{
    "astropy__astropy-11693": {
        "explanation": "The issue is reasonably well-specified. It clearly describes a problem where the 'WCS.all_world2pix' function fails to converge when plotting a WCS with non-linear distortions. The user provides the expected behavior (adding the 'quiet=True' parameter to suppress the error and achieve the desired plot), the actual error behavior, and steps to reproduce the issue with a code snippet. This is sufficient to understand the problem and start working on a solution, although there might be some blanks to fill in regarding the exact implementation details and testing requirements.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-12544": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The request is to add a keyword argument to the `Table.read()` function that disables the automatic creation of `MaskedColumn` and `MaskedTable` when encountering NaN values. The problem is clearly described, along with the current behavior, the desired behavior, and a specific example of how the new functionality would be used (with a `mask=False` keyword). This provides sufficient detail for an experienced software engineer to implement the requested feature.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-12825": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of the current behavior and the expected behavior. The error message is provided, which gives insight into the root cause. The example code shows how to reproduce the issue, and the expected outcome is defined as aggregation working except for cases where it doesn't make sense. This provides a clear target for a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-12842": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, the expected vs. actual behavior, steps to reproduce the issue, and the system details. The user has also identified the specific commit that introduced the issue and provided the error message and a relevant code snippet. This information allows a software engineer to understand the problem and develop a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-12880": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, the expected and actual behavior, steps to reproduce the issue, and the system details. The user is facing a problem with reading a specific file format after an upgrade, which is a common issue in software development. The problem is related to a specific change in the codebase (a commit that introduced strict type checking), and the user is suggesting a possible solution (scaling back the strict type checking or adding datetime64 as an allowed type). The issue also includes the full error log, which can help in understanding the problem. Therefore, the issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-12891": {
        "explanation": "The issue is reasonably specified as it describes the problem with the `where` keyword argument in `np.mean` not being supported for `astropy.units.Quantity` instances. It also mentions that the feature was added in numpy version 1.20.0 and indicates a possible direction for a solution, which is updating `astropy.units.Quantity` to support this feature. However, it lacks specific details on how exactly this support should be implemented and what the expected behavior is when using `where` with `astropy.units.Quantity`. Therefore, there are some blanks to fill in, but there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-12907": {
        "explanation": "The issue is well-specified. It provides a clear example of the expected behavior of the `separability_matrix` function for different compound models and highlights a discrepancy when models are nested. The problem is described with reproducible code snippets and expected vs. actual outputs. This allows for a meaningful attempt at a solution by investigating how the function handles nested compound models.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-12962": {
        "explanation": "The issue is well-specified and clear. It explains the current limitations in converting a CCDData object to an ImageHDU, provides examples of the existing functionality (reading an ImageHDU into a CCDData object), and proposes specific solutions (options A, B, and C). The problem and desired outcome are clearly defined, making it possible to implement a meaningful solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13032": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example and expected output. The discrepancy in behavior when ignoring different inputs is highlighted. The user provides code samples that demonstrate the incorrect behavior and shows what the correct output should be. This provides enough information for a developer to understand what needs to be fixed in the ModelBoundingBox implementation regarding how it handles ignored inputs.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13033": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, with a specific example of the current behavior and the expected behavior. The steps to reproduce the issue are provided, allowing for testing and verification of any potential solution. The error message is identified as the main problem, and the goal is to change it to be more informative for users.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13068": {
        "explanation": "The issue is reasonably specified. The reporter provides a clear example of the problem, showing that converting a time string to a JD and back results in a loss of precision. They also show the code they are using, which helps in understanding the context and the expected behavior. However, there are some missing details such as the expected output or the desired behavior that would need to be inferred or clarified. For instance, it is not explicitly stated what the precision should be after the conversion, but it can be reasonably assumed that the goal is to maintain the original precision when converting between formats. Therefore, the issue is reasonably specified and a solution can be attempted with some assumptions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13075": {
        "explanation": "The issue is reasonably specified. It outlines the goal of registering an HTML format with the Cosmology.write method, suggests using MathJax for formatting, and provides examples and documentation references. However, there are some details that are not explicitly provided, such as the exact implementation steps for the write_html method, how to integrate MathJax into the HTML table, and the specifics of storing the MathJax representation on the Parameter object. These details would need to be inferred or researched based on the provided references.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13132": {
        "explanation": "The issue is reasonably well-specified, but there are some blanks to fill in. The main goal is clear: to add numpy array functions for `astropy.time.Time` objects, allowing operations like `np.linspace` to work without errors. However, the specific function `__array_func__` to be implemented is not detailed beyond its purpose, and the exact implementation steps are not provided. Additionally, the issue mentions that tests, 'what's new' documentation, and API docs still need to be added, which are not fully specified. Despite these gaps, a sensible interpretation of the requirements exists, making it possible to proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13158": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem, a minimal reproducible example, and a traceback showing where the error occurs. The issue also identifies the specific code location (L2703-L2704 in core.py) where the problem likely lies and suggests that more sophisticated logic is needed for handling MagUnit type values. This gives a clear starting point for investigation and resolution. The system details are also provided for context.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13234": {
        "explanation": "The issue is reasonably specified as it provides a clear description of the problem, expected behavior, steps to reproduce the issue, and relevant system details. However, some blanks may need to be filled in regarding the exact implementation details of the serialization format tweak that is suggested. There is a sensible interpretation of what is required for a successful solution, but additional information may be needed to fully understand and implement the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13236": {
        "explanation": "The issue is reasonably specified. The problem is clearly described, and the proposed solution includes adding a FutureWarning and changing the behavior in a future version. There are specific code references and a context explanation. However, some details about implementation might need further exploration, but the general approach is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13306": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, a minimal working example to reproduce the issue, the error traceback, and system details. The problem occurs when using `table.vstack` on tables with specific structured array columns, and the expected behavior is that it should work without a casting error. The code examples show the difference between a working and failing case, making it clear what needs to be fixed. The traceback points to specific lines in the code where the issue occurs, which helps in understanding where the problem is happening.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13390": {
        "explanation": "The issue is about test failures in the Astropy library when using a specific version of NumPy (1.23.0rc3). The provided information includes detailed error messages from test failures, including the specific test names, exception types, and stack traces. The root cause seems to be related to numpy's handling of comparisons between different string types (Unicode vs bytes), which was working before but is now causing failures. The problem is with the `Column` and `MaskedColumn` classes in Astropy's table module, specifically their comparison operations. The error messages clearly indicate what is failing and where in the code. While there might be some interpretation needed about the exact fix (whether to handle the comparison differently, enforce type conversion, or add error handling), the problem is well-defined and it's clear what the expected outcome should be (passing tests that are currently failing). Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13398": {
        "explanation": "The issue is reasonably well-specified for a meaningful attempt at a solution. The description provides a clear problem statement regarding the recurring issues with the ITRS to AltAz transform in the Astropy library. It explains the current problem with geocentric versus topocentric aberration and provides a specific approach to solve it by staying entirely within the ITRS. The issue also includes working code samples that demonstrate the proposed solution, which makes it concrete. However, there are some aspects that are not fully clear: the exact requirements for handling different frame types (AltAz vs HADec), the specific conditions under which this approach should be used, and the potential impact on existing functionality. The developer would need to make some reasonable assumptions about these aspects while implementing the solution. Overall, the issue provides enough context and guidance for a developer to make meaningful progress on the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13404": {
        "explanation": "The issue is reasonably specified as it provides a clear description of the problem, expected behavior, actual behavior, and steps to reproduce the issue. However, some blanks need to be filled in regarding the implementation details of the ``_array2string `` function and how it should handle structured dtypes. The issue gives a specific example of the error occurring, which can be used to create a test case and verify the solution. Therefore, the issue is reasonably specified and a solution can be attempted with the given information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13453": {
        "explanation": "The issue is well-specified. The user explains that the 'formats' option is not working for HTML output in the 'write()' method, while it works for other formats like CSV and RST. They provide a clear description of the problem, expected behavior, actual behavior, and steps to reproduce it with code examples. This information is sufficient for an experienced developer to understand the issue and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13462": {
        "explanation": "The issue is reasonably specified because it provides a test failure, a comparison of failing and successful logs, and a code snippet showing the problem. However, some details about the expected behavior and the specific environment differences (like pyinstaller) are not fully explained.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13469": {
        "explanation": "The issue is reasonably specified. It explains the problem with converting a list of Astropy tables to a NumPy array, the error encountered, and the possible solution (allowing dtype=object to pass through). While it doesn't give exact implementation details, an experienced developer would understand what needs to be changed in the code (i.e., modifying the __array__ method to handle dtype=object specially).",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13477": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a specific example of comparing a Frame instance and a SkyCoord instance with the same data. The expected behavior is stated (returning true/false based on data) and the actual behavior is an exception. The steps to reproduce the issue are provided, and the error traceback is included which points to the specific part of the code where the error occurs. This information is sufficient for a developer to understand the issue and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13579": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The issue provides a clear description of the problem, steps to reproduce the issue with code examples, and even shows the unexpected output versus the expected output. It also provides system details and references to the original issue. This information is sufficient for an experienced developer to understand the problem and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13668": {
        "explanation": "The issue is reasonably specified but has some gaps. It describes the problem (wcslint crashes on valid WCS) and provides examples with error outputs. The code references are clear, and it suggests potential areas to investigate (either the WCS object or how validator calls it). However, it lacks specific details on the expected behavior, steps to reproduce beyond the examples, and the exact environment or dependencies causing the issue. These gaps would require some assumptions or further investigation to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13745": {
        "explanation": "The issue is well-specified. The problem is clearly described: the float32 representation of pi/2 is slightly larger than pi/2 when represented as a float64, which causes it to be rejected by the Latitude class in Astropy. The expected behavior is to be lenient and only compare up to float32 precision. The actual behavior is shown with the error message. Steps to reproduce are provided with the code snippet. The system details are also provided. All necessary information is included to understand the problem and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13803": {
        "explanation": "The issue is well-specified. The problem is clearly described: the float32 representation of pi/2 is being rejected by the `Latitude` function in Astropy because the float64 comparison results in a value slightly outside the valid range. The expected behavior is to be lenient and perform comparisons only up to float32 precision. The actual behavior is demonstrated with an error, and the steps to reproduce are provided. The issue provides enough context and details for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13838": {
        "explanation": "The issue is reasonably specified. It describes the problem with printing tables when there are 0-length array cells, provides the expected and actual behavior, includes steps to reproduce the error with sample code, and shows the traceback. However, there are some details missing, such as the exact format of the data and the expected output when the fix is applied, which would help in implementing a solution. The problem seems to be related to how the astropy library handles empty arrays in table cells during the formatting process. A developer would need to look into the _pformat_col_iter function and how it deals with empty arrays to prevent the IndexError. The solution would likely involve adding a check for empty arrays and handling them gracefully in the formatting process.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-13933": {
        "explanation": "The issue is well-specified because it includes a clear description of the bug, steps to reproduce the problem with a code example, and system details. The problem is that after pickling and unpickling an Angle object, the to_string method fails with a specific error. The code example demonstrates the issue by showing that the original object works but the pickled/unpickled one does not. This provides enough information for a software engineer to investigate and resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-13977": {
        "explanation": "The issue is reasonably specified.  The problem is clearly described, with a minimal working example and a detailed explanation of the error.  The proposed solution (changing the return value of `__array_ufunc__` from raising `ValueError` to returning `NotImplemented`) is also presented.  However, there are some implicit assumptions.  The success of the solution is dependent on how the `__array_ufunc__` method is implemented in `astropy.units.Quantity`, and how `NotImplemented` is handled in the context of ufunc operations.  The issue is not perfectly clear on how the change would affect existing functionality and potential side effects.  A successful solution would require a deeper understanding of the `astropy` codebase and the `__array_ufunc__` protocol.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14096": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the code that reproduces the issue, the expected behavior, and the actual behavior. The user explains that when a property in a subclass of SkyCoord tries to access a non-existent attribute, the error message is misleading and points to the property instead of the actual missing attribute. This is enough information for an experienced developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14182": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a code example showing the current behavior and the desired behavior. The user wants to support header rows in the RestructuredText output of the Astropy library when writing tables. The example shows how it would work for the 'ascii.fixed_width' format, and how it fails for 'ascii.rst' with an error about the 'header_rows' parameter not being recognized. This gives a clear target for the solution: to modify the RST writer to support the 'header_rows' parameter in the same way as the fixed_width format. The additional context explains the motivation, making it clear why this feature would be useful. The error message also points directly to the line of code that needs to be fixed, helping to locate where in the codebase the change needs to be made. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14253": {
        "explanation": "The issue is discussing the behavior of the `__array_finalize__` method in the `Quantity` class, specifically how the `info` attribute is passed on during various operations. The issue provides a detailed list of operations and categorizes them into three groups: 'Surely for', 'Probably for', and 'Probably not for' in terms of whether `info` should be propagated. This categorization provides a clear framework for determining the desired behavior. The issue also references current implementation details and suggests that the behavior may be adjusted with changes to `__array_finalize__`. While there are some subjective elements in the categorization (e.g., 'Probably for'), there is enough information to make a meaningful attempt at a solution by implementing the suggested behavior for each category. Therefore, the issue is reasonably specified, with some blanks to fill in, but a sensible interpretation is possible.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14295": {
        "explanation": "The issue is well-specified and provides a clear problem statement, expected vs actual behavior, steps to reproduce, and even sample code and images to demonstrate the issue. The problem seems to be that when SIP keywords are present, PV keywords are being ignored by astropy, and the PR proposes to remove the heuristic code causing this behavior. All the necessary details are provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14309": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear error message (IndexError: tuple index out of range), a detailed stack trace showing where the error occurs, a clear explanation of what changed in the Astropy library commit that caused the issue, and a reproduction script. The issue also explains the root cause - when a file path without a FITS extension is passed to the identify_format function, it's now trying to access args[0] which doesn't exist, causing an IndexError. This gives a clear understanding of what needs to be fixed in the code. The solution would involve modifying the is_fits function in fits/connect.py to handle cases where args[0] doesn't exist rather than trying to access it directly.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14365": {
        "explanation": "The issue is well-specified with a clear description of the problem, expected behavior, and steps to reproduce. The problem is that the ascii.qdp format in astropy assumes QDP commands are in uppercase, but QDP is case-insensitive. The expected behavior is that a qdp file with lowercase commands should be read into a Table with errors instead of crashing. The How to Reproduce section provides a clear example of the problem. All necessary information is provided to understand and solve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14369": {
        "explanation": "The issue is well-specified. It includes a clear description of the problem, expected behavior, steps to reproduce the issue, and the observed incorrect behavior. The input file format and the expected output are clearly defined, making it possible to understand what the solution should achieve. The issue also provides the software version and environment, which helps in replicating and debugging the problem.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14371": {
        "explanation": "The issue is reasonably specified. The request is to add an ``atol`` argument to the ``is_O3`` function or to use the maximum precision of the matrix dtype instead of the current arbitrary value of 1e-15. While the general direction is clear, there are some implementation details that need to be filled in. For example, it's not explicitly specified how to determine the maximum precision of the matrix dtype, whether it should be based on the data type's epsilon or machine precision, and how the ``atol`` parameter should be integrated into the function's logic and interface. However, these are standard considerations in numerical computing, and there are conventional approaches for determining data type precision and adding tolerance arguments to functions. The task is achievable with reasonable assumptions about best practices in numerical computing.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14379": {
        "explanation": "The issue is reasonably specified. The problem is described with an example showing the current behavior of Angle.to_string, and the desired change is to add a boolean keyword argument to optionally include a space between the value and unit. The issue also proposes a potential alternative solution (changing the default behavior to match Quantity's default). While there are some implementation details to consider (such as the name of the boolean keyword, where to add it, and whether to change the default behavior), the overall goal is clear and actionable for an experienced developer familiar with the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14413": {
        "explanation": "The issue is well-specified with a clear description of the problem, expected behavior, and steps to reproduce. The problem is that unit representations in certain formats include an extraneous space at the beginning, and the expected behavior is that no such space should be present. There are specific examples provided that demonstrate the current incorrect behavior versus the expected correct behavior. The problem is well-defined and it is clear what the solution should accomplish.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14439": {
        "explanation": "The issue is reasonably specified. The problem is that the FITS unit definition for 'Jy/beam' in Astropy is different from the convention used by radio astronomy packages. The current export is 'beam-1 Jy', but the convention is 'Jy/beam'. The issue provides a code snippet to reproduce the problem and references to related issues in other packages. However, the exact steps to resolve the issue are not provided, and the solution may involve changes to the Astropy unit definitions. The issue is clear enough to understand the problem and its impact, but some details about the desired implementation are missing.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14508": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, expected behavior, and steps to reproduce. It also includes specific code examples, a sample file, and references to the relevant code section. This information allows for a direct approach to address the float string representation issue in `io.fits.Card`.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14528": {
        "explanation": "The issue is well-specified. The problem is clearly described: `ImageHDU` accepts zero-dimensional data which leads to corrupt FITS files. The expected behavior is stated as `io.fits` should not silently create corrupt files. A minimal reproducible example is provided, along with version information. All necessary information is present for a developer to understand the issue and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14539": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem, the expected behavior, and a detailed reproduction script. The suspected cause (improper handling of VLAs) is mentioned, and the issue includes information about the environment and versions of relevant packages. All necessary information is provided to understand and address the problem.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14566": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with a detailed explanation of the unexpected behavior when using the 'decimalyear' type with the MaskedColumn type. There is a comparison with the 'jyear' type, which works as expected. The issue also includes a complete code example that reproduces the problem and provides the expected versus actual behavior. However, the exact expected output when using 'decimalyear' with a MaskedColumn is not clearly stated, and the specific error message or behavior is not provided. Despite these minor gaps, the information provided is sufficient to understand the issue and attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14578": {
        "explanation": "The issue is well-specified because it clearly describes the problem (writing a table with objects to FITS fails), provides a minimal working example, a non-working example, and the exact error message. It also explains where the error occurs in the code and suggests a possible direction for a solution (handling objects by string representation or better error message). This provides all necessary information to investigate and resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14590": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The error message indicates a TypeError: 'cannot write to unmasked output' when using the np.fix function with numpy-dev. However, the issue lacks specific details about the expected behavior and the context in which this error occurs. The description does not clearly state what the intended fix should be or what the expected outcome is after implementing the solution. The code snippet and error trace are provided, but without a clear problem statement and desired resolution, it is challenging to determine the correct approach to address the issue. Therefore, it is considered vague as it does not provide enough information to understand what a successful solution would look like.",
        "label": "VAGUE"
    },
    "astropy__astropy-14598": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with specific examples of the inconsistency in handling double single-quotes in FITS cards. The issue includes code snippets that reproduce the problem, expected behavior, and the actual observed behavior. The input and output of the test cases are provided, showing exactly when the issue occurs. Additionally, the environment information is given. All of these details make it clear what needs to be fixed and how to verify the fix. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14701": {
        "explanation": "The issue is reasonably specified. It asks to register a latex method with Cosmology.write, and provides examples and documentation links. The intended functionality is to export a Cosmology to a LaTeX table, formatting it appropriately. While there are some details that need to be filled in, such as the exact formatting rules and implementation specifics, the general direction is clear enough for a meaningful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14702": {
        "explanation": "The issue is well-specified. It clearly describes a problem where the representation of votable.tree.Table is the same as table.Table, causing confusion. It provides a specific suggestion to change the votable case representation from <Table length=4> to <VOTable length=4>. The issue includes a clear example demonstrating the current behavior and the desired change. This provides enough information for a software engineer to understand the problem and implement the suggested solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14938": {
        "explanation": "The issue is reasonably well-specified but has a few missing details. The main task is clear: add the 'ascii.latex' registration label to Cosmology IO. However, there are some missing details that require interpretation. The issue mentions that this is for Cosmology write methods that leverage Table, but it doesn't specify which exact methods need this change or where the registration is currently implemented. The developer would need to look through the codebase to identify the relevant write methods and understand how the current registration system works. The reference to Table having both 'latex' and 'ascii.latex' provides a useful analogy, but the exact implementation details of Cosmology IO's registration system are not provided. The task is doable with reasonable assumptions and codebase exploration, but some interpretation is needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-14966": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal example showing the current behavior and the expected behavior is clearly stated. The example demonstrates that when grouping a QTable with a column containing a quantity, the keys only contain the float value without the unit. The expected behavior is that the keys should contain the full quantity with the proper unit. The example provides a clear way to reproduce the issue, and the versions of the software involved are provided. All necessary information to understand the problem and what needs to be fixed is present.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14991": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is identified as an incorrect equation in the `w0wzcdm.py` file, specifically line 205. The issue provides a clear expected fix by showing the correct equation that should be used. Additionally, the issue explains why the change is needed (based on manual calculation and verification with Wolfram). While the issue doesn't include specific steps to reproduce the error (since the code snippet is missing), the problem is clearly defined enough to allow for a meaningful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-14995": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: mask propagation fails when one operand doesn't have a mask in NDDataRef arithmetic operations with handle_mask=np.bitwise_or. The issue includes a detailed description, expected behavior, and clear reproduction steps with test cases showing what works and what fails. The error message is provided, and it contrasts between versions 5.2 and 5.3. This information would allow a software engineer to understand what the problem is, what the expected behavior should be, and how to reproduce and test the fix.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-6938": {
        "explanation": "The issue is reasonably specified. The problem is identified in the code, and the explanation is given. The code may be incorrect due to the replace method not being in-place, and it's not being tested. It's clear what the problem is and what the proposed solution would involve.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-7008": {
        "explanation": "The issue is reasonably specified. It describes the need for a context manager that sets the version of constants, with an example of how it might be used. However, it lacks some details about the implementation, such as how to handle different versions of constants, what exactly 'astropyconst13' refers to, and how the context manager should interact with existing code. These details can be reasonably inferred or clarified during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-7166": {
        "explanation": "The issue is reasonably specified. It identifies a problem with the InheritDocstrings metaclass not working for properties and explains that this is due to the use of `inspect.isfunction` which returns False for properties. A solution would likely involve modifying the metaclass to properly handle properties, perhaps by checking for properties in addition to functions. Some details about the desired behavior or implementation specifics may still need to be determined, but the core issue is clear enough to start working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-7218": {
        "explanation": "The issue is well-specified. It provides a clear problem statement that HDUList.copy() returns a list instead of an HDUList. It includes a code example that demonstrates the current behavior, showing that the output of hdulist.copy() is a list. The goal is to change the behavior so that it returns an HDUList instead of a list. There is no ambiguity in what needs to be fixed - the function should be modified to return an HDUList object rather than a list. The code example provides a clear way to test the fix.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-7336": {
        "explanation": "The issue is well-specified with a clear summary, a reproducible example, and an explanation of the error. It also includes information about the environment and a suggested workaround. The problem description is clear enough to understand what is wrong and what a potential solution might involve. The decorator is trying to apply a unit conversion to the return value, but since the constructor returns None, it fails. A fix would involve modifying the decorator to handle cases where the return value is None by skipping the unit check. This is a clear and specific task.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-7441": {
        "explanation": "The issue is reasonably specified.  It clearly states that the `astropy.time.TimeDelta` class should support conversion to `datetime.timedelta` and suggests a method name (`to_timedelta`) and desired output.  The problem with the existing `to_datetime` method is also mentioned.  While the issue also mentions conversion to `np.datetime64` and `np.timedelta64`, it is marked as 'would also be great', indicating these are less critical and potentially optional.  A developer could implement the core functionality (the `to_timedelta` method) based on the information provided, even if the details of the NumPy conversions require further consideration.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-7606": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem: when comparing an UnrecognizedUnit instance with None using the equality operator, a TypeError is raised instead of returning False as expected. The issue provides a code example that reproduces the error, shows the traceback, and indicates what the expected behavior should be. This information is sufficient to understand what needs to be fixed in the __eq__ method of the Unit class. The solution would likely involve modifying the __eq__ method to handle comparisons with None by returning False instead of attempting to create a Unit from None.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-7671": {
        "explanation": "The issue is well-specified with a clear description of the problem, including the error traceback, examples of when it fails and when it doesn't, and a comparison with another implementation that works. The issue also references the specific PR that caused the regression and the related Python bug report. This provides all the necessary information to understand the problem and create a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-7737": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific example and the cause is identified (0/0 division when variance is zero). The suggested solution is also clear - to catch this special case and return the median instead of nan. The expected behavior is defined (returning the expected value of 1 for an array of ones). A developer would have enough information to implement a fix for this specific issue.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-7973": {
        "explanation": "The issue is asking for a vote on which approach to take for recording data size in the WCS object, but it doesn't clearly specify what the actual task is. It mentions two proposed ways but doesn't state which one should be implemented. Without knowing which approach to take, it's impossible to create a meaningful solution. Additionally, the issue is more of a discussion and decision-making thread than a specific task to implement. Therefore, it's impossible to solve without further information.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "astropy__astropy-8005": {
        "explanation": "The issue is reasonably specified. It points out an inconsistency in the use of cosmologies in two different equivalency functions. The first uses Planck15 explicitly, while the second uses the default cosmology (currently WMAP9). The request is to make these more consistent for the 3.1 release. However, there are some decisions to be made about what form the consistency should take. For example, should both use the explicit Planck15 cosmology, or should the default cosmology be changed to Planck15 and both use the default? The issue also mentions that this is related to another issue about changing the default cosmology, which provides some context but doesn't fully specify the solution. A developer would need to understand the context of the default cosmology setting and how it relates to these two functions to implement the fix properly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-8263": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce it, and context about the environment and the first bad commit. The provided code example and error message give enough details for someone to understand and attempt to solve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-8339": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific error message (UnboundLocalError: local variable 'ncp_prior' referenced before assignment) and the exact location of the bug in the code (line 373 in bayesian_blocks.py). The reporter even provides a fix by adding an 'else' clause to handle the case when 'self.ncp_prior' is not None. This gives a clear path for implementing the solution. The input that causes the issue (calling bayesian_blocks with 'ncp_prior=ncpp') is also provided, making it possible to reproduce and test the fix. The explanation of the problem and the suggested solution are both clear and actionable, leaving little ambiguity about what needs to be done to resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-8519": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the code that reproduces the issue, the expected behavior, and the actual error encountered. The problem is about adding/subtracting ABmag quantities losing the type of magnitude, which is a specific issue with the unit handling in the astropy library. The user explains what they expect to happen (the difference should also be an ABmag) and shows the error that occurs when trying to convert the result to nJy. This is sufficient information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-8707": {
        "explanation": "The issue is well-specified. The problem is clearly described: the `Header.fromstring` method does not accept Python 3 bytes as expected. The issue explains what the method is supposed to do according to the documentation and highlights the discrepancy between Python 2 and Python 3 behavior. It also suggests a solution direction (changing the method to accept both unicode and bytes string types) and even indicates that `Card.fromstring` may need similar treatment. All necessary information for implementing a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "astropy__astropy-8747": {
        "explanation": "The issue is reasonably specified. It mentions that `np.clip` will be based on a `ufunc` starting from numpy 1.17 and that the goal is to ensure it works properly with `Quantity`. While it provides a general direction, there are some details missing, such as specific requirements for the integration with `Quantity` or any constraints. However, an experienced developer would be able to interpret the general direction and know what steps to take to make `np.clip` compatible with `Quantity` by adapting it to work with the `ufunc` implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "astropy__astropy-8872": {
        "explanation": "The issue is well-specified. The problem is clearly described with examples showing the unexpected behavior when creating a `Quantity` from a `np.float16` which gets upgraded to `np.float64`. The issue also shows how other float types behave correctly. The reporter mentions that this was discovered during experimentation, but the behavior is clearly demonstrated with code examples. A software engineer would be able to reproduce the issue and understand what the expected behavior should be based on the examples provided for other float types. The reference to a related issue (#6389) also provides additional context that could be useful for solving the problem.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10097": {
        "explanation": "The issue is well-specified. The problem is clearly described: the URLValidator should reject URLs with invalid characters in the username and password fields, as per RFC 1738. An example of an invalid URL that is currently accepted is provided. The specific characters that need to be encoded are mentioned. The pull request reference provides additional context and indicates that this is a real-world problem that has been encountered in production. The concern about adding complexity to the validation regex is also mentioned, but the issue is still well-defined and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10213": {
        "explanation": "The issue is well-specified. It clearly states the problem (Django disables colors when output is piped), the desired solution (add a --force-colors flag similar to other *nix commands), and the use-case (custom Django command to import data and generate colored logs for data curators). The reporter also provides a real-world example and even references another utility (aha) that is not working because of the current behavior. The issue is clear, actionable, and the expected outcome is well-defined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10301": {
        "explanation": "The issue is reasonably specified. The problem is that using a NULL value in a Django annotate with a mathematical operation (in this case, exponentiation) is causing an OperationalError in the SQLite backend. The user has provided a clear example of the problem, including the traceback. However, there is no explicit instruction on how to resolve this issue or what the expected behavior should be when NULL is raised to the power of NULL. A solution would need to determine if Django should handle this case gracefully, perhaps by returning NULL instead of raising an error, or if there should be validation to prevent such operations. Therefore, some interpretation is needed to implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10316": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the current behavior, the expected behavior, and a specific code change that would resolve the issue. The user explains that when using settings.configure(), diffsettings raises an exception because it calls settings._setup() unconditionally. The user provides the correct condition to check before calling _setup(), which would fix the issue. This provides all the information needed to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10390": {
        "explanation": "The issue is reasonably well-specified as it provides a test case that demonstrates the problem and the expected outcome. However, there are some implementation details that need to be filled in, such as how exactly to pass the 'is_dst' resolution parameter to the Trunc function and how to handle the timezone conversions in Django. The provided code example shows the current behavior and the expected behavior, which gives a clear direction for the solution. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10426": {
        "explanation": "The issue is reasonably specified. It indicates that app_label validation should be added to the showmigrations command, referencing similar changes in other commands. While the exact nature of the validation isn't detailed, the context and references to previous tickets give a clear direction for implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10531": {
        "explanation": "The issue is well-specified. It clearly describes the problem (history messages use field names instead of verbose names), provides an example (pub_date field with verbose name 'date published'), and explains the expected behavior (displaying 'Change date published.' instead of 'Changed pub_date.'). The issue also references that older versions of Django did this correctly, which gives context and shows what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10554": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue provides a detailed description of the problem, including a minimal reproduction example that clearly demonstrates the bug. The problem is about a query that breaks when ordering is applied in a union query, and the issue even references a related ticket (#29692) which can provide additional context. The provided example shows the exact code that reproduces the issue, the expected and actual outputs, and the error traceback. This information is sufficient for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10606": {
        "explanation": "The issue is well-specified. It clearly describes the problem (an exception when using RelatedOnlyFieldListFilter with a reverse ManyToMany relation), provides a specific error message, identifies the method and parameter that are causing the issue, and includes a pull request and a demo to reproduce the bug. All necessary information is provided to understand and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10643": {
        "explanation": "The issue is reasonably specified. It describes the problem with the icontains lookup for UUIDs in the Django admin when using Oracle. It explains that the UUID is displayed with dashes, and the search should work with the displayed value. The problem is specific to Oracle, and the user wants the search to work with UUIDs both with and without dashes. There are some details to work out, such as the exact implementation of the workaround and how to handle it in Django, but the overall goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10737": {
        "explanation": "The issue is reasonably specified. The request is to modify FieldError exceptions to include the field that caused the error in the error message. While it doesn't provide exact code changes or specific locations to make the changes, it does provide enough context (specific file and general locations) to understand what needs to be done. The person would need to review the compiler.py file to find where FieldError is raised and update those instances to include the field in the error message.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10853": {
        "explanation": "The issue is well-specified. It clearly explains the problem (window functions not being supported in older SQLite versions used with Python 3.6.7 and 3.7.1), provides the expected behavior (Django should check for support and raise an error before executing SQL), and includes a reproducible example with code snippets and test environment details. All necessary information is provided to understand the issue and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10880": {
        "explanation": "The issue is reasonably specified. The problem is that a Count annotation with both a Case condition and a distinct=True parameter causes a query error in Django 2.2. The issue mentions that a space is missing, which gives a hint about the nature of the problem. While the specific code to reproduce the issue and the exact expected behavior are not provided, the general problem and its context are clear enough for a developer to investigate and find a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10904": {
        "explanation": "The issue is well-specified. It clearly states the task of replacing the use of various OSError aliases (IOError, EnvironmentError, etc.) with the OSError exception in the Django codebase. It provides the motivation (Python 3.3 changes) and the relevant documentation links. A software engineer can understand what needs to be done and how to approach it. The task is specific and actionable, making it well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10910": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the incorrect behavior when using timezone(timedelta(...)) with Django ORM and PostgreSQL. It explains how PostgreSQL interprets POSIX-style time zones differently, leading to incorrect timezone shifts. The issue includes a sample model, test cases that demonstrate the problem, and even shows the exact SQL query generated by Django that causes the issue. The expected vs actual behavior is clear from the examples. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-10914": {
        "explanation": "The issue is reasonably specified. It provides a clear problem statement about the inconsistency in file upload permissions when using Django's FileSystemStorage. It explains the root cause as being the use of different temporary file handling mechanisms (MemoryUploadedFile vs. TemporaryUploadedFile) which result in different final permissions. The issue also provides a concrete suggestion for a solution - setting a default FILE_UPLOAD_PERMISSIONS value of 0o644. While there are some implementation details that would need to be worked out (like exactly how to apply this setting across different storage systems), the core problem and proposed solution are clearly articulated. The issue also provides context about where this behavior is observed (CentOS 7.4.1708 with Python 3.6.5) and references existing GitHub discussions about the topic.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10939": {
        "explanation": "The issue is not well-specified and lacks sufficient detail for a meaningful attempt at a solution. The problem description is vague and does not provide clear information about the expected behavior versus the actual behavior. It is unclear what specific conditions cause the issue and what exactly needs to be fixed. The issue would benefit from a more detailed explanation, steps to reproduce the problem, and any error messages or logs that could help in diagnosing the issue.",
        "label": "VAGUE"
    },
    "django__django-10973": {
        "explanation": "The issue is reasonably specified. It suggests using subprocess.run with PGPASSWORD for a PostgreSQL client in a Django backend. While it provides context about Python 3.5 compatibility and the benefits of using subprocess.run, the exact implementation details, such as how the environment should be modified and where exactly in the Django codebase the changes should be made, are not clearly defined. A developer would need to interpret these aspects to create a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10989": {
        "explanation": "The issue is reasonably specified because it describes a problem with ellipses in output strings causing crashes on Windows, provides a traceback, and explains the underlying cause related to code page 437. However, some details about the exact location of the problematic ellipsis character and the specific files or modules where it needs to be replaced with \"...\" are missing. The solution involves identifying and replacing the ellipsis character, but the issue does not provide a complete list of locations to check, requiring some investigation to locate the exact source of the ellipsis in the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10997": {
        "explanation": "The issue is reasonably specified. It suggests adding the applied datetime to the showmigrations command, which is a clear goal. The context about needing this for managing migrations across branches is provided, which helps understand the use case. The mention of the --list option and verbosity level 2 and above gives some direction on how the feature should be implemented. However, the exact format of the datetime display, how to handle existing commands, and potential backward compatibility concerns are not fully detailed. These details would need to be worked out during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-10999": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the specific regex pattern that needs to be fixed and the suggested correction. The explanation clarifies why the current regex fails to match negative durations and provides the exact change required. A developer would be able to understand the issue and implement the fix without needing additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11003": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11019": {
        "explanation": "The issue is well-specified. It provides a detailed example of the problem, including code that reproduces the issue, the expected outcome, and the actual outcome. The explanation of why the current implementation is incorrect is also provided, as well as the unintuitive nature of the warning. All necessary information for understanding the problem and implementing a solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11057": {
        "explanation": "The issue is about a problem when upgrading from Django 2.1 to 2.2b1 where a custom authentication middleware that subclasses the base AuthenticationMiddleware is no longer accepted by the admin check, which requires the exact class 'django.contrib.auth.middleware.AuthenticationMiddleware' to be in MIDDLEWARE. The user is asking whether this is a bug/regression or if they have been using the middleware incorrectly. The problem is well-specified with a clear description of what is happening, what change occurred (upgrade), and what error is being encountered (admin.E408). It also provides context about their custom middleware implementation. There is enough information to understand the issue and determine whether it's a bug or a change in expected behavior.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11062": {
        "explanation": "The issue is well-specified with a clear description of the problem, a minimal example to reproduce the issue, and details about the error message. The user explains that using an annotated field calculated with django.db.models.functions.Extract in an aggregate results in a ProgrammingError. They provide a code snippet that reproduces the issue, the expected behavior, the actual error, and the versions of Django and PostgreSQL they are using. This information is sufficient to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11066": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific lines of code that need to be changed, the expected behavior, and the actual behavior. The proposed solution is also provided. The context of the issue is also explained, including the use of a dynamic database router and the error that occurs. All the necessary information to understand the issue and how to fix it is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11070": {
        "explanation": "The issue is reasonably well-specified, but there are a few areas where interpretation is needed. The main task is clear: add autocomplete attributes to contrib.auth fields with specific values (username, email, current-password, new-password). However, the exact implementation details may require some interpretation, such as which specific forms and fields these attributes should be applied to. The pull request link provides additional context, but without direct access to the codebase and the pull request, some assumptions may be needed about how to integrate these changes. The provided documentation links help clarify the purpose and expected behavior of the autocomplete attributes, but the actual implementation will depend on the existing structure of the contrib.auth forms in Django.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11087": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear problem description (UnicodeDecodeError during .delete() operation), a detailed STR (Steps To Reproduce), the actual vs expected behavior, and even points out specific code locations where the issue occurs. The issue identifies the root cause as Django fetching unnecessary fields that cause decoding errors, and suggests that optimizing .delete() to use only required fields would fix the problem. This gives a clear direction for the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11088": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the steps to reproduce the error, the environment (Python 3.6.0, Django 1.10.6, Postgres 9.5.4), and the error message that occurs. The issue involves a migration problem with BinaryField when using a non-bytestring default value and then trying to undo the migration. The report even provides a possible fix in the code by checking if the field is a BinaryField and handling the default value appropriately. All the necessary information to understand the problem and implement a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11095": {
        "explanation": "The issue is reasonably specified. The request is to add a new hook method called get_inlines to the ModelAdmin class, which would allow developers to set inlines based on the request or model instance. While the overall goal is clear, there are some implementation details that would need to be worked out, such as how exactly this new hook would integrate with the existing codebase, what parameters it would accept beyond what's mentioned, and how it would interact with the existing get_inline_instances method. However, the general direction and purpose of the change are clear enough to proceed with a sensible interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11099": {
        "explanation": "The issue is well-specified. The problem is clearly described (username validators allowing trailing newlines), the cause is explained (regex $ matching trailing newlines), and the solution is provided (changing regex to use \\A and \\Z instead of ^ and $). The exact files to modify (ASCIIUsernameValidator and UnicodeUsernameValidator) and the specific regex to use are given. A successful solution would involve making this regex change in the two specified validators.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11115": {
        "explanation": "The issue is reasonably specified. The user is requesting that the AlreadyRegistered exception provide more information to help identify which package or app is causing the clash when a model is already registered. This is a clear problem, but there are some implementation details that are not explicitly mentioned, such as how to track down the offending models and what additional details to include in the exception. However, a sensible interpretation would be to modify the exception message to include the app label or the package name that initially registered the model. This is a common approach in Django for such issues, and the context provided in the issue gives a good understanding of the problem. Therefore, it is reasonably specified enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11119": {
        "explanation": "The issue is well-specified. It clearly describes the problem: the Engine.render_to_string() method is not honoring the autoescape attribute when creating a Context. It explains that even if the engine is created with autoescape=False, the render_to_string() method still autoescapes the result. It also references a specific commit where this might have been overlooked. A developer would understand that the fix would involve modifying the render_to_string() method to ensure it passes the engine's autoescape setting when creating a Context.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11129": {
        "explanation": "The issue is not well-specified. It describes an error that occurs when using QuerySet.update() with an F expression on an annotated field that includes a join. However, the exact problem to solve is unclear. It mentions the error message is incorrect and that better error messages would be helpful, but it does not specify what the correct behavior should be. There is no clear description of what needs to be implemented or fixed, and there is no minimal reproducible example provided in the issue description. The issue is about improving error messages, but it's unclear what specific changes should be made to the error messages or how they should be improved. The description is too vague to determine a meaningful solution path.",
        "label": "VAGUE"
    },
    "django__django-11133": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed example showing the current behavior and the expected behavior. It shows the issue when using a memoryview object with HttpResponse, and explains that it works with strings and bytes but not with memoryview objects. The example also shows the incorrect output and the expected output. This provides enough information to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11138": {
        "explanation": "The issue is well-specified and provides a detailed description of the problem, including code examples, expected vs actual behavior, and references to documentation and source code. The issue clearly explains that the TIME_ZONE value in DATABASES settings is not being used when making dates timezone-aware on certain databases. It provides a specific example with code that demonstrates the problem and what the expected outcome should be. The issue also references the exact line of code where the problem occurs. This level of detail allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11141": {
        "explanation": "The issue is well-specified. It explains the problem (migrations directories without __init__.py files are not working), provides background on why this is happening (Python 3 namespace packages), and explains the technical cause (a __file__ check that is no longer needed). The issue also references related work and pull requests. This provides enough information for an experienced developer to understand what needs to be changed in the codebase to remove the __file__ check and allow namespace packages to work with migrations. The expected outcome is clear - allow migration directories without __init__.py files to work properly.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11149": {
        "explanation": "The issue is well-specified enough to understand the problem and reproduce it. It describes a specific bug where users with only view permissions can edit ManyToManyFields in the Django admin. The problem is clearly explained with a code snippet showing the models and admin configuration. The reporter even references a specific Django ticket (8060) and provides context about when the regression occurred (at least in Django 2.1). This information is sufficient for a developer to understand what the expected behavior should be (view-only users should not be able to edit) and what the actual behavior is (view-only users can add/remove items). The code example also gives a clear path for reproducing the issue and testing any potential fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11155": {
        "explanation": "The issue is reasonably specified.  It clearly describes the desired outcome (adding configuration options for cookie attributes) and provides a rationale for the change.  The default values are specified, ensuring backward compatibility.  However, the issue doesn't detail the implementation approach (e.g., how to integrate the new settings into the existing cookie handling code),  which is something the developer will need to figure out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11163": {
        "explanation": "The issue is well-specified. The problem is described as model_to_dict() returning all fields when an empty list is passed for 'fields', but it should return an empty dict. The problem point in the code is provided, along with a reference to a PR that addresses the issue. A solution can be developed by modifying the condition from 'if fields and f.name not in fields:' to 'if fields is not None and f.name not in fields:' as indicated. The desired outcome is clear, and the necessary code change is specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11166": {
        "explanation": "The issue is well-specified enough to understand the problem and the proposed solution. The problem is that the admin app has a hard dependency on the sessions app, causing incompatibility with alternative session management apps. The proposed solution is to replace the app check with a middleware check, similar to how it's done for various middleware in the checks function. This is a clear and actionable solution, and the issue provides enough context and technical details to implement it. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11169": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides the context of existing functionality (check for signatures of custom error handlers), references a related GitHub issue (#29642) and a Stack Overflow question for additional context, and clearly describes the desired outcome: catching the exception when the 'path.to.view' cannot be imported and adding a new check code (urls.E008) with a specific message format. This provides sufficient information for an experienced developer to implement the requested feature.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11170": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem is a UnicodeDecodeError when loading debug templates in Django. However, the description is confusing and lacks important details. It mentions a change from 'dotdotdot' to 'ellipsis' in a template file but doesn't clearly explain what the actual problem is or why the change was made. It also references changing encoding to utf-8 as a solution but doesn't provide enough context about where this change was made or why it was necessary. The core issue appears to be a Unicode encoding problem, but the description is unclear about the exact cause and solution. The reporter seems to have found a solution but hasn't clearly explained the problem or how their solution addresses it. This makes it difficult to understand what the actual issue is and how to reproduce or fix it.",
        "label": "VAGUE"
    },
    "django__django-11177": {
        "explanation": "The issue is about the Django 2.2 autoreloader not consistently picking up changes to .py files. The reporter provides context about their environment (Docker, Python 3.7 slim, not using watchman), describes the problem behavior compared to previous versions, and mentions some attempts at workarounds. However, the issue lacks specific steps to reproduce the problem, expected vs actual behavior in precise terms, and exact error messages or logs. While the problem is clearly described in general terms, there are still some gaps in what would be needed to reproduce and fix the issue definitively.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11179": {
        "explanation": "The issue is reasonably specified. It describes a problem where the delete() method on Django model instances without dependencies does not set the primary key (PK) to None after deletion. The reporter also provides a specific location in the Django source code (models.deletion:276-281) and suggests that the model should be updated on line 280. While the issue is clear about what is wrong and where, some additional context or clarification might be helpful for a full implementation, such as understanding the exact expected behavior or any potential side effects of changing the code. However, the core issue is well-defined and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11185": {
        "explanation": "The issue is reasonably specified.  It describes a problem with the Model.delete(keep_parents=True) method in Django, indicating that it does not properly preserve parent reverse relationships beyond immediate parents.  The reference to a partial fix in a specific pull request (#27407) suggests that some progress has been made, but the solution is incomplete.  The issue clearly states what the problem is (relationships toward parents of parents are not preserved) and what needs to be addressed (fix the method to handle these relationships).  However, there are some details missing, such as specific examples of the relationships that are not being preserved, the expected behavior, and the exact conditions under which the issue occurs.  These details would help in understanding the scope of the problem and in verifying the solution.  Despite these missing details, there is a clear direction for a successful solution, which is to extend the existing fix to handle relationships beyond immediate parents.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11194": {
        "explanation": "The issue is reasonably specified.  It indicates that the current implementation of RSS views in Django uses the global LANGUAGE_CODE setting for RSS feed language tags.  It also mentions that the author couldn't find a way to override this behavior and provides a pull request with a potential solution.  While the issue could be clearer on the *exact* desired behavior (e.g., how to specify a different language for a specific feed, what the fallback behavior should be if no override is specified, etc.), there's a clear problem (lack of flexibility) and a general direction for a solution (allow overriding the language code for RSS feeds).  A competent developer could implement a solution that allows specifying a different language for RSS feeds, even if some details would need to be decided during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11206": {
        "explanation": "The issue is well-specified. The problem is clearly described with examples of the current behavior and the expected behavior. The issue provides specific code examples and explains the cause of the issue. It also clearly states what the desired output should be for the given inputs. This provides all the information needed to understand the problem and implement a solution that matches the expected behavior.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11211": {
        "explanation": "The issue is well-specified. It clearly describes the problem, provides a step-by-step reproduction scenario, and even references a related bug report. All the necessary information is present to understand what the issue is and how to reproduce it. A solution would involve investigating why prefetch_related is not working with UUID primary keys in generic foreign keys and finding a way to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11214": {
        "explanation": "The issue is well-specified and it is clear what the problem is. The issue describes a specific problem with Django's migration system when using a range in a CheckConstraint. It explains the problem behavior (check constraint is repeatedly deleted and re-added), provides a code example, shows the generated migration, and even offers potential solutions. This provides enough information for an experienced software engineer to understand the problem and create a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11216": {
        "explanation": "The issue is reasonably specified. It describes the problem with ManifestStaticFilesStorage generating duplicate files during collectstatic, explains the impact (e.g., extra work for WhiteNoise), and suggests a potential solution with a 'keep_intermediate_files' property. While there are technical details to work through, the goal is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11239": {
        "explanation": "The issue is well-specified. It clearly explains the problem: the dbshell command does not support client certificate parameters for PostgreSQL connections, even though the configuration is supported elsewhere in Django. It provides an example configuration showing how the ssl parameters are already used in the DATABASES setting. The issue also references a similar bug (#28322) for context, and states that the fix is likely trivial. This gives enough information to understand what needs to be implemented and how it should integrate with the existing codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11260": {
        "explanation": "The issue is reasonably specified. It describes a problem where inspectdb generates a ForeignKey instead of a OneToOneField, which causes a warning. However, it lacks details on the exact scenario, database schema, or expected behavior. A developer could address this by investigating when ForeignKey is incorrectly generated and modifying the inspectdb logic to produce a OneToOneField when appropriate, but some assumptions would be needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11265": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, a concrete example of the issue in code, and even a trace of the error. The reporter explains the context (using exclude on annotated FilteredRelation), the problem (FieldError), and gives a step-by-step reproduction of the issue in a Django test. The example shows the test case before and after the change that causes the issue, and it also mentions the specific function that might be at fault. This level of detail allows a software engineer to understand what the issue is, how to reproduce it, and where to start looking for a solution in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11270": {
        "explanation": "The issue is reasonably specified. It describes the problem (overlaying on target directory with invalid name causing import issues) and suggests a solution (adding validation like app name validation). However, some details such as specific validation rules or implementation specifics might need to be inferred.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11276": {
        "explanation": "The issue is well-specified. It clearly states the problem (duplicate functionality in Django's html.escape() compared to Python's html.escape()), explains why it's a problem (performance and code duplication), and provides a clear solution (replacing Django's implementation with the Python stdlib version). The issue also includes performance metrics before and after the change, and acknowledges a potential backward incompatibility with the change in the format of apostrophe escaping. All necessary information is provided to understand what needs to be done and what the expected outcome should be.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11278": {
        "explanation": "The issue is reasonably specified. It mentions that the name field is mandatory for constraints and partial indexes and must be unique in the database scope. It also references a previous discussion (#30362) which may provide more context but is not necessary to understand the main task. A software engineer can interpret that a system check needs to be implemented to enforce uniqueness of these names. However, some implementation details, such as how to handle existing duplicate names or how to integrate the check into the system, may need to be inferred or researched.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11279": {
        "explanation": "The issue is reasonably specified. It describes the need to allow the use of app_label and class in the name argument for indexes and constraints. The description explains what these placeholders should be replaced with (lowercased class name and app label). There is a reference to a discussion in another issue (#30362) which provides additional context. While it is clear what the desired outcome is (enable specifying constraints and indexes in abstract models), the implementation details (how to integrate this into the existing codebase, specific classes to modify, etc.) would require exploration of the codebase to fully understand. Overall, it provides enough information for a meaningful attempt at a solution with some exploration needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11281": {
        "explanation": "The issue is reasonably specified. The goal is to improve typography of user-facing strings by replacing certain characters. The specific replacements (e.g., using \u201c\u201d for quotes, \u2019 for contractions, \u2014 rather than --, \u2026 rather than ...) are provided, which gives a clear direction for the implementation. However, there might be some blanks in terms of how to implement this (e.g., the scope of the codebase, how to handle existing usages, and whether to use a library or manual replacement). Despite these minor uncertainties, the core requirements are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11292": {
        "explanation": "The issue is reasonably specified. The request is to expose an existing 'skip_checks' option as a command-line argument for management commands. While the exact implementation details (like the flag name, help text, or specific commands to affect) are not fully detailed, the general goal is clear and there's a sensible interpretation of what needs to be done. A developer can reasonably infer that they need to add a --skip-checks flag to the command-line interface of the relevant management commands, which would set the existing skip_checks option to True. This provides enough direction for a meaningful solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11299": {
        "explanation": "The issue is well-specified because it provides a detailed description of the problem, including the incorrect SQL generated by Django when using a CheckConstraint with OR and AND operators. It includes a code example that reproduces the issue, shows the actual SQL output, and explains the error encountered. The expected correct SQL is also provided for comparison. With all this information, a developer would have a clear understanding of the problem and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11333": {
        "explanation": "The issue is well-specified and provides a clear explanation of the problem, including the root cause and a proposed solution. It explains why the current implementation is inefficient and how it can be improved. The details about URLResolver, get_resolver, and the memoization mechanism are all relevant to understanding the issue. The proposed solution is concrete and specific enough to implement. There's a clear understanding of the current behavior and the desired improvement. This level of detail makes it possible to create a meaningful solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11354": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The user has provided a clear description of the problem, including the error message, a code example to reproduce the bug, and a detailed explanation of the root cause within the Django codebase. The user has even identified the specific lines of code that are causing the issue and provided a proposed fix. All the necessary information is present to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11377": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem with the deprecation warning when using a query expression in Model.ordering, provides an example model definition, and explains the error that occurs. It also includes a partial workaround and a regression test. However, there are some details that need to be filled in, such as exactly what the correct output should be for different query expressions and how to handle the quotation marks issue mentioned. Despite these missing details, there is a sensible interpretation of what is needed to solve the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11396": {
        "explanation": "The issue is about the inability to order a Django query by a constant value on PostgreSQL. The problem is clearly described with an example query and the error message. The error message and example query give enough information to understand the issue, and the question is whether this qualifies as a bug. A solution would involve understanding how Django's annotate and order_by functions work with PostgreSQL, and potentially modifying Django's behavior to handle constant values in ORDER BY clauses correctly. There are some details that may need to be filled in, such as the exact expected behavior and any constraints, but the core issue is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11400": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including specific code references and the expected behavior. The user explains the current behavior of the two filters (RelatedFieldListFilter and RelatedOnlyFieldListFilter) and what should be changed to align with the expected behavior. The code locations that need to be modified are provided with links, and the desired outcome is clearly stated (fall back to the ordering defined in the related model's Meta.ordering field). This provides enough information to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11405": {
        "explanation": "The issue is about a bug where queryset ordering and Meta.ordering are mutable when using the reverse() method. It mentions that a test revealed the issue and that the test might be incorrect because the order mutates on queryset execution in SQLCompiler.get_order_by(). However, the description is somewhat technical and assumes familiarity with the Django codebase, particularly the ordering test and SQLCompiler.get_order_by() method. It doesn't provide a clear, high-level explanation of the problem, the expected behavior, or the actual behavior. Without additional context or a more detailed description, it might be challenging for someone unfamiliar with the specific parts of the codebase to understand what exactly needs to be fixed. Therefore, it's reasonably specified but has some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11417": {
        "explanation": "The issue is reasonably specified. It indicates that the current code uses email.utils.parseaddr and suggests replacing it with email.headerregistry.parser.get_mailbox(). The task is clear: update the sanitize_address function in django.core.mail.message to use the newer standard library method. While it doesn't provide exact implementation details, an experienced developer can infer the necessary changes based on the provided information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11423": {
        "explanation": "The issue is well-specified and provides a clear example with steps to reproduce the problem. It describes the expected behavior, the actual behavior, and the impact of the issue. The provided repository with example code makes it possible to test and verify the issue. The explanation of the problem and the use case (OpenSlides) provides context and helps in understanding the requirements for a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11428": {
        "explanation": "The issue is well-specified with clear steps to reproduce, a detailed description of the problem, and context about the change that introduced the issue. It's clear what the expected behavior is and what the current behavior is, making it possible to work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11433": {
        "explanation": "The issue is reasonably specified.  It points to a specific pull request and comment for context, and clearly describes the problem and the desired behavior.  However, it doesn't fully explain the current implementation or the precise steps to reproduce the issue.  A developer would need to review the referenced pull request and possibly the Django source code to fully understand the implementation details and develop a solution.  Despite this, the core issue is clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11446": {
        "explanation": "The issue is well-specified because it clearly describes the problem (default error webpages are not correctly-formed HTML pages), provides specific examples of the current behavior for both DEBUG=False and DEBUG=True modes, and explains the expected behavior. The reporter also provides the Django version (2.2.1), which helps in understanding the context. All necessary information to understand the issue and what needs to be fixed is present in the description.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11451": {
        "explanation": "The issue is well-specified. It provides a detailed explanation of the problem, including code comments and a specific scenario where the problem occurs. It also includes a suggested solution (shortcutting with 'if username is None or password is None: return') and explains the timing concerns and how the current implementation affects performance and query behavior. The issue gives concrete examples like the SQL query that doesn't make sense and explains why the change would be beneficial. This information is sufficient for an experienced software engineer to implement the proposed solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11477": {
        "explanation": "The issue description is vague because it doesn't provide enough information about the problem. It mentions that there is a problem when translating URLs with absent 'optional' arguments, but it doesn't explain what the expected behavior should be, how the current behavior is incorrect, or provide a specific test case to reproduce the issue. The reference to a 'test case of the patch' suggests that there might be more context, but without seeing the actual test case or understanding the patch, it's difficult to determine what the exact problem is or how to fix it. The description also doesn't explain what 'optional named groups' are in this context or how they should be handled in the translate_url() function. More details would be needed to create a meaningful solution.",
        "label": "VAGUE"
    },
    "django__django-11490": {
        "explanation": "The issue is well-specified enough to understand the problem and the expected behavior. The example provided shows the current behavior versus what is expected. It also references a specific section of code (compiler.py#L428-L433) which gives a hint where the problem might be located in the codebase. This allows a developer to focus on that part of the code to find the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11514": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The request is to add the 'Cache-Control: private' header to Django's 'never_cache' decorator to prevent CDN caching. The issue provides a clear description of the problem, including an example (Fastly) and a reference to their documentation explaining why this change is needed. The proposed solution (adding the header) is specific and actionable. There is no ambiguity about what needs to be done.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11517": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the code that causes the error, the specific error messages, and the line of code where the error occurs. The issue also describes the expected behavior based on Django 1.11 and the actual behavior in the current version. This information is sufficient to understand the problem and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11525": {
        "explanation": "The issue is reasonably specified. The reporter describes the problem they encountered when using an improperly formatted MANAGERS setting in Django, which led to an smtplib.SMTPRecipientsRefused error. They suggest that Django should fail earlier by raising an exception when these settings are in an improper format. While the general direction is clear (validate the format of MANAGERS/ADMINS settings and raise exceptions for invalid formats), there are some details that need to be filled in:\n\n1. What exactly constitutes an \"expected format\" for these settings? Currently, Django expects a list of (name, email) tuples. The reporter's example shows a list of just email strings.\n\n2. Should the validation happen when the settings are loaded, or only when mail_admins()/mail_managers() is called?\n\n3. What specific validation checks should be performed? For example, should we check that each entry is a tuple of two strings, that the second element is a valid email format, etc.?\n\nDespite these missing details, there is a clear understanding of the problem and a reasonable approach to solve it by adding validation to these functions. A developer could make reasonable assumptions to implement this feature.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11527": {
        "explanation": "The issue is reasonably specified. It provides a clear problem description and a suggested solution. The main task is to modify the sqlsequencereset command to handle the case when no sequences are found. The issue suggests that the command should raise a CommandError when there are no statements, and optionally, check the backend to determine if the command is necessary. While some implementation details may need to be worked out, the overall goal and expected behavior are clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11532": {
        "explanation": "The issue is well-specified with clear steps to reproduce the problem, a detailed description of the problem, and even a proposed fix and test case. The traceback is also provided, which helps in understanding where the error is occurring in the code. The problem is about handling non-ASCII domain names in email headers when using a non-unicode encoding. The solution involves converting the domain name to punycode before using it. All the necessary information to understand the problem and how to approach the solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11543": {
        "explanation": "The issue is reasonably well-specified as it provides the context of the problem, the environment in which it occurs, and a basic explanation of the root cause. However, there are some gaps in the information that a developer would need to fully understand and implement a solution. Specifically, the issue does not provide clear steps to reproduce the problem, expected vs. actual behavior, and the exact code changes needed. The explanation of the problem is technical and points to how the keep-alive connections are causing the issue with the --nothreading option, but a developer would need to investigate further to understand exactly how to fix this in the Django codebase. Overall, there is a sensible interpretation of what is required for a successful solution, but there are some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11551": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The issue provides a detailed description of the problem, including the error message (admin.E108), the context of the problem (upgrade from Django 2.0.7 to 2.2.1), a minimal code example that reproduces the issue, and a thorough explanation of the root cause related to a specific commit in Django. The issue also includes a proposed patch that demonstrates the correct behavior and explains the changes made to fix the problem. All of these details make it clear what the issue is, why it's happening, and how it can be resolved. The information provided is sufficient for an experienced software engineer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11555": {
        "explanation": "The issue is reasonably specified. The problem is described as a bug when using a query expression for ordering during multi-table inheritance, which causes a crash. A test repository is provided for reproduction, and the issue is linked to the 'get_order_dir' function where an OrderBy object is encountered instead of a string. While some technical details and the exact expected behavior may be missing, the provided information is sufficient for a software engineer to investigate and attempt a solution. The issue is not fully detailed, but there is a clear direction for investigation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11559": {
        "explanation": "The issue is reasonably specified. The problem is described as a bug when using a query expression for ordering during multi-table inheritance, which causes a crash. A test repository is provided for reproduction, and the issue is linked to the 'get_order_dir' function where an OrderBy object is encountered instead of a string. While some technical details and the exact expected behavior may be missing, the provided context and repository are sufficient to understand the problem and attempt a solution. The ambiguity lies in the lack of explicit steps for resolution, but the core issue is clear enough for a developer to investigate.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11560": {
        "explanation": "The issue is well-specified as it provides a clear description of the problem, including a code example that demonstrates the issue and the error message that occurs. It explains that the ExtractYear lookup on a DurationField is failing due to an optimization that compares the source duration with a range of dates, which is not valid for durations. The code example shows how to reproduce the issue and the expected behavior. The solution would involve raising a ValueError when the Extract lookup is used on a DurationField that doesn't work properly. The problem is well-defined and the solution is clear.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11564": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem of static URLs not including the SCRIPT_NAME when running on a sub-path, and suggests a possible solution involving modifying the static tag and storage classes. However, the exact implementation details and the scope of changes needed (e.g., which other parts of Django might be affected) are not fully detailed, requiring some interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11584": {
        "explanation": "The issue is reasonably well-specified, but there are a few missing details that need to be inferred. The problem is described as a FileNotFoundError when running the development server in a Docker container with a volume-mounted source. The issue is specifically tied to Django==2.2.3 and not present in Django==2.1.4. The user has provided the traceback, Dockerfile, and docker-compose configuration.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11591": {
        "explanation": "The issue is reasonably specified. It describes the need to raise a descriptive error for unsupported operations after using QuerySet.union(), intersection(), and difference(). The documentation and reference to other tickets provide context, but there may be implementation details that need to be filled in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11592": {
        "explanation": "The issue is well-specified because it clearly explains the problem and provides code references. The task is to pass the block_size attribute from FileResponse to the wsgi.file_wrapper. The references to specific lines in the Django codebase make it clear where the changes need to be made. The issue also explains why the change is needed. Therefore, a developer can understand the issue and implement a solution based on the provided information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11603": {
        "explanation": "The issue is reasonably specified. It refers to an existing issue (#28658) which likely provides more context, but even without that, it clearly states that DISTINCT support needs to be added for Avg and Sum aggregates. It explains that previously these aggregations ignored the parameter, but now throw an exception. It also suggests that the change involves marking these classes as allowing DISTINCT. However, there are some blanks such as the exact implementation details and the specific code locations where this change needs to be made. Despite these blanks, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11605": {
        "explanation": "The issue is reasonably specified. It describes a current limitation in Django's handling of window expressions in filter operations. It provides code examples showing the current behavior and explains that the check for window expressions in filters is insufficient. A successful solution would involve enhancing Django's validation to detect these cases and raise appropriate errors earlier. While some implementation details would need to be worked out, the problem and desired outcome are clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11612": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, and the error message. The problem is about SQLite3 migrations failing when using quoted db_table names in Django models. The issue provides a detailed explanation, including a sample SQL query that causes the error and a traceback. This information is sufficient to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11618": {
        "explanation": "The issue is reasonably specified. The user has provided a detailed description of the problem they encountered, including the error messages they received, their debugging process, and a suggested approach for fixing the issue. However, there are still some blanks to fill in for a complete solution. The user has suggested three possible approaches (a, b, and c), but it's not clear which one should be implemented. A software engineer would need to analyze the trade-offs between these options, understand the broader context of the Django static files system, and potentially discuss with the community or project maintainers to determine the best approach. The issue is well-explained, but there are some decisions that need to be made to implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11622": {
        "explanation": "The issue is well-specified because it clearly describes the problem (invalid values passed to fields causing unhelpful tracebacks), the desired outcome (display the field name in the exception), and provides context (example error message and impact on developers). The solution involves modifying the error handling in the mentioned fields to include the field name in the exception message, which is a clear task for a software engineer.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11630": {
        "explanation": "The issue is about Django throwing an error when multiple apps have models with the same table name. The user is asking if this is correct behavior and mentions that they had to roll back to Django 2.0. However, the issue description does not clearly state what the desired behavior is or what specific changes are needed in the code to resolve the issue. The problem seems to be related to Django's validation of model table names, but the solution would require understanding the underlying cause and potential workarounds. Without more specific instructions on what needs to be changed or how to handle the error, the issue is not well-specified enough for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "django__django-11638": {
        "explanation": "The issue is reasonably specified. It mentions the problem (exception when None is passed as data in POST requests with Django's test client), the desired improvement (better exception message showing the offending key and value), and references a proposed change in a GitHub fork. However, it lacks specific details on how to implement the improvement, such as the exact format of the new exception message or the specific code changes required.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11669": {
        "explanation": "The issue is about the inconsistency between TemplateView and ListView in how they handle the passing of self.kwargs to the context. The issue is not very detailed and does not specify the exact expected behavior or how to go about fixing the inconsistency. However, there is a clear problem statement (inconsistency in how different views handle context) and a goal (to fix this inconsistency). A developer with knowledge of Django's view system could make a reasonable interpretation of what needs to be done, such as aligning TemplateView's behavior with ListView or vice versa. There are some blanks to fill in, like which behavior should be the standard, but the overall direction is clear enough to make a sensible solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11680": {
        "explanation": "The issue is well-specified. It clearly describes the problem where an UPDATE query is executed when saving a new model instance with a primary key that has a default value. It provides examples of the current behavior, the expected behavior, and mentions a related issue. This information is sufficient to understand what needs to be fixed and how to approach the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11692": {
        "explanation": "The issue is well-specified because it clearly describes the problem with using OuterRef in a union Subquery, provides a code example that reproduces the error, and mentions the specific error message received. This information allows for a meaningful attempt at a solution since it is clear what the expected behavior is versus what is actually happening.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11695": {
        "explanation": "The issue is well-specified. It explains the problem (unnecessary load on servers due to requests on every key-press), provides a solution approach (rate-limiting with Select2's ajax.delay option), and references a specific PR that implements the fix. A developer has enough information to understand the problem and implement the solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11701": {
        "explanation": "The issue is well-specified. It describes the problem (crash when searching with a null character), provides steps to reproduce (input URL with %00), environment details (Django version, Python version, middleware, etc.), and a traceback. All necessary information is present to reproduce and understand the problem.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11728": {
        "explanation": "The issue is reasonably specified.  It provides a clear example of the problem (the 'related_field' not being replaced in a specific regex pattern), describes the conditions under which it occurs (when the urlpattern is missing a trailing '/'), and mentions a workaround that works.  The reference to the function's usage in Django REST Framework and a specific issue (6888)  gives additional context.  However, it does not provide the actual implementation of 'simplify_regexp()' or 'replace_named_groups()', nor does it specify exactly what the expected output should be after replacement.  A developer would need to look at the code of these functions and understand their intended behavior to implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11734": {
        "explanation": "The issue is well-specified because it provides a clear test case that demonstrates the problem, along with the expected and actual behavior. The test case shows that using OuterRef in exclude() or ~Q() leads to an error, which is the problem to be solved. The error message is also included, which helps in understanding the nature of the issue. The description explains that the error occurs when trying to exclude results using OuterRef(), and it specifies the models involved (Number, Item, tags, category_id). A developer can use this information to investigate why the OuterRef is causing an error in these specific contexts and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11740": {
        "explanation": "The issue is reasonably specified. It describes a scenario where changing a UUID field to a ForeignKey in Django does not create a dependency on the related model, leading to a ValueError when the migration is applied. The problem is clearly explained with code examples, and the expected outcome is mentioned (creating a dependency for App2). While some technical details may need further clarification (e.g., the exact migration behavior expected), the core issue is understandable and actionable for a developer familiar with Django's migration system.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11742": {
        "explanation": "The issue is reasonably specified. It describes the problem (no check for max_length being large enough for the longest choice) and the desired outcome (a check to prevent this issue). However, there are some blanks to fill in, such as where exactly this check should be implemented and what specific logic should be used for the check. A reasonable interpretation would be to add validation logic when choices are set or when the field is initialized to ensure max_length is at least as long as the longest choice. This provides a clear direction for a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11749": {
        "explanation": "The issue is well-specified because it includes a detailed error message, a clear description of the problem, and a comparison of working and non-working scenarios. It also provides code snippets and references to relevant parts of the Django source code. This information allows an experienced software engineer to understand the issue and create a PR to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11751": {
        "explanation": "The issue is well-specified and clear about what is needed. It outlines the specific security headers (SECURE_CONTENT_TYPE_NOSNIFF, SECURE_BROWSER_XSS_FILTER, and X_FRAME_OPTIONS) that should be set by default in the startproject settings. It also references the specific warnings (W006, W007, W019) that these changes would address, and the context of making these changes to improve security for new Django projects. The proposal also mentions a deprecation period for the global defaults, which adds clarity about the implementation approach. This information provides a clear path for implementing the changes.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11754": {
        "explanation": "The issue is reasonably specified. It clearly outlines the desired change (allowing the use of an ExceptionReporter subclass in technical_500_response) and provides specific tasks: moving the ExceptionReporter to a parameter, providing an example using functools.partial, updating documentation, and adding a DEFAULT_EXCEPTION_REPORTER setting. However, there are some areas where interpretation may be needed, such as the exact implementation of the parameter and how the setting interacts with the existing code. Despite these minor ambiguities, the overall direction and objectives are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11772": {
        "explanation": "The issue is well-specified and provides clear details on the problems with the current implementation of the make_template_fragment_key function. It identifies three specific issues (urllib.quote usage, MD5 hashing compliance, and string joining for hashing). The issue also provides a proposed solution with a SHA256 implementation and references to a GitHub repository and performance test results. The potential impact (cache key changes) is also acknowledged. All necessary information is present to implement the proposed solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11790": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly identifies the problem (AuthenticationForm's username field not setting the maxlength HTML attribute), mentions when the regression was introduced (commit hash and issue reference), and provides links for additional context. This information would allow a developer to locate the relevant code, understand the change that caused the regression, and implement a fix that restores the expected behavior.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11797": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with code examples and expected vs. actual behavior. The reporter provides a clear description of the issue with Django ORM queries, showing the expected SQL and the actual SQL generated. The problem is that the GROUP BY clause is not being handled correctly in a subquery when using the ORM. The issue is clearly reproducible with the provided code and the expected outcome is clearly stated. The reporter shows both the correct and incorrect SQL output, making it clear what the bug is and what the expected behavior should be.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11808": {
        "explanation": "The issue is well-specified. It clearly describes the problem (Model.__eq__ not returning NotImplemented when it should), explains why it's a problem (violates Python's data model and can cause bugs), and even provides an example (interaction with mock.ANY). The expected behavior is clearly defined by referencing the Python documentation. This gives enough information to understand what the code needs to do differently and how to implement the fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11810": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example, including code snippets for models.py and test.py, as well as the actual output versus the expected output. The description explains that chaining select_related() is causing the original QuerySet to mutate unexpectedly, and it clarifies that the expectation is for the original QuerySet to remain unchanged. The explanation about the _clone() method is also provided to support the claim that the behavior is incorrect. All necessary information is present to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11815": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with a clear example of the current behavior versus the expected behavior. The user explains why the current approach is problematic (due to translation issues with Enum values) and provides a specific suggestion for the fix (using the Enum name instead of the value in migration files). The example clearly shows what the code looks like before and after the proposed fix, making it easy to understand what needs to be implemented.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11820": {
        "explanation": "The issue is not very well specified. It describes a problem with Django's model validation where it raises an error about a nonexistent field when 'ordering' refers to the primary key (pk) of a related field. However, it lacks specific details on how to reproduce the issue, what the expected behavior should be, and what the underlying cause might be. It also references a commit hash as a regression point but does not provide a clear explanation of the intended functionality before and after the change. The information provided is minimal and lacks the necessary context to implement a solution without further investigation or clarification.",
        "label": "VAGUE"
    },
    "django__django-11829": {
        "explanation": "The issue is well-specified. It explains the problem with the current implementation of patch_cache_control not handling the 'no-cache' directive correctly, especially when field names are specified. It provides examples of the desired behavior, such as how multiple calls to patch_cache_control should work, and references related tickets for context. This is sufficient information to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11848": {
        "explanation": "The issue is well-specified enough to understand the problem with the two-digit year check in the 'django.utils.http.parse_http_date' function. It references specific RFC standards (RFC 7231 and RFC 2822) and explains how the current logic is incorrect - it hardcodes year ranges instead of using the current year for comparison. This provides clear guidance on what the expected behavior should be according to the RFCs and what the current implementation is doing wrong. The explanation of how timestamps with two-digit years should be interpreted is specific and actionable for a developer to implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11880": {
        "explanation": "The issue is well-specified because it clearly explains the problem with the __deepcopy__ method in Django's form fields not properly copying the error_messages dictionary. It provides specific code references (file paths and line numbers), describes the consequences of the issue (shared dictionaries leading to incorrect error propagation), and mentions the affected versions of Django. The problem and expected solution (deep copying the error_messages dictionary instead of shallow copying) are clearly outlined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11883": {
        "explanation": "The issue is reasonably specified. The main goal is to make the `cache.delete()` method return a boolean indicating success or failure. The issue description provides some context and examples (memcache, file, inmemory, database, Redis) to guide the implementation. However, there are some details that need to be clarified or decided during implementation, such as how to handle different backend implementations and what exactly constitutes a 'success' or 'failure' in each case. Despite these minor gaps, the overall direction is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11885": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the current behavior, the desired behavior, and an example with the current and desired SQL queries. The code example shows the models and the relationships, and the explanation of the problem and the proposed solution is clear.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11891": {
        "explanation": "The issue is reasonably specified. It explains the problem with ConditionalGetMiddleware when used with x-sendfile, and describes the current behavior (ETag is based on empty content, so it's always the same). It also explains the consequence (always returns 304 regardless of Last-Modified changes) and what should happen (Django shouldn't return 304 if ETag is same but Last-Modified has changed). The problem is clearly defined, but the implementation details of how to fix it would need to be worked out. The reference to related issue #29241 might provide additional context.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11893": {
        "explanation": "The issue is well-specified. It clearly states the problem (DateTimeField doesn't accept ISO 8601 formatted date string), explains the difference (ISO format uses capital T as a separator while Django expects a space), and provides the expected format. With this information, a developer can identify where in the codebase the date parsing is happening and modify it to accept both formats or convert the ISO format to the expected format. There is a clear understanding of what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11894": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the default value of the samesite argument in Django's cookie handling and references an external source to support the need for a change. The goal is to explicitly set SameSite=None for cookies to ensure compatibility with Chrome's new behavior.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11903": {
        "explanation": "The issue is well-specified. It explains the current behavior of the fetch_command method in the ManagementUtility class, which prints an error message if the DJANGO_SETTINGS_MODULE environment variable is not set. However, it also explains that settings can be configured via a UserSettingsHolder using settings.configure(...) and the current check does not account for this case. The issue also references the parent execute method, which correctly checks if settings.configured. The description provides enough context and specific information about the code and the desired change. A developer could understand the problem and implement a solution based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11905": {
        "explanation": "The issue is reasonably specified. It describes a problem with the __isnull lookup allowing non-boolean values, which is undocumented and untested. The desired solution is to raise an error for non-boolean values to ensure consistency and avoid confusion. While there are some technical details to work out (like how to implement the validation), the overall goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11916": {
        "explanation": "The issue is reasonably specified. It explains the problem (prefetch_related is slow due to creating querysets that are not used), provides profiling data to back up the claim, and suggests two possible approaches (with a preference for option 2). However, some implementation details are left open, such as exactly how to implement the proxy object that behaves like a QuerySet but avoids unnecessary overhead. The issue is clear about the goal and the general approach, but some technical specifics would need to be worked out during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-11951": {
        "explanation": "The issue is well-specified because it points out a specific line of code where a problem exists, explains why it is a bug by comparing it to another function (bulk_update) that handles the same logic correctly, and suggests a specific fix. The proposed solution is clear and actionable, making it possible to implement a PR that addresses the issue effectively.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11964": {
        "explanation": "The issue is well-specified. The problem is clearly described with a complete example including code for the model, test case, and test results showing the failure. The reporter explains that when using Django's TextChoices/IntegerChoices with a CharField or IntegerField, the getter returns an enum value object instead of the expected string or integer value. The issue includes a reproducible test case and clearly states the problem behavior compared to what is expected. This provides all the information needed to understand the issue and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-11999": {
        "explanation": "The issue is well-specified. The user provides a clear example of the problem, including code that demonstrates the issue and mentions the specific versions of Django where the behavior differs (2.1 vs 2.2). The expected outcome is also clearly stated. This information is sufficient for a software engineer to reproduce the issue and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12009": {
        "explanation": "The issue is describing the installation of two scripts, django-admin and django-admin.py, both of which execute the same functionality. The issue is suggesting that only one of these scripts should be installed. The problem and the proposed solution are clearly defined - remove one of the two redundant scripts. The cause of the duplication is also explained (one from scripts and one from entry_points in setup.py). The information is sufficient to understand what the problem is and how to fix it in the setup.py file.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12039": {
        "explanation": "The issue is well-specified. It clearly describes the problem with whitespace in CREATE INDEX statements generated by Django when using opclasses. It provides concrete examples of the current incorrect output and the expected correct output. It even explains the root cause of the issue - that the fix in #30903 assumed empty col_suffixes for ascending order but they actually contain empty strings. With this detailed explanation and examples, a software engineer could look at the code reference (ddl_references.py line 87) and implement a fix to properly handle whitespace in these SQL statements. The requirements for a successful solution are clear - fix the whitespace handling so the generated SQL matches the expected formatting in all cases.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12050": {
        "explanation": "The issue is reasonably specified. It explains that a change in a specific pull request (#30687) caused a problem where list values are being converted to tuples, which is breaking certain functionality related to exact value queries, particularly for ORM field types like PickledField. It also mentions that the expected iterable return type should match the input iterable type. This gives enough information to understand the problem and work on a solution, but there might be some implementation details that need to be figured out while working on the code.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12062": {
        "explanation": "The issue is reasonably well-specified as it provides a specific setting to implement and a method to hook into. However, there might be some blanks to fill in about the exact implementation details and potential edge cases, but the general approach is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12073": {
        "explanation": "The issue is reasonably specified. The task involves deprecating the InvalidQuery exception in Django, replacing its usage with more appropriate exceptions (FieldDoesNotExist and FieldError), and adding a deprecation warning. While some details may require further investigation (like exact locations of usage and implementation specifics), the general approach is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12091": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the task (deprecating the is_ajax method), the reason for the change (discussed on a specific thread), and the context (jQuery's popularity is decreasing, and it's better to inspect the HTTP Accept header instead). The issue also references a similar action taken by Flask, which provides an additional context for the change. The necessary steps for deprecation would likely include adding deprecation warnings, updating documentation, and possibly suggesting alternatives for users. All these steps are clear and actionable based on the given information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12113": {
        "explanation": "The issue is about a specific test failure in Django when using persistent SQLite databases with the --keepdb option. The problem is described in detail with the error message, a code snippet showing the database configuration, and the traceback from the error. The core issue is that the test 'admin_views.test_multidb' fails with a 'database is locked' error when using persistent SQLite databases for multiple database tests. This is a clear and specific problem that can be addressed by understanding why the lock is occurring with persistent databases and how to resolve it. The information provided is sufficient to attempt a solution, though some deeper understanding of Django's testing framework and SQLite's behavior with multiple connections may be needed. Therefore, the issue is reasonably specified, as there are some technical details to work through but the goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12121": {
        "explanation": "The issue is reasonably specified. It provides a clear problem scenario involving URL converters in a web framework (likely Django based on the context), describes the user's attempt and the current workaround, and offers two possible solutions. While there's a bit of context that might require understanding the framework's internals, the core of the issue\u2014how URL converters should signal a failure in to_url\u2014is clear enough to work on. Some interpretation may be needed regarding the best approach, but the overall goal is well-defined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12125": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, and examples of the incorrect and correct behavior. It explains that when an inner class of a Django model is used as a field type, the generated migration file incorrectly refers to the inner class as a top-level class instead of using its full nested path. The issue includes a minimal code example to reproduce the problem, shows the actual output and expected output, and even provides a real-life use case with django-enumfields. This provides all the information needed for a developer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12143": {
        "explanation": "The issue is well-specified. It clearly describes a problem with potential data loss when using regex special characters in a formset prefix in the admin changeform view. It provides the specific line of code in the Django repository (with a GitHub link) where the problem occurs, explains why the issue exists (string formatting vs. proper escaping of regex characters), and mentions that the fix is to use re.escape(). It also references the commit that introduced the regression. This information is sufficient for a developer to understand the problem, locate the code, and implement the fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12148": {
        "explanation": "The issue is reasonably specified.  It clearly states that the `FlatPage` model's `get_absolute_url()` method does not use `reverse()` and this is causing problems in the admin interface when using a prefix for flatpage URLs.  The issue also mentions that the templatetag for resolving a flatpage works correctly.  While the exact nature of the problem with the admin link is not explicitly detailed, a competent developer with knowledge of Django's URL routing and the FlatPage model should be able to understand the general problem and devise a solution.  The developer would need to investigate how the admin interface generates the link and how the `get_absolute_url()` method is being used in that context.  The developer would also need to understand why the current implementation of `get_absolute_url()` is not working correctly with URL prefixes.  However, these are reasonable things for a developer to figure out based on the information provided.  The issue is not vague or impossible to solve, but there are some details that would need to be filled in by the developer.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12153": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the migration script 0011_update_proxy_permissions.py crashes in a multi-database environment when the default database is not set. The relevant code section is provided along with the error traceback. The issue provides context from the Django documentation and explains the scenario in which the problem occurs. A successful solution would involve modifying the migration script to handle cases where the default database is not set, likely by making the database configuration optional or adding proper error handling. The problem is clearly defined with enough technical details to begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12155": {
        "explanation": "The issue is well-specified with a clear problem description, error message, and proposed solution. The problem is that admindoc is having issues with docstrings that don't start with an empty line. The error message and culprit code are provided, along with a proposed solution to skip the first line when calculating indentation. This provides all the information needed to implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12161": {
        "explanation": "The issue is well-specified because it clearly states the problem: through_defaults does not support callable values like other default mechanisms in Django. It explains the current behavior (callables are passed through unevaluated, leading to unexpected results like saving the repr() of the function). It also mentions that this was an oversight, not a deliberate decision, and provides a pull request showing a straightforward fix with no regression. The goal is clear - modify through_defaults to evaluate and execute callable defaults before saving, similar to how get_or_create and model fields handle defaults. The issue provides enough context, examples, and even a proposed solution to make this a well-defined task for a developer.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12172": {
        "explanation": "The issue is reasonably specified. It describes the problem (Jupyter executing code in an async environment causing issues with async unsafe checks), the need for a solution (add a flag to disable these checks), and possible implementation approaches (setting or environment variable). The preference for an environment variable is mentioned, but the task is clear enough to proceed with a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12187": {
        "explanation": "The issue is about allowing the configuration of where to save the staticfiles manifest in Django. It describes the problem of the manifest being publicly accessible, which can be a security risk, and suggests potential solutions like encrypting the manifest or changing the manifest path to a non-public location. The issue also references ticket #26029, which relates to allowing storage configuration options to change the manifest path. The problem is well-defined with a clear goal of providing a way to configure the manifest's save location, and it suggests possible approaches for implementing this feature. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12193": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the SplitArrayField and BooleanField where the 'checked' attribute is being set incorrectly after the first True value. It provides the specific code reference and explains why the problem occurs (CheckboxInput widget's get_context() modifying the attrs dict). The issue also describes the symptom (all widgets checked after the first True) and the cause. This provides enough information for an experienced developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12198": {
        "explanation": "The issue is not very well specified. It describes a problem with the sensitive_variables decorator in relation to the inspect.getcallargs function and how it affects authentication backends. However, it lacks important details that would be needed to understand and implement a solution, such as:\n\n1. What exactly is the expected behavior of sensitive_variables() preserving the decorated function's signature?\n2. What specific version introduced the issue (since it mentions it worked in 1.6)?\n3. What exactly is the error scenario that causes the TypeError?\n4. What is the expected behavior vs actual behavior?\n5. What are the constraints or requirements for the solution?\n\nWithout these details, it's difficult to determine exactly what needs to be fixed or how to approach the solution.",
        "label": "VAGUE"
    },
    "django__django-12209": {
        "explanation": "The issue is well-specified. It provides a clear example of the model in question, the expected behavior in previous versions (Django 2.2 and earlier), and the changed behavior in Django 3.0. It explains the problem with specific code examples and references a related ticket. The issue clearly describes the impact of the change (particularly on the loaddata command) and suggests a possible direction for a solution (changing behavior only when an explicit pk value is not set). All necessary information is provided to understand and address the problem.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12212": {
        "explanation": "The issue is reasonably specified. It explains the error that occurs, provides the traceback, and describes the underlying cause as a 'NoneType' object being non-iterable on line 139 of the PythonDeserializer. It even suggests a potential fix (changing the for loop to use 'field_value or []'). While some implementation details might need to be filled in, the problem and solution direction are clearly articulated.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12225": {
        "explanation": "The issue is reasonably specified. The problem is clear: when a model has multiple ForeignKeys to the same parent model, the error message should recommend specifying fk_name. However, there are some implementation details not specified, such as exactly how to modify the error message and where in the codebase to make the change. But these are standard implementation details that a developer with knowledge of the codebase could reasonably figure out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12231": {
        "explanation": "The issue is about the Django framework's RelatedManager set() method not properly handling string values when comparing to primary keys, which are integers. The user has provided a specific scenario where foreign keys are being completely replaced instead of updated as expected, and they've identified a condition in the Django source code that's causing this behavior. The issue includes a specific line reference in the Django code, a clear description of the problem (strings not matching integer pks), and a proposed solution (converting strings to integers before calling set()). The question posed is about how to avoid this issue, whether all usages of set() are affected, and if Django should handle this by raising an exception for string inputs. This is reasonably specified because while there are some open questions (how common this issue is, what the best practice should be), the core problem is clear and actionable. A solution could involve either documentation changes, input validation in Django, or guidance for users on proper input types for the set() method.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12237": {
        "explanation": "The issue is well-specified and provides a detailed explanation of the problem, including code examples, error messages, and a proposed solution. The issue also includes a repository with further analysis, making it clear what the problem is and what needs to be done to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12262": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, code examples that demonstrate the issue, and even mentions that a fix is already ready. The problem involves custom template tags in Django raising incorrect TemplateSyntaxError exceptions when keyword-only arguments with defaults are used. The issue includes specific examples of the erroneous behavior and what the correct error messages should be. This level of detail provides enough information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12273": {
        "explanation": "The issue is reasonably specified. The problem is described with code examples, and the expected behavior is explained. However, some interpretation is needed to fully understand the context and the expected outcome.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12276": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly identifies the problem (FileInput shouldn't display required attribute when initial data exists), provides specific code references (ClearableFileInput.use_required_attribute() and a GitHub link), and describes the proposed solution (moving the method to FileInput). The explanation also includes a rationale for the change and acknowledges potential edge cases. All necessary information for implementing the change is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12286": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12299": {
        "explanation": "The issue is reasonably specified. The problem is about raising a descriptive error when performing update() or delete() operations after using QuerySet methods like union(), intersection(), and difference(). The example shows that when performing q.update(name='foo'), it's causing an unexpected SQL query that doesn't align with the expected behavior of the QuerySet. The example is clear enough to understand that there is a discrepancy between the expected and actual behavior when using update() after union(). However, the exact error message that should be raised is not specified, and the exact conditions under which the error should be raised are not fully detailed. The solution would require understanding how Django's QuerySet handles these operations and implementing checks to raise appropriate errors.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12304": {
        "explanation": "The issue is well-specified because it clearly describes the problem (enumeration types not usable in templates due to being callable), provides an example of the issue, and even suggests a solution (declaring do_not_call_in_templates = True on the various Choices classes). A software engineer would be able to understand the problem and implement the suggested fix without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12308": {
        "explanation": "The issue is well-specified enough to understand the problem and the proposed solution. The problem is that JSONField values are displayed as Python dictionaries (with curly braces) in the Django admin when set to readonly, which is not valid JSON. The user suggests a solution by adding a special case in the 'display_for_field' function to use the JSONField's prepare_value method instead of using json.dumps directly. This gives a clear direction for the solution. There is enough information to identify where the code change needs to happen and what the expected outcome is.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12313": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is that Django's migration system does not detect changes in model name case (like renaming 'Rubrictype' to 'RubricType'). The issue provides a clear example of the problem, including code samples that show the initial and modified model definitions, commands used, and the resulting migrations. The issue also explains the workarounds and the error that occurs when trying to manually add a RenameModel operation. This provides enough information for a developer to understand the problem and potentially work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12325": {
        "explanation": "The issue is about Django model inheritance with multiple OneToOneField references to the same parent model. The user is encountering an error when trying to define a model that inherits from Document and has two OneToOneField fields referencing Document. The issue is that the order of the fields matters for Django to correctly identify the parent link, even though Django has a parent_link marker. The user is asking why the order matters and if Django should be able to handle this without relying on field order. This is a specific technical issue with Django's handling of model inheritance and OneToOneField fields. The problem is well-defined, the error is clearly described, and the user has provided code examples showing the issue. There is a clear question about Django's behavior and how it could be improved. I would label this as WELL_SPECIFIED because the issue is clearly defined with specific code examples and a clear error message.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12360": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the scenario where a model name is just under the 100 character limit, but the generated permission codenames exceed 100 characters. The issue provides a concrete example with a model class and the resulting database error. The background and context are clearly explained, and there's even a mention of a workaround. This information gives a clear understanding of the problem and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12364": {
        "explanation": "The issue is reasonably specified. It provides a clear explanation of the problem (UniqueConstraints are not considered when determining if a model is totally ordered), a reference to related code and PR, and an understanding of why the change is needed (docs suggest unique_together may be deprecated). However, it lacks specific implementation details or steps on how to implement the solution, which requires the developer to fill in some blanks.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12394": {
        "explanation": "The issue is well-specified enough to understand the problem and create a solution. The error message shows a TypeError related to an 'itertools.chain' object being unsubscriptable, which is a specific issue that can be addressed in the code. The traceback points to the error occurring during a test case for protected related objects in Django's delete functionality. The goal would be to fix the code so that raising an error about protected related objects does not crash with this TypeError. The issue provides enough context and information to create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12396": {
        "explanation": "The issue is well-specified with detailed information on the problem, including the suspected cause, steps to reproduce, and the error messages encountered. The provided test case and the environment setup also contribute to a clear understanding of the problem. This enables a developer to replicate the issue and work on a solution effectively.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12406": {
        "explanation": "The issue is well-specified. The problem is described with a clear example of the current behavior and the expected behavior. It explains that the RadioSelect widget is rendering a blank option even when the model field has blank=False. The code example shows how the form is defined and the HTML output that is being generated, and it clearly states what the expected output should be. A software engineer would have enough information to understand the problem and implement a solution to prevent the RadioSelect widget from rendering a blank option when blank=False on the model field.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12407": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly explains the problem with the {% include %} template tag in Django, which uses get_template instead of select_template. It provides a detailed example with code snippets and error traces to illustrate the issue. The proposed fix is mentioned (changing get_template to select_template), and the issue also references a specific commit that might have complicated the fix. The expected outcome after the fix is demonstrated with a working example. All necessary information to understand the problem and the proposed solution is provided, making it a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12419": {
        "explanation": "The issue is well-specified. It clearly states the goal of changing the default SECURE_REFERRER_POLICY to 'same-origin' in Django. The reasoning behind the change is explained, as well as the potential risks of breakage. The issue also provides documentation resources for the Referrer-Policy header. All necessary information is provided to implement the change and understand its implications.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12453": {
        "explanation": "The issue is well-specified. It explains the problem in detail, including the specific code paths and functions involved. It also provides a suggested fix with a code diff and explains why the current implementation is incorrect. The issue even references other parts of the codebase for comparison (like loaddata). There are no significant ambiguities about what the problem is or what a solution would look like. A developer could take this information and implement the proposed fix or investigate further.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12464": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The issue clearly describes a problem with the Django ORM's handling of the GROUP_CONCAT function in SQLite when using the DISTINCT keyword with multiple expressions. It provides the error encountered (NotSupportedError), explains that SQLite actually supports DISTINCT on aggregate functions contrary to what Django's code suggests, and includes a code example of a custom GroupConcat implementation that works around the issue. The issue also explains the limitation of GROUP_CONCAT in SQLite where DISTINCT is only allowed when a delimiter isn't specified. All of these details provide clear guidance on what the problem is and what needs to be fixed in the Django codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12469": {
        "explanation": "The issue is reasonably specified. The problem is described as an extra day appearing in the date_hierarchy filter when using a non-UTC timezone. The example of America/Los_Angegeles is given. A software engineer with access to the codebase can investigate the date filtering logic, timezone handling, and the date_hierarchy implementation to identify and fix the issue with the extra day at the timezone boundary.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12470": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a model definition, the expected behavior, and the actual behavior. The reporter provides a concrete example and explains the discrepancy between what is happening and what is expected. The issue involves Django model inheritance and ordering, which is a specific topic. The problem is reproducible with the provided code snippet, and the expected outcome is clearly stated.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12477": {
        "explanation": "The issue is well-specified. It provides a clear example of the problem, including code snippets that demonstrate the issue. The error message and the solution (using unique_together) are clearly mentioned. The user also explains why this is a problem (since unique_together may be deprecated). This is sufficient information for a developer to understand what the issue is and how to approach solving it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12484": {
        "explanation": "The issue is well-specified enough to understand the problem and the desired solution. The problem is that the Django system check is not providing a helpful hint about which field is causing the error when a custom user model's USERNAME_FIELD is included in REQUIRED_FIELDS. The reporter suggests that a specific hint should be added to clarify this, such as indicating which field is causing the problem and suggesting to remove it from the required fields. The issue includes the current error message, the context in which it occurs, and a clear example of the desired hint. All necessary information is provided to implement the change in the Django codebase. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12496": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem, including the scenario (multi-inheritance with a custom primary key in the parent model), the incorrect behavior (an extra update query setting parent model fields to empty values), and example code showing the correct and incorrect behaviors. The issue also specifies the environment (Python 3.6, PostgreSQL 9.6). This information is sufficient to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12503": {
        "explanation": "The issue is well-specified. It clearly describes the problem (makemessages doesn't provide feedback when no locale is specified), explains the expected behavior (it should raise CommandError), and mentions that the user has already fixed it in their fork and submitted a PR. The request for feedback on necessary next steps is clear.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12504": {
        "explanation": "The issue is reasonably specified. It explains that the logout link in the admin app is not CSRF-protected because it's a link rather than a form. It also mentions that while it may not be crucial for security reasons, it's a matter of following best practices (GET requests should not change system state). A developer can interpret that the goal is to implement CSRF protection for the logout functionality, likely by changing the link to a form or adding a CSRF token to the request. Some implementation details will need to be worked out, but the overall objective is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12508": {
        "explanation": "The issue is well-specified. It clearly describes the current limitation (cannot run specific SQL directly with dbshell), the desired feature (-c argument to provide SQL commands directly), and provides examples of both the current workaround (using pipes) and the proposed solution. The request is specific and actionable for a developer familiar with the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12513": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The task is to deprecate the 'providing_args' argument from the Signal class. The issue explains why this argument is being deprecated (it's purely documentational, provides no functionality or checking, and causes confusion). The solution involves removing this argument from the codebase and updating any related documentation or comments to reflect this change. The reference to a previous issue (#19579) provides additional context about the confusion this argument has caused.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12517": {
        "explanation": "The issue is about inconsistent datetime logging when using Django's runserver. It explains that WSGIRequestHandler and WSGIServer use different methods to generate timestamps in the logs. The issue provides a clear problem statement, explanation of the current behavior, and even suggests possible solutions like using %(asctime)s instead of %(server_time)s. While there are implementation details that would require understanding of Django's logging infrastructure, the core problem and desired outcome are clear enough for a software engineer to create a meaningful solution. The issue also references relevant documentation and provides examples of the inconsistent output.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12518": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the error messages and steps to reproduce the issue. It also specifies the expected improvements (A and B). There is a provided repository for reproduction. The request is specific and actionable for a developer familiar with Django's migration system.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12519": {
        "explanation": "The issue is about a problem with subquery annotations being omitted in the group by clause when multiple annotations are declared. The issue provides detailed query outputs from two different Django versions (3.0.2 and 2.2.9) showing the difference. The problem is clearly described as leading to duplicate results. The issue references a previous related issue (#31094), which might provide more context if accessible. However, without access to the full codebase, dependencies, or the actual implementation of the query that's causing this issue, it's challenging to provide a complete solution. The explanation is detailed, but there are still some blanks that need to be filled in about the codebase and specific implementation details. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12532": {
        "explanation": "The issue is well-specified because it clearly describes the discrepancy between the error message keys used by MultipleChoiceField and ModelMultipleChoiceField. It states that MultipleChoiceField uses \"invalid_list\" while ModelMultipleChoiceField uses \"list\", which is a clear and specific problem. The required solution is also clear: change ModelMultipleChoiceField to use \"invalid_list\" as the error message key to align with MultipleChoiceField. There is no ambiguity in the problem description or the expected solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12553": {
        "explanation": "The issue is reasonably well-specified but has some missing details. It clearly states the goal of increasing the default password salt size from ~71 bits to ~131 bits, providing references to support this change. However, it lacks details on how to implement this change in code (e.g., which specific file or method in BasePasswordHasher needs modification, what parameters need to be adjusted, etc.). The issue also references an existing pull request that implements this change, but doesn't provide enough standalone information for someone to implement the solution without looking at that PR. The motivation and technical justification are well-explained, but some implementation details are missing. This falls into the 'REASONABLY_SPECIFIED' category because a developer with knowledge of the codebase could interpret what needs to be done based on the context provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12588": {
        "explanation": "The issue is reasonably specified. It asks to add an option to a command called remove_stale_contenttypes that will allow it to remove entries for nonexistent apps. While it doesn't give full technical details on how to implement the option, the general direction is clear - modify the command to include a new optional flag. A developer with knowledge of the codebase can infer the necessary implementation steps.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12591": {
        "explanation": "The issue is about a change in Django's admin system that prevents replacing global admin actions with specialized ones for specific models. The problem is clearly described with the commit hash, related issue, and even a workaround for a specific use case. It explains what the problem is (admin.E130 error), what change caused it, and gives a specific example (qsessions app). The issue also mentions a potential solution for the example case. This provides enough information to understand the problem and work on a solution. However, there are some details that might need to be filled in about the exact requirements for a solution (like whether the solution should be specific to the example or more general).",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12613": {
        "explanation": "The issue is reasonably specified because it describes a specific problem with the XML serializer not handling JSONFields correctly. It includes a code snippet that shows how the error is triggered, the exact error message, and the stack trace. This information makes it clear that the XML serializer is failing when a JSONField is included in the fields parameter of the serialize function. While some implementation details may need to be worked out, the problem and its cause are clearly identified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12627": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly states the problem (make_password function accepts any Python object as an argument), the desired solution (throw TypeError when passing anything but bytes or str), and provides the reasoning for the change. The issue also references similar behavior in other libraries and mentions the inconsistency with the documentation and validate_password function. All the necessary information to implement the change is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12663": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The issue provides a detailed description of the problem, including the models, a test case to reproduce the issue, and the error traceback. The problem appears to be a regression related to using SimpleLazyObject with a nested subquery annotation. The reporter also mentions that this behavior is new after a specific commit. With this information, a developer could investigate the code changes introduced in that commit and analyze how they affect the handling of SimpleLazyObject in the context of subquery annotations. The provided test case would allow for verifying a potential fix. The error message clearly indicates the problem occurs when trying to convert a SimpleLazyObject to an integer, which provides a good starting point for debugging.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12669": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: the order_by functionality breaks for a uuid column when annotated. The proposed fix is given (changing the ORDER_PATTERN regex), and there's even a question about potential incompatibility with other databases. The main thing missing is a clear instruction on what should be done next (e.g., whether to implement the change, test it across databases, or just document the workaround). However, based on the information provided, one could reasonably interpret the task as implementing the proposed regex change and verifying its compatibility with different databases.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12671": {
        "explanation": "The issue is reasonably specified. It describes the problem with Django's management commands' stdout and stderr proxies, specifically that they always add a newline character. It also suggests a solution of allowing self.stdout.write() and self.stderr.write() to add a newline. However, there are some missing details about the exact behavior change needed and how to implement it. The issue provides context about the current behavior and the proposed change, but leaves some interpretation about the implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12708": {
        "explanation": "The issue is well-specified because it provides clear steps to reproduce the problem, identifies the specific Django version affected, and explains the error that occurs. The description also includes a detailed error message and the location in the codebase where the error happens. Additionally, the reporter offers potential areas of focus for the solution, indicating that the problem is related to how Django handles index_together and unique_together during migrations. The issue is specific enough that a software engineer could understand what the problem is and begin working on a solution without needing significant additional information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12713": {
        "explanation": "The issue is not very well specified. It mentions that overriding the widget in formfield_for_manytomany() does not work and is different from formfield_for_foreignkey(), but it does not provide enough details about the expected behavior, the actual behavior, or how the widget is being overridden. There is no clear problem statement or steps to reproduce the issue. The issue is also missing any code examples or error messages. It is unclear what the exact problem is and what the desired outcome should be. Therefore, the issue is vague and lacks sufficient information for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "django__django-12733": {
        "explanation": "The issue is well-specified because it clearly explains the problem (sql_flush() is slow due to multiple queries), provides a specific solution (use PostgreSQL TRUNCATE ... RESTART IDENTITY to combine operations into a single query), and explains the expected benefit (performance improvement). A developer would understand exactly what change to implement and why it's needed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12734": {
        "explanation": "The issue is reasonably specified. The user has provided a clear example of the problem, including code snippets from models.py and the migration file. They explain the expected behavior (changing the max_length of a field) and the actual observed behavior (the related ManyToMany table's field length remains unchanged). However, there are some implicit assumptions and blanks to fill in, such as the exact relationship between the field and the ManyToMany table, and the precise expected outcome. A software engineer with Django experience could interpret these and create a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12741": {
        "explanation": "The issue is well-specified. The task is to simplify the signature of the `execute_sql_flush` method by removing the `using` parameter and using `self.connection.alias` instead. The desired new signature is provided, and the explanation of why the change is needed (that `using` can be inferred) is also given. There's enough information to implement the change and verify it. The issue is clear and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12747": {
        "explanation": "The issue is well-specified. It describes the current inconsistent behavior of the QuerySet.delete() method in Django when no objects are deleted. It provides examples of the two different return formats when deleting objects with and without foreign keys, and clearly states the expected consistent behavior. The reporter provides specific examples of the current output and the desired output, making it clear what the problem is and what a successful solution would look like. The issue has a clear problem statement, reproducible examples, and a specific expected outcome, which are all hallmarks of a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12748": {
        "explanation": "The issue is reasonably specified. It asks to add support for resetting sequences on SQLite, and provides a hint about using the internal sqlite_sequence table. While the exact implementation details are not provided, a reasonable interpretation is that the solution should involve interacting with the sqlite_sequence table to reset sequence values, which is a common approach for managing auto-incrementing primary keys in SQLite. The task is clear enough for an experienced developer to proceed with a meaningful implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12754": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem (FieldError when migrating a field to a new model subclass), a concrete example of the before and after model structure, and an explanation of the current behavior (makemigrations works but migrate fails) versus the desired behavior (should pass by reversing the order of migration operations). The error message is included, and there is an indication of what the auto-detector should be able to do. This information is sufficient to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12771": {
        "explanation": "The issue is well-specified and clear. It explains the current implementation of ModeState.fields as a list of tuples, the reasoning for this approach (preserving ordering), and the conclusion that this approach is now unnecessary because dicts preserve insertion order in Python. The issue clearly states the desired change: to switch ModelState.fields to a Dict[str, models.Field], and similarly for indexes and constraints. The rationale for the change is also provided. All necessary information is given to make a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12774": {
        "explanation": "The issue is well-specified because it provides a clear problem statement, a code example, and the expected behavior. It explains that the current implementation of QuerySet.in_bulk() does not recognize fields with UniqueConstraints as unique. The issue also includes a traceback from the error that occurs when attempting to use in_bulk() with a field that has a UniqueConstraint. Additionally, it states that the reporter has a potential solution ready if accepted. This information provides enough context and detail for a software engineer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12796": {
        "explanation": "The issue is reasonably well-specified, but there are a few areas that require interpretation. The main goal is to add a flag to skip database consistency checks during makemigrations, which is clear. However, the exact implementation details, such as the name and placement of the flag, need to be determined. Additionally, the behavior when the flag is used should be clarified, such as whether it should also affect other commands or just makemigrations. Despite these minor ambiguities, there is a sensible interpretation of the requirements, making it possible to proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12821": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: some admin static assets are minified while others are not, leading to inconsistency. The request is to stop minifying only some admin static assets. The reasoning for the change is provided, and the impact of minification is discussed. However, there are some blanks to fill in regarding the exact implementation steps. The reporter suggests dropping minification of admin files altogether but does not provide detailed instructions on how to implement this change. A developer would need to review the current codebase to understand how minification is currently handled and how to modify it to stop minifying admin static assets. There may also be questions about how this change will affect existing functionality or if there are any exceptions to consider. Overall, the issue provides a clear direction but requires some additional research into the codebase to fully implement the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12830": {
        "explanation": "The issue is reasonably well-specified but has some missing details. The description explains the problem with the max_num parameter in Django's formset_factory not behaving as expected when initializing forms with a large number of initial values. It references documentation and provides code examples showing the unexpected IndexError. The issue suggests adding an absolute_max parameter to solve this problem. While the overall goal (adding a new parameter) is clear, there are some implementation details missing about how exactly this new parameter should behave and interact with existing functionality. The issue provides enough context to understand the problem, but would require some interpretation of how to implement the solution effectively. This makes it reasonably specified, not fully well-specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12851": {
        "explanation": "The issue is reasonably specified. The request is to remove the 'ifequal' feature from a template language. While the issue provides the reasoning for the removal (it's not used in modern projects, not recommended, and takes up space), it doesn't provide specific details on how 'ifequal' is implemented or where it's used. However, a software engineer would reasonably understand the task as identifying and removing the 'ifequal' functionality from the template language codebase. The goal is clear, even if the implementation details are not explicitly provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12855": {
        "explanation": "The issue is well-specified and clear. It requests deprecating a specific function in Django's codebase, django.conf.urls.url(), which is currently an alias for django.urls.re_path(). The issue references the commit where the function was introduced and provides context about its deprecation warning. The task is straightforward: update the code and documentation to mark this function as deprecated, following Django's established deprecation process. There is no ambiguity in the request.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12856": {
        "explanation": "The issue is well-specified because it clearly states the problem: when a model gains a UniqueConstraint, makemigrations does not check if the fields exist, unlike the older unique_together syntax. The issue also provides a way to reproduce the problem and shows what the expected behavior should be. This information is sufficient to understand what needs to be fixed and how to test the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12858": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the error message, the context in which the error occurs, and a code example that demonstrates that the ordering works despite the error. The issue is related to a specific error (models.E015) and provides a reference to a previous change (#29408) that is believed to have caused the issue. This information should be sufficient for an experienced developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12869": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem where the collectstatic command does not run staticfiles checks, which is due to requires_system_checks = False. The expected solution is outlined, including the need to run finder.check() for each finder and surface any errors. However, there are some details missing, such as how to integrate the check into the collectstatic command and handle potential errors. These can be reasonably inferred from the context of Django's staticfiles framework.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12906": {
        "explanation": "The issue is well-specified. It clearly states that Django needs to document a change related to the admin's use of the request context processor. The documentation requirements are outlined in three specific locations: release notes, admin docs, and system check framework. The issue also references a commit and explains the impact of the change. This provides a clear understanding of what needs to be done.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12910": {
        "explanation": "The issue is reasonably specified. It describes a proposed change to replace a boolean attribute with a more flexible configuration option that can take different values, such as '__all__' or an empty list. The expected outcome and the motivation for the change are provided, giving enough context for an experienced developer to understand what the change should accomplish. However, some details about the implementation, such as the exact behavior of the new configuration and how it integrates with existing code, would need to be inferred or clarified during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12915": {
        "explanation": "The issue is reasonably specified because it provides a clear error message and traceback, indicating that the 'get_response_async' method is missing from the 'ASGIStaticFilesHandler'. It also explains the context (using ASGIStaticFilesHandler) and the resulting TypeError. While the exact implementation details of the method may require some investigation, the purpose of the task is clear. The issue also references the relevant components (StaticFilesHandlerMixin and ASGIStaticFilesHandler) and the problem is reproducible with the given traceback.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12928": {
        "explanation": "The issue is reasonably specified. It explains the desired functionality (autoreload behavior for cached template loader) and provides an example configuration on how it should work. However, it lacks some implementation details like how to detect template changes, when to trigger a reload, and how to integrate with the existing Django framework. A developer would need to make some reasonable assumptions to implement this feature.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12933": {
        "explanation": "The issue is well-specified because it clearly describes the problem and the desired solution. It states that currently, when 'clearsessions' is called on a backend that does not implement 'clear_expired()', it writes to stderr directly. The desired solution is to raise a CommandError instead of writing to stderr. This is further supported by a reference to a PR and a note from Fran\u00e7ois Freitag about the recommended behavior. The issue has a clear goal and the steps to fix it would involve modifying the 'clearsessions' command to check if the backend implements 'clear_expired()' and raise a CommandError if it does not. Therefore, it is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12957": {
        "explanation": "The issue is reasonably specified. It indicates that in the file contrib/gis/templates/gis/admin/openlayers.js, float values should be marked as safe using the |safe filter to prevent the DECIMAL_SEPARATOR setting from altering the JavaScript syntax. While the specific implementation details (e.g., exactly which float values need the |safe filter) might require some investigation, the general approach and goal are clear. A developer can reasonably infer the necessary steps to address the problem based on the information provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-12961": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The user provides a detailed description of the problem, including a clear example with model definitions, sample data, and the specific error that occurs when trying to use 'order_by' with 'F' expressions on a union of querysets. The user also explains the expected behavior and suggests that if it's expected, the error message should be more explicit. This information is sufficient to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12965": {
        "explanation": "The issue is well-specified with a detailed explanation of the problem, including specific examples of the SQL generated in different Django versions, performance benchmarks, and the impact on locking. The cause of the issue and the consequences are clearly explained, making it clear what needs to be addressed. The desired solution is to revert or modify the behavior to avoid the subquery in the DELETE statement to maintain compatibility with LOCK TABLES and improve performance.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12973": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: when the AuthenticationMiddleware is added to the MIDDLEWARE without the SessionMiddleware, an AssertionError is raised. The desired solution is to update the order of the errors output to prevent this exception in the specific scenario described. All the necessary information is provided to understand what needs to be done.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-12983": {
        "explanation": "The issue is well-specified. The problem is described with a clear example of the current behavior and the desired output. It explains that the slugify function should be modified to strip dashes and underscores from the string. The example shows the current and expected output, which makes it clear what the solution should achieve. A software engineer could reasonably implement this change by modifying the slugify function to remove these characters.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13012": {
        "explanation": "The issue is well-specified. It clearly explains the problem with including constant expressions in the GROUP BY clause when using ExpressionWrapper, provides a minimal example to reproduce the issue, and shows the expected behavior when not using ExpressionWrapper. The issue also includes the exact error message and the SQL queries generated by Django, which helps in understanding the problem. There is a clear description of the discrepancy between the two cases (with and without ExpressionWrapper) and what the expected outcome should be.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13023": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: DecimalField.to_python() raises a TypeError instead of a ValidationError when given a dictionary as the value parameter. The issue also provides context (difficulty tracking the problem to the field in models with many fields) and even links to a proposed patch. This provides sufficient information for a software engineer to understand what the expected behavior should be and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13028": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with the error message and the code that is causing the issue. It also explains the solution that was found (renaming the field). However, it is not clear if the goal is to document this behavior or to find a fix that does not involve renaming the field. These are two different tasks, and without clarification on which one is needed, there is some ambiguity.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13030": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It describes the problem of passing NULL to the IN lookup in the context of Django's prefetch_related on a ForeignKey. The issue includes a detailed explanation of why passing NULL is unnecessary and potentially problematic, along with example models, steps to reproduce the issue, and a specific example of the generated SQL query with NULL included. The issue also suggests a possible extension of the solution to non-nullable fields. All of these details provide clear guidance on what needs to be fixed and how to approach the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13033": {
        "explanation": "The issue is well-specified because it provides the following key details that are necessary for understanding and solving the problem:\n\n1. **Model Definitions**: It includes the full model definitions for `OneModel` and `TwoModel`, which clearly show the self-referencing foreign key and the relationship between the models.\n\n2. **Reproduction Steps**: The issue provides specific code examples of different querysets and their resulting SQL queries, including the problematic ones and the working ones. This makes it easy to reproduce the issue and understand the unexpected behavior.\n\n3. **Expected vs. Actual Behavior**: The issue clearly states what the expected SQL should look like and what is actually happening (unnecessary joins, incorrect sorting behavior due to the default ordering in the model's Meta class).\n\n4. **Environment and Versions**: It mentions that the problem was initially observed in version 2.2.10 and confirmed in 3.0.6, which helps in understanding if it's a regression or a long-standing issue.\n\n5. **Observations and Workarounds**: The issue explains what the user has already tried, including a working workaround using `annotate` and `F`, and also explores variations of the problem when changing the sort order. This gives insight into what might be causing the issue.\n\n6. **Clear Question**: The issue ends with a clear question: \"Is this a potential bug or a misunderstanding on my part?\" which shows the user is seeking an explanation or confirmation of the behavior, not just a solution.\n\nGiven all this information, a software engineer would be able to reproduce the issue, analyze the Django ORM's behavior, and determine whether it's a bug or an intended behavior with a possible workaround.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13066": {
        "explanation": "The issue is well-specified. It clearly states that Argon2id should be supported and become the default for Argon2PasswordHasher. It provides detailed context about the changes in the upstream library, including the addition of argon2id, its default status, and updated parameters. This provides enough information for a software engineer to implement the necessary changes to the Django codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13077": {
        "explanation": "The issue is reasonably specified because it describes the problem and provides some context about the cause. However, there are some blanks to fill in about the exact conditions and the root cause of the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13085": {
        "explanation": "The issue is well-specified with a clear problem statement and proposed solution. The user explains that the compilemessages command in Django is running msgfmt on unchanged .po files, causing unnecessary execution time. They propose checking the mtime of the .po and .mo files to only run msgfmt when needed, and also mention a potential issue with the is_writable function that modifies mtime. The user even provides their own solution results, reducing runtime from 1.75 seconds to 0.2 seconds in the common case. This provides enough information for an experienced software engineer to implement the proposed solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13089": {
        "explanation": "The issue is reasonably specified because it provides the error message, backtrace, and a clear explanation of the problem. The issue mentions that the 'NoneType' error occurs because the cursor.fetchone() returns None, and suggests adding a check to see if it contains data. This gives enough information to understand the problem and start working on a solution. However, there might be some blanks to fill in, such as the exact condition under which the cursor is empty and how to handle it gracefully.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13109": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example and the expected behavior is explained. The issue provides code examples to demonstrate the problem and a suggested solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13111": {
        "explanation": "The issue is well-specified. It clearly states the requirement to add support for the %V format in WeekArchiveView, which is the ISO 8601 week format. The issue also references a previously closed ticket (#26217) which provides additional context. It explains that with Python 3.6, the %G, %u, and %V formatters were added to strptime, which are part of the ISO 8601 standard. The specific change required is to add %V to the list of accepted week formatters in WeekArchiveView. Furthermore, the issue mentions the need to handle a special case where the year format should be changed to %G instead of %Y when using %V, or alternatively, raise a ValueError with a specific message when there's an incompatibility between %V and %Y. This provides a clear direction on what needs to be done to resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13112": {
        "explanation": "The issue is reasonably specified. It explains the error that occurs when running makemigrations in Django 3.1b1, provides the relevant code from models.py, settings.py, and apps.py. The problem seems to be related to the app name case sensitivity, as the app is installed as 'DJ_RegLogin' but referenced as 'dj_reglogin' in the error. A software engineer would need to investigate how Django handles app names and lazy references in this version to resolve the issue. There are some assumptions to be made, but a sensible interpretation of the required solution is possible.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13115": {
        "explanation": "The issue is reasonably specified. It describes the need to add error checking when certain parameters are combined with 'deferrable' in UniqueConstraint, specifically when parameters require the use of an explicit unique index. While the general direction is clear, there may be implementation details that need to be filled in, such as exactly which parameters to check and how to implement the error logic. The mention of adding documentation also provides a clear task, but the specifics of that documentation are not detailed. Overall, a developer can reasonably interpret what needs to be done, but will need to make some decisions during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13121": {
        "explanation": "The issue is reasonably well-specified because it provides a clear example of the problem, including the model definition, the query causing the error, and the error traceback. It shows that the durations-only expressions cause an error in SQLite and MySQL databases. However, the issue lacks some details about the expected behavior, the specific versions of Django and the databases, and a proposed solution. Despite these missing pieces, it's clear that the issue is about fixing the error when performing duration field expressions in these databases. A software engineer can work with this information to investigate and fix the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13128": {
        "explanation": "The issue is reasonably specified. The user is providing a code example that is causing an error and is asking to make temporal subtraction work without using ExpressionWrapper. The problem is clear: the current code produces a FieldError due to mixed types. The desired outcome is also clear: perform the subtraction without ExpressionWrapper. However, there are some details to fill in, such as the exact implementation or how to handle the output field correctly. But based on the context and error message, a sensible interpretation of what is required can be made.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13158": {
        "explanation": "The issue is well-specified enough to understand the problem and reproduce it. The user provided a clear example of the problem with code, and explains the difference in behavior between the OR query and the union() method. The expected vs actual behavior is clear, making it possible to create a meaningful solution. The issue is a bug report where the behavior of QuerySet.none() on combined queries is not working as expected.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13162": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem with the current merge migration naming convention is clearly explained, and a specific proposed solution is provided with examples of the desired format. The request is to change the default merge migration filename from a timestamp-based format to one that combines the files being merged. The issue also acknowledges that there may be different ways to combine the names, but provides a starting approach that can be adjusted if needed. All the necessary information to understand the problem and implement the solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13170": {
        "explanation": "The issue is reasonably specified. It explains the current limitation of FilteredRelation's condition not supporting nested relations and provides a code example that demonstrates the problem. The request is to support nested relations in FilteredRelation's condition. While the exact implementation details are not provided, the general goal is clear. A developer would need to understand how FilteredRelation currently processes conditions and modify it to handle nested relations.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13192": {
        "explanation": "The issue is reasonably specified because it provides enough information to understand the problem and the root cause. It explains that email names over 75 characters are causing errors due to a recent Python update which no longer allows the Header class to introduce newlines at 75 characters. It also points to the specific code location in Django where the issue occurs and provides a reference to the Python commit that changed the behavior. This information allows a software engineer to identify the problem and work on a solution, even if some implementation details might need further investigation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13195": {
        "explanation": "The issue is well-specified because it includes a detailed problem description, the warning message, examples of the cookie headers before and after deletion, and a proposed fix. The reporter also explains the implications of not setting the SameSite attribute and the secure flag correctly. All the necessary information is provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13199": {
        "explanation": "The issue is well-specified because it includes a detailed problem description, the warning message, examples of the current and desired behavior, and even a proposed fix. The reporter explains the problem with the delete_cookie method not preserving the samesite attribute, and provides a code snippet showing how they modified the method to fix the issue. This gives clear guidance on what needs to be fixed and how it should behave. The issue is specific enough to allow for a meaningful attempt at a solution without requiring significant additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13212": {
        "explanation": "The issue is reasonably specified. The request is to modify built-in validators to include the provided value in ValidationError so that custom error messages can use a %(value)s placeholder. While the specific implementation details are not provided, the problem and desired outcome are clear enough to guide the development. The example given and the reference to the Django documentation provide a good context for understanding the intended functionality.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13218": {
        "explanation": "The issue is well-specified. It explains the problem (migrations directories without __init__.py files are not working), provides background on why this is happening (Python 3 namespace packages), and explains the technical cause (a __file__ check that is no longer needed). The issue also references related work and pull requests. This provides enough information for an experienced developer to understand what needs to be changed in the codebase to remove the __file__ check and allow namespace packages to work with migrations. The expected outcome is clear - allow migration directories without __init__.py files to work properly.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13220": {
        "explanation": "The issue is reasonably specified. It clearly states the problem (ValidationErrors with identical messages don't equal each other) and the desired solution (add an __eq__ method). However, there are some details to be filled in, such as the exact implementation of the __eq__ method and how to handle nested errors. The mention of comparing independent of order suggests a specific approach, but the exact implementation would require some interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13230": {
        "explanation": "The issue is reasonably specified. It asks to add a 'comments' argument to the 'add_item()' function in 'syndication.views' to support 'item_comments'. It also mentions that 'comments' is already in 'feedparser' but not implemented in the view. While it provides a clear direction, there are a few details that need to be filled in, such as how to integrate this new argument into the existing code structure and what specific functionality is expected from 'item_comments'. However, with the context provided, a developer can make sensible assumptions and proceed with the implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13240": {
        "explanation": "The issue is reasonably well-specified, but there are some details that would need to be clarified or inferred from the codebase. The main task is clear: change the behavior so that the ImproperlyConfigured exception is raised when SECRET_KEY is accessed, rather than during initialization. However, without seeing the codebase, it's not immediately clear how the settings are structured or how the SECRET_KEY is currently being checked. The developer would need to locate where the initialization check occurs and modify it to instead perform the check when the SECRET_KEY is accessed. The use case and current workaround are well-explained, which helps in understanding the motivation behind the change. Overall, while the high-level goal is clear, some implementation details would need to be explored within the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13250": {
        "explanation": "The issue is about the JSONField's __contains and __contained_by lookups not working with nested values on SQLite. The description provides specific examples of what is not working and references test cases. However, it does not clearly outline the expected behavior or the exact implementation needed to fix the problem. The user is unsure if it's feasible to emulate the correct behavior in Python and mentions that SQLite doesn't provide a native way for testing containment. While there is enough information to understand the problem, there are still gaps in understanding what the solution should look like. Therefore, there are some blanks to fill in about the issue, but there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13251": {
        "explanation": "The issue is well-specified. The problem is described with a clear example of the error, the conditions under which it occurs (a field named 'negate'), and a workaround. A software engineer would be able to reproduce the issue and understand what needs to be fixed based on the information provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13265": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is that the AlterOrderWithRespectTo operation is being executed after the AddIndex operations that depend on the _order field, which has not been created yet. The solution is to reorder the migration operations so that AlterOrderWithRespectTo is executed before the AddIndex operations that reference the _order field. The issue provides enough information to understand the problem and determine the necessary fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13267": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the code that causes the error, the error message, and the context in which it occurs. It also mentions that the issue is related to a change between Django versions (1.8 to 1.9.8) and references specific documentation and source code. This information allows a developer to understand the problem and reproduce it, making it possible to work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13279": {
        "explanation": "The issue is reasonably specified. It describes a problem with session data decoding after a format change in a specific commit when transitioning to Django 3.1. It mentions that changing the DEFAULT_HASHING_ALGORITHM to 'sha1' is not sufficient and suggests a potential workaround. While there are some implementation details that would need to be filled in, the general problem and desired outcome are clear enough for a software engineer to attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13281": {
        "explanation": "The issue is about a change in behavior between Django versions 1.11.x and 2.x regarding the caching of foreign key (FK) fields when copying model instances. The reporter provides a detailed description of the problem, including a specific commit that might have introduced the change, a test case that demonstrates the issue, and their own proposed solution based on a suggestion from the Django community. The question is whether the new behavior in Django 2.x is correct and what the recommended way to clone a model instance is.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13287": {
        "explanation": "The issue is well-specified because it clearly describes the problem (an app with default_app_config and without apps.py or with an empty apps.py crashes), provides detailed error messages, and identifies the root cause as a regression related to a specific Django ticket. The problem scenario is clearly outlined, and the expected outcome (fixing the crash) is implied. The detailed stack traces and context make it possible to understand what is failing and under what conditions.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13295": {
        "explanation": "The issue is reasonably specified. It clearly describes a problem with Django's save method when using update_fields with a non-concrete field. It provides context about how non-concrete fields work, explains the current behavior (silent failure), and suggests a potential cause (the difference in field checks between meta.fields and meta.local_concrete_fields). The issue also proposes possible solutions (either allowing non-concrete fields to specify underlying fields or adding an error for this case). While there are some implementation details that would need to be worked out, the problem and desired outcome are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13297": {
        "explanation": "The issue is well-specified. The problem is described in detail with code examples showing the issue in Django 3.1 and the workaround. The error message is included, and the context is provided (Python 3.7.8 with SQLite). The specific change in behavior between Django 3.0 and 3.1 is clearly explained. All the necessary information to understand the issue and reproduce it is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13300": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: the Exists() function in Django generates subqueries with SELECT fields, which can be large and hard to debug. The desired solution is to use SELECT 1 instead, similar to how the .exists() method does. However, there are some implementation details that would need to be filled in, such as how to modify the Django ORM to change the subquery generation. The benefits (reducing query size and improving debuggability) are also clearly explained. While the general direction is clear, some technical details would need to be worked out during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13301": {
        "explanation": "The issue is well-specified. It clearly describes the problem: the default username validation in the createsuperuser command does not respect the --database option, causing issues when using multiple databases. The problem is clearly defined, and the desired outcome is to have the validation check the correct database specified by --database. This provides enough information for a software engineer to understand the issue and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13315": {
        "explanation": "The issue is reasonably specified. It describes a problem where using a Q object with join in limit_choices_to on a ForeignKey field can cause duplicate options in a form. However, there are some details missing, such as the expected behavior and specific steps to reproduce the issue. The reference to a regression test in a patch suggests that more information is available there, but without that patch, some interpretation is needed to understand the exact requirements for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13321": {
        "explanation": "The issue is reasonably specified because it provides detailed error logs and context about the problem. The reporter mentions that upgrading to version 3.1 caused a crash when decoding invalid session data, and the error traceback is included. However, without access to the codebase, some assumptions must be made about how session data is handled and where the bug might be. The reporter also mentions that the issue occurs only in the staging environment and with Chrome, which may require further investigation into environment-specific configurations. Despite these considerations, the information provided is sufficient for a software engineer with access to the codebase to begin troubleshooting and implementing a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13325": {
        "explanation": "The issue is reasonably specified. It lists the specific functions in the codebase that need to be fixed (validate_key() should be called) and mentions the need for a test to ensure this is done for all operations. However, there are some details that would need to be filled in by the developer, such as the exact implementation of validate_key() and how to handle cases where it might raise exceptions. The overall goal is clear, but some specifics would require interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13341": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem (TemplateView automatically passing kwargs into the context causing SimpleLazyObject issues), provides example code that demonstrates the issue, and explains the error that occurs. The reporter has also noted the difference in behavior between Django 3.0 and 3.1, and how the workaround (explicitly converting to string) is needed. This provides sufficient information to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13343": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description clearly explains the problem with the FileField's deconstruction when using a callable storage parameter. It describes what the current incorrect behavior is, what the expected correct behavior is, and even references where the bug was introduced in the codebase. The issue also provides context by mentioning the documentation and comparing it with the behavior of the upload_to parameter. This information allows an experienced software engineer to understand the problem and work on a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13344": {
        "explanation": "The issue is well-specified. It clearly describes the problem (a coroutine is passed to the first middleware's process_response method instead of an HttpResponse), provides a detailed explanation of the problem, and includes a step-by-step guide to reproduce the issue. The issue also references a real-world example (django-cors-headers package) that is affected by this behavior. The information provided is sufficient to understand the problem and create a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13346": {
        "explanation": "The issue is reasonably specified. The problem is that the __in lookup doesn't work as expected on key transforms when using models.JSONField. The reporter has provided code examples that demonstrate the discrepancy between the behavior of __in and direct key lookup. They also mention that they are switching from django_mysql.models.JSONField to models.JSONField, which suggests there might be a compatibility issue. The issue is not fully detailed in terms of the exact database backends affected or the expected SQL queries, but the core problem is clear enough to attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13347": {
        "explanation": "The issue is well-specified. The problem is clearly described: the SafeExceptionReporterFilter does not recurse into dictionaries with non-string keys. A specific example is provided to illustrate the issue. The cause of the issue is explained, pointing to a specific line of code. This provides enough information for an experienced developer to understand what needs to be fixed and how to approach the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13354": {
        "explanation": "The issue is well-specified with a clear problem statement, steps to reproduce, and expected outcome. The user has also provided a detailed analysis of the problem. All necessary information is present for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13363": {
        "explanation": "The issue is well-specified with a clear description of the problem, including specific code references and an example of the expected behavior. The reporter explains that the TruncDate and TruncTime functions are not utilizing the passed tzinfo parameter correctly, and there is an example of how it should work. The problem is described in detail and the reporter even provides a workaround and a reference to a PR, which further clarifies the context and expected solution. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13369": {
        "explanation": "The issue is well-specified because it includes a clear example of the problematic code, the exact error message, and a traceback showing where the error occurs. It also notes that this worked in a previous version (Django 3.1) but is failing in the current version (Django 3.2). This provides enough information to reproduce the issue and understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13371": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is clearly described with a code example showing that the Row class from Django is not pickleable, and the impact of this issue on the cacheops package is mentioned. A software engineer would understand that the goal is to make the Row class pickleable to resolve the compatibility issue with cacheops and other systems that rely on pickling.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13386": {
        "explanation": "The issue is reasonably specified. The main goal is clear: convert the max_age parameter to an integer in the set_cookie() function. However, there are some open questions that need to be resolved before implementation, such as how to handle floats with non-zero decimal parts and what to do if conversion to an integer is not possible. These are reasonable considerations that can be resolved with standard approaches (like truncating or rounding for floats, and raising an exception for invalid conversions).",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13401": {
        "explanation": "The issue is well-specified. The problem is described in detail with a clear example of the current behavior and the desired outcome. The reporter has already researched the issue and provided insight into the root cause (fields comparing as equal). They've also discussed the potential solution (modifying __eq__, __hash__, and __lt__ methods to account for different field.models) and even mentioned a possible caveat when changing the ordering in __lt__. The issue has been discussed on the django-dev IRC channel, indicating that it's a recognized problem within the community. This provides enough information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13406": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue includes a detailed description of the problem, a minimum reproducible example with code, and the exact error message. The user is encountering a problem where pickling and unpickling a Django queryset query that uses values() and annotate() results in incorrect behavior when the query is reused. The problem is clearly explained, and the steps to reproduce are provided, making it possible to understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13410": {
        "explanation": "The issue is well-specified. The problem is clearly described: the current implementation of the posix version of locks in django/core/files/locks.py is returning False even when the lock is successfully acquired because the cpython fcntl module returns None on success and raises an OSError on failure. The user also provides a suggested fix in the form of a diff that modifies the lock and unlock functions to use try-except blocks to return appropriate boolean values. This provides a clear direction for implementing the solution. There is no ambiguity in the requirements and the necessary changes are clearly outlined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13417": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue explains that the 'ordered' property of a QuerySet is not correctly reflecting whether the resulting SQL query will have an ORDER BY clause. It provides a clear example using a model with Meta.ordering, and demonstrates the problem with two querysets: one with default ordering and one with an annotation that introduces a GROUP BY clause. The issue also explains that the 'ordered' property incorrectly remains True even when the SQL will not have an ORDER BY clause. This is a clear bug report with a specific problem and example that can be addressed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13431": {
        "explanation": "The issue is well-specified. The user has provided a clear description of the problem, including a simplified model, the query they are executing, the SQL query that is being generated, the expected SQL query, and the error that is occurring. The problem is that the aggregate functions are not correctly referencing the annotated field in the subquery. The solution would involve ensuring that the aggregate functions reference the correct column name (the alias created in the annotate) in the generated SQL. The issue is specific enough that a software engineer could look at the relevant Django code (probably in the aggregation or query generation parts) and make the necessary changes to ensure that the aggregate functions use the correct field names.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13447": {
        "explanation": "The issue is reasonably specified. The user wants to manipulate the app_list in a custom admin view by having access to the model class, and also make the _build_app_dict method public. These are clear goals, but the exact implementation details may require further clarification.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13449": {
        "explanation": "The issue is well-specified because it includes a detailed description of the problem, a clear example of the code that reproduces the issue, the error message, a stack trace, and the generated SQL query. The user also explains their understanding of the cause of the problem and provides a workaround. All necessary information for a meaningful attempt at a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13454": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem (a crash when using EmptyFieldListFilter with GenericForeignKey), provides a code example that reproduces the issue, and explains the expected behavior. However, there are some gaps in the information, such as the version of Django being used, the exact error traceback, and the environment details. Despite these gaps, the core problem and the desired solution are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13460": {
        "explanation": "The issue is well-specified. It provides a clear example of the problem with the template code, the error message, and the cause of the error. It also suggests potential solutions. A developer would be able to understand the problem and know what needs to be done to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13466": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue provides a detailed description of the problem, including the management command code, the usage that works and fails, and the traceback of the error. A solution would involve understanding why passing a boolean argument to call_command is causing an error with the mutually exclusive group and finding a way to handle boolean arguments correctly.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13490": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, a minimal example that reproduces the issue, and the expected vs actual behavior. The example shows that when using the difference() method and then calling get() with a filter, Django raises an incorrect error about multiple objects returned. The issue also includes Django and Python versions, which is helpful for reproduction. All necessary information is provided to understand the problem and reproduce it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13495": {
        "explanation": "The issue is well-specified enough to understand the problem and the expected behavior. The user is using the TruncDay() function with a DateField and a timezone, but the timezone conversion is not applied in the generated SQL for PostgreSQL. The user provided code analysis shows that the timezone conversion is only applied when the output_field is a DateTimeField. The issue clearly states the problem, includes example code, and highlights the part of the codebase that needs to be changed. There is a clear understanding of what the problem is and what the desired outcome should be. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13512": {
        "explanation": "The issue is about Django admin not displaying Unicode characters properly in JSONFields, instead showing ASCII-encoded representations. The reporter provides a clear example using json.dumps and explains the behavior. They also reference a potential fix in a specific pull request. Based on this information, a software engineer could understand the problem (Unicode characters being escaped to ASCII in JSONField display) and would likely know how to investigate and potentially implement a fix by looking at the referenced pull request and Django's JSONField implementation. The issue is well-defined with a clear problem statement, example, and pointer to a possible solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13513": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including a code example that reproduces the issue, an explanation of why it is happening (the get_traceback_frames() function not respecting exc.__suppress_context__), and even a proposed fix for the issue. The issue refers to a specific line of code in the Django repository and explains how the function should be modified. All of these details make it possible to create a meaningful PR that resolves the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13516": {
        "explanation": "The issue is reasonably specified. The problem is that the flush() method for stdout/stderr in management commands is not working as expected, leading to delayed output during long migrations. The user provides an example of the current behavior and the expected behavior. While the exact code or context for the flush() implementation is not provided, a software engineer with experience in the codebase could infer the necessary changes based on this information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13528": {
        "explanation": "The issue is about a problem with the Django template filters intcomma and floatformat when used together in certain locales, such as Germany, where the decimal separator should be a comma. The issue provides a specific example of the unexpected behavior when applying these filters to a decimal value, and clearly explains the expected versus actual output. Although there are some minor language issues (e.g., 'u' instead of 'you', some typos), the core problem is clear: when chaining floatformat and intcomma, the output is not properly localized. The issue is well-specified enough for a software engineer to understand what needs to be fixed, reproduce the problem, and implement a solution. There is a clear example (1000.11 should become 1000,11 in Germany but is instead becoming 1,000,11), and the context of using these filters in templates is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13530": {
        "explanation": "The issue is well-specified enough to understand the problem. It provides a clear description of the issue, sample code to reproduce it, sample data, the error, and even a note that it was working before Django 3.1. All necessary details are present to reproduce and fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13537": {
        "explanation": "The issue is reasonably specified. The problem is described as the 'dbshell' command not respecting the 'database_options' setting, specifically in the context of character set configurations for MySQL. The reporter provided a real-world scenario where this issue was encountered and even included a patch that addresses the problem. While there are some areas requiring interpretation (e.g., how to generalize the solution to other backends), there is a clear understanding of the issue and a proposed solution. This allows for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13551": {
        "explanation": "The issue is well-specified. It provides a clear sequence of steps that reproduce the problem, explains the current behavior versus the expected behavior, and even suggests a fix (adding the user's email into _make_hash_value()). It also mentions potential considerations regarding the email field in the user model. All necessary information is provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13553": {
        "explanation": "The issue is well-specified enough to understand the problem and the proposed solution. The user provides a clear description of the problem, including code examples, error messages from different databases, and a proposed solution. It is clear what the expected behavior should be and what the current behavior is. The issue is related to the Django ORM's QuerySet API and how it handles the union() method in combination with the order_by() method. The issue is also well-documented with a test case that reproduces the problem. Therefore, it is clear what needs to be done to resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13556": {
        "explanation": "The issue is reasonably specified. The problem is that passing None to transaction.on_commit() causes a TypeError because None is not callable. The request is to either prevent registering None or handle it gracefully. While there are some implementation details to determine (like how to handle or validate the input), the overall goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13560": {
        "explanation": "The issue is reasonably specified. The problem is that the exception message contains an iterator object, which is not informative when viewed in Sentry. The goal would be to modify the code in Collector.collect so that it does not include the iterator in the exception message. There are some details that need to be filled in, such as exactly how to modify the exception message or what alternative information to provide, but the general problem is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13568": {
        "explanation": "The issue is reasonably specified. It describes a scenario where a system check (auth.E003) is being triggered unnecessarily when a USERNAME_FIELD is included in a UniqueConstraint. It explains the context (a custom user model with a unique constraint on the USERNAME_FIELD) and the problem (unwanted system check error). The proposed solution is also outlined - checking for the presence of the USERNAME_FIELD in Model._meta.constraints. There is enough information to understand the problem and implement a fix, though some implementation details may need to be worked out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13569": {
        "explanation": "The issue is well-specified. It includes a clear problem description, steps to reproduce the issue, code examples showing the problem, and even a proposed patch to fix the issue. The reporter explains what is happening (using order_by('?') is breaking the aggregation), why they believe it's a problem (the random function has no logical connection to the aggregation), and provides technical details of where the problem occurs (in the SQL compiler's get_group_by method). This provides all the information needed to understand the issue and implement a solution. The reporter even suggests how to fix it, though the solution may need to be refined or adapted for different database backends.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13578": {
        "explanation": "The issue is well-specified. It clearly describes the problem (a non-informative error message when a prefix is incorrectly specified), explains the scenario in which this occurs, and even suggests a solution (including form._errors in the output). The issue also references specific code lines and expected error details. This level of detail makes it possible to understand what needs to be fixed and how to approach the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13589": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem with an example and shows the error that occurs. However, it leaves some room for interpretation regarding the exact desired solution. The reporter describes the current behavior and the expected outcome, but the implementation details of how to achieve this are not fully specified. A software engineer could reasonably interpret what needs to be done, but there are some design considerations (like how to handle the foreign key assignment automatically) that would need to be filled in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13590": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem (named tuples used as arguments to __range cause errors when upgrading from Django 2.2 to 3.0), provides the error message (TypeError: __new__() missing 1 required positional argument: 'far'), explains the root cause (Query.resolve_lookup_value attempts to reconstitute the tuple but passes an iterator to the constructor), and suggests a potential fix (expand the contents of the iterator into the constructor). The information provided would allow an experienced developer to locate the relevant code in Django's Query class and implement the necessary change.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13606": {
        "explanation": "The issue is well-specified as it clearly describes the problem with the current implementation, the reason for the change (optimization and handling of NULL values), and the proposed solution (using NOT EXISTS instead of NOT IN). The target function (sql.Query.split_exclude) is mentioned, providing a clear starting point for the implementation. All necessary information is provided to understand what needs to be done and why.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13615": {
        "explanation": "The issue is reasonably specified. The goal is to add a warning when an incorrect locale code is used with the `l` flag in the makemessages command. The user suggests normalizing the directory name to a consistent format (e.g., zh_CN) regardless of input variations (e.g., zh_cn, zh_CN, ZH_CN, ZH-CN). While the general approach is outlined, specific implementation details like where to add the warning, how to normalize the locale code, and what constitutes an incorrect locale code are not fully detailed. These details can be reasonably inferred or explored in the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13616": {
        "explanation": "The issue is about improving the error message raised by the 'makemessages' command when the '/locale' directory does not exist under the app directory. The user suggests that the error message should be clearer and more helpful, possibly indicating that a 'locale' directory is expected. However, the issue lacks specific details about the exact changes needed to the error message, the expected behavior, or the conditions under which the error should be raised. While the general idea of improving the error message is clear, the specifics of what the new error message should say, how it should behave, and what the exact requirements are are not well-defined. There are multiple possible interpretations of how to implement the suggested improvement. Therefore, the issue is reasonably specified but has some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13620": {
        "explanation": "The issue is well-specified. It includes a code example that demonstrates the problem with the current behavior when using list arguments inside exclusive required groups. The example shows the incorrect parsing of the list when using call_command, and the expected outcome is clear. The reporter also mentions the workaround they've found, which provides context for the problem. All the necessary information is provided to understand what needs to be fixed in the Django management command framework.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13658": {
        "explanation": "The issue is well-specified. The problem is clearly described with code snippets showing the current implementation and the proposed fix. The issue explains that ManagementUtility parses the program name correctly from the provided argv but later uses sys.argv[0] when it should be using the computed self.prog_name when creating the CommandParser. The issue also provides the exact code change that would fix the problem. This makes it clear what the problem is and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13660": {
        "explanation": "The issue is well-specified with a detailed description of the problem, including specific examples of the shell command crashing when passing Python code with functions to the Django shell using the -c option. The reporter provides a clear explanation of the problem and even suggests a potential solution by indicating that the exec function should be passed a dictionary containing a minimal set of globals. The examples show the contrast between the standard Python interpreter and the Django shell's behavior, making it clear what the expected and actual behaviors are. This level of detail provides a clear path for a software engineer to understand the issue and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13665": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the relevant code snippets, the error that occurs, and a reference to a proposed fix. The issue clearly states that the test is failing because the serialization is using the wrong manager, and it provides the context for why this is happening. The reference to a specific pull request also provides a direction for the solution. This information allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13667": {
        "explanation": "The issue is well-specified. It clearly explains the current behavior of QuerySet.exists() and the desired optimization for QuerySet.union().exists(). It provides concrete examples of the SQL queries before and after the optimization, and explains why this optimization is needed (to help query planners that cannot optimize combined queries automatically). The issue also notes limitations (that this optimization is only applicable to union and not to intersection and difference). With this information, an experienced software engineer would be able to understand what needs to be implemented in the Django ORM to achieve the described optimization. The problem is clearly defined, the expected outcome is clear, and the scope is well-understood.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13670": {
        "explanation": "The issue is well-specified because it includes a clear problem description, examples of the current behavior in Django versus the expected behavior based on Python's datetime and PHP, and even a link to a pull request with a proposed solution. The problem is about how the 'y' format character in Django's dateformat does not handle years less than 1000 by not adding leading zeros, unlike Python and PHP. This provides enough information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13682": {
        "explanation": "The issue is well-specified. The problem is clearly described: when a user forgets to call .as_view() on a class-based view (CBV) when passing it to path(), the error occurs later when the route is loaded, and it's not beginner-friendly. The issue provides a specific example of how the error currently manifests, and it explains the desired improvement: to detect the mistake earlier (during route construction) with a clearer error message. The issue also references a pull request that implements the solution, which further clarifies the expected outcome. All the necessary information to understand the problem and what needs to be fixed is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13684": {
        "explanation": "The issue is reasonably specified. The problem is about an error message that is not helpful when a database backend (django_cockroachdb) fails to import. The example shows the error traceback and the resulting ImproperlyConfigured exception. The reporter suggests changing the error message to include information about the import failure and possibly adjusting the advice in the error message. While some specifics about how to implement the change might need to be inferred, the general direction is clear enough for a meaningful solution attempt. The reporter also hints at potential conditions for when to show certain parts of the error message (e.g., if the backend name starts with 'django').",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13689": {
        "explanation": "The issue is well-specified because it clearly describes the problem with a specific example, including the code that reproduces the issue, the expected SQL query, and the actual SQL query. The problem is about a bug in Django where the ExpressionWrapper is not properly included in the GROUP BY clause when using annotate and values. All necessary information is provided to understand the problem and reproduce it, making it possible to create a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13691": {
        "explanation": "The issue is well-specified enough to understand the problem. It describes the problem with JSON path lookup in Sqlite when the value is numeric, which leads to a JSON decode error. The issue mentions the specific error message, the versions of Django and the problem with Sqlite compared to other databases. It also includes a traceback. This information is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13693": {
        "explanation": "The issue is well-specified because it includes a detailed error traceback, environment information, steps to reproduce, and even a working monkey-patch solution. The problem is clearly identified as Django's autoreload module passing a WindowsPath object instead of a string to subprocess.Popen on Windows with Python <3.8. All necessary information is provided to understand and implement a proper fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13708": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The task is to add a 'durable' flag to the transaction.atomic() function. The description provides context about why this feature is needed (to guarantee durability in addition to atomicity) and explains David Seddon's approach (checking if an atomic() is already active and raising an error). It also references Ian Foote's suggestion and Aymeric Augustin's approval. The goal is clear: implement a 'durable' flag with the described behavior. While the exact implementation details might require exploration of the Django codebase, the problem and desired outcome are well-defined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13710": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem (verbose_name_plural for an Inline is not based on verbose_name, unlike models' Meta classes), and proposes a solution (default verbose_name_plural for Inline should be based on verbose_name). However, there are some implementation details that would need to be considered, such as how to handle existing code and what the exact behavior should be in edge cases. But the core idea is clear and there is a sensible interpretation of what needs to be done.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13714": {
        "explanation": "The issue is reasonably specified. The problem is described with a specific example of the DATABASES configuration, the error message, and steps to reproduce (running ./manage.py migrate). It also explains what the actual problem is (bad file path) and what the expected outcome should be (a more meaningful error message instead of the JSON field error). However, there are some details that would need to be filled in during implementation, such as exactly how to detect and handle the bad file path condition in the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13722": {
        "explanation": "The issue is reasonably specified. It describes a new feature to add a hook for customizing admin formsets parameters. While it provides some context about the default implementation and challenges with using GET parameters, some implementation details may need to be worked out. A developer can reasonably interpret the requirements and proceed with the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13741": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue provides a clear description of the problem (the need for the clean_password method in UserChangeForm to prevent accidental password changes), references relevant documentation, and proposes a specific solution (setting disabled=True on the ReadOnlyPasswordHashField). The expected outcome is clear: removing the need for the clean_password method and eliminating a potential pitfall. The task has a clear goal and can be implemented based on the provided information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13743": {
        "explanation": "The issue is reasonably specified.  It indicates that the ConnectionAbortedError should be treated as a broken pipe error in the development server.  It provides context (links to CPython issues and a specific file and function that should be modified).  However, it's not completely clear exactly how to implement the fix without looking at the code.  For example, I would need to look at the is_broken_pipe_error function in basehttp.py to determine how to modify it to include ConnectionAbortedError.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13744": {
        "explanation": "The issue is well-specified. It clearly states the intention to deprecate the MemcachedCache backend in Django 3.2 and remove it in Django 4.1. It provides reasoning for the deprecation (python-memcached is unmaintained and there's a better alternative with pymemcache). The steps for deprecation in Django are well-known (adding deprecation warnings, documentation updates, etc.) and the timeline is given. A software engineer with Django experience would know exactly how to proceed with implementing this deprecation.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13768": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue description explains that the Signal.send_robust() function currently does not log exceptions raised in receivers, and suggests adding a logger.exception() call in the except clause to log these exceptions. The motivation for this change is provided, as well as the expected outcome (users would see exceptions in error handling tools like Sentry). The task is specific enough that an experienced software engineer could locate the send_robust() method in the Django codebase and implement the suggested change by adding the appropriate logging statement.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13773": {
        "explanation": "The issue is reasonably specified. The problem is described as a crash when renaming fields with a specific pattern (a->c; b->a; c->b) during migration squashing. It mentions the root cause is in the RenameField optimization logic allowing it to optimize through other RenameField operations referencing old_name. A migration file that triggers the failure is mentioned to be attached. This gives a clear path to reproduce and fix the issue. However, the attached migration file is not visible here, so some details may need to be inferred.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13774": {
        "explanation": "The issue is reasonably specified. The problem is described with a clear example of the behavior and the specific code references to the Django source code where the issue occurs. However, there may be some blanks to fill in about the exact behavior expected when there are reused model instances and how to fix the issue. A developer could understand the problem and work on a solution, but there might be some interpretation needed regarding the correct behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13786": {
        "explanation": "The issue is well-specified enough to understand the problem and the expected solution. It explains the current behavior (model options are not cleared when an AlterModelOptions operation with empty options is squashed into a CreateModel operation) and the desired behavior (model options should be cleared as AlterModelOptions does in its state_forwards() method). The issue also provides code references and a test environment. This gives a clear path for a software engineer to investigate and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13791": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, including specific examples that demonstrate the bug. The reporter explains the unexpected behavior of the parse_duration function when handling ISO duration strings with a negative sign and only days. They also provide code examples showing the discrepancy in behavior between different inputs, and even point to a potential location of the issue in the codebase. This information allows a developer to reproduce the issue, understand what the expected behavior should be, and work on a solution. The problem is clearly defined as a bug where the sign is being ignored in certain cases, and the reporter provides sufficient context to make this a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13794": {
        "explanation": "The issue is reasonably specified. It describes a specific problem with the add filter when concatenating a string with a lazy string. The error message and the expected behavior (concatenation) are clear enough to understand what needs to be fixed. However, without knowing the specific implementation details of the add filter and lazy string in the codebase, some assumptions might need to be made to implement the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13797": {
        "explanation": "The issue is reasonably specified. It suggests adding compression support to the dumpdata command, mirroring what loaddata already does. While the exact implementation details (e.g., which compression formats, how to handle command-line options) are not specified, there's a clear direction based on the existing loaddata functionality. The reference to Django's documentation provides context on what is expected.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13807": {
        "explanation": "The issue is well-specified because it provides a clear problem description, steps to reproduce, error messages, and even identifies the exact location of the root cause in the codebase. The problem is using SQL keywords as table names (like 'Order') which leads to a crash when using loaddata with SQLite. It explains that the issue is due to missing backticks around the table name in the SQL statement. This is sufficient information to create a meaningful solution by modifying the relevant code to properly quote the table names.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13808": {
        "explanation": "The issue is well-specified and provides a clear request to allow PostgreSQL database connections to use PostgreSQL services in Django. The issue includes details on how PostgreSQL services work, an example of the current workaround (repeating the database name), and even proposes potential solutions for how the configuration should look. The user also acknowledges that psycopg2 already supports this via the service argument. The issue is clear in what it wants to achieve (allowing the use of service files without coupling the config and service file), and the proposed solutions provide a good starting point for implementation. There is enough information here to create a meaningful pull request that addresses the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13809": {
        "explanation": "The issue is reasonably specified. The request is to add a --skip-checks option to the runserver command in a Django-like framework. The rationale is provided, explaining that this would be consistent with other management commands and would improve development efficiency by skipping checks during local development. The related Stack Overflow question also supports the need for this feature. However, some details are missing, such as exactly how this option should behave (e.g., should it disable all checks or only specific ones?), and how it should integrate with existing command-line options. These are reasonable assumptions that can be made based on common practices in similar commands.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13810": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. It is a bug report with a detailed description of the problem and a repository with a minimal example, but it is not a clear instruction on what needs to be changed. The issue is more of a bug report that requires investigation and analysis to understand the cause and potential solution. Without further information on what the expected behavior should be or what specific changes are needed in the codebase, it is difficult to determine what a successful solution would look like. Therefore, it is labeled as VAGUE.",
        "label": "VAGUE"
    },
    "django__django-13814": {
        "explanation": "The issue is well-specified and provides a clear explanation of the problem, including the code location, the behavior being observed, and a detailed reproduction scenario. It explains that the current exception handling in 'get_package_libraries' masks the original ImportError by raising 'InvalidTemplateLibrary' instead, making debugging more difficult. The issue also provides a comparison of the desired behavior (raising the original ImportError) and the current behavior (raising a new exception that hides the original one). The steps to reproduce are clear and actionable. This provides enough information for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13820": {
        "explanation": "The issue is quite detailed and provides specific information about the current implementation, the problem with it, and the proposed solution. It mentions the specific code file and method (django.db.migrations.loader.MigrationLoader.load_disk), the condition being checked (getattr(m, '__file__', None)), and the proposed change (augmenting with isinstance(m.__path__, list)). The issue also explains the context of frozen Python environments and how this change would affect them without changing behavior for normal environments. The request is specific to improving the check for namespace packages in migration loading. While it is a technical issue that requires understanding of Django's migration system and Python's import system, the problem and proposed solution are clearly defined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13821": {
        "explanation": "The issue is about dropping support for SQLite versions earlier than 3.9.0. It provides context about why this change is being considered, such as the availability of features like indexes on expressions and the SQLITE_ENABLE_JSON1 compile-time option in versions 3.9.0 and above. It also gives information about the EOL status of certain distributions and the age of SQLite 3.9.0. However, the actual implementation steps required to make this change are not provided, and the specific code changes that need to be made are not outlined. Despite this, a software engineer with experience in Django and SQLite would be able to interpret what needs to be done based on this information. They would need to identify and modify any code that checks for SQLite versions, remove or update compatibility code for older versions, and ensure that new features requiring 3.9.0 are properly supported. Therefore, the issue is reasonably specified, with some blanks to fill in, but it is clear enough for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13822": {
        "explanation": "The issue is not well-specified and lacks sufficient detail for a meaningful attempt at a solution. The problem description is brief and lacks specific information about the error being raised (fields.E305), the exact cause of the error, and the expected behavior versus the actual behavior. The issue mentions that Django raises an error during migration creation when two models with the same name refer to the same model in an M2M field. However, it doesn't clearly explain what the desired outcome should be. The description also lacks a clear minimal reproducible example or steps to reproduce the issue. While there is a reference to a test project on GitHub, it's not clear what specific changes need to be made to the test project to reproduce the issue. The issue also doesn't clearly state what the expected solution should look like. The problem appears to be related to Django's handling of related_names for ManyToManyFields, but the exact nature of the issue and the requirements for a solution are not clearly defined.",
        "label": "VAGUE"
    },
    "django__django-13837": {
        "explanation": "The issue is well-specified and provides a clear understanding of the problem and the proposed solution. It explains the current limitation in the detection of Python's -m command-line option in the get_child_arguments function of django.utils.autoreload. The issue also outlines the motivation for the change, which is to support Django-based command-line utilities with their own __main__ sub-module. The proposed fix is explained in detail, including the reasoning and the algorithm to be implemented. The issue references a PR that has been submitted, which further supports the clarity of the problem and solution. All necessary information for a meaningful attempt at a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13841": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including which modules need to be fixed and what the proposed fixes are. The issue also explains the context (frozen Python environments) and the specific issue with __file__ usage in Django modules. The 'What this ticket is not' section clearly defines the scope and what is not being proposed. The 'Proposed fixes' section gives specific examples of how to fix each module. This level of detail allows a software engineer to implement the solution without needing additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13884": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the i18n.set_language function unquoting the next_url and causing a wrong URL for parameters containing the '&' character. It also provides a Django test case that demonstrates the bug, which gives a concrete example of the expected behavior versus the actual behavior. This allows a software engineer to understand what the problem is and how to verify a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13915": {
        "explanation": "The issue is well-specified. It clearly states the objective of dropping support for Python 3.6 and 3.7. It provides context about Django 3.2 LTS and the end of life dates for the Python versions. The links to the discussions also add clarity to the reasoning behind the decision, which helps in understanding the scope and implications of the change. All necessary information is provided to implement the solution effectively.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13924": {
        "explanation": "The issue is reasonably specified. It references a specific commit (c86a3d80a25acd1887319198ca21a84c451014ad) and issue (#29721) that were previously addressing a related problem. The problem is described as migrations being marked as applied even when deferred SQL fails during SchemaEditor.__exit__. This gives enough information for a developer to investigate the code changes in the referenced commit and understand the context from issue #29721 to determine what needs to be fixed. However, without access to the full codebase and the referenced issues/commits, there are some details that would need to be filled in by a developer working on the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13925": {
        "explanation": "The issue is reasonably specified. The user explains the problem they are facing with Django 3.2 alpha where models.W042 warning is raised for inherited models even though primary keys are defined in ancestor models. The user provides detailed error messages and context about their model structure. While there are some specifics about the exact model inheritance structure and configuration that would need to be understood from the codebase, the general problem and expected solution (configuring DEFAULT_AUTO_FIELD or app config's default_auto_field) are clear. The user also provides the context that this worked in Django 3.1 but not in 3.2 alpha, suggesting a regression. This provides enough information for a software engineer to investigate and create a PR to fix the warnings.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13933": {
        "explanation": "The issue is reasonably specified. The problem is that ModelChoiceField does not include the invalid value in the error message when a validation error occurs, unlike ChoiceField and others. The solution is to modify the default error message to include the invalid value. The issue provides the relevant code snippets and the expected behavior. However, it is not explicitly stated how the error message should be modified, but it is a reasonable assumption to follow the pattern of the ModelMultipleChoiceField's 'invalid_choice' error message which includes the invalid value. Therefore, the issue is reasonably specified, but there are some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13952": {
        "explanation": "The issue is reasonably specified. The problem is that the migrate command's verbosity flag is not properly directing output to the specified stdout in the signal emission functions. The reference to a specific pull request and the explanation about testing pollution gives enough context to understand what the problem is and what the expected behavior should be. However, there might be some details about how exactly to modify the functions to direct output to the provided stdout that would need to be figured out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-13964": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with an example, provides code snippets to reproduce the issue, and explains the expected vs. actual behavior. The issue also includes detailed steps to reproduce the problem with two code examples showing the correct and incorrect cases. The problem seems to relate to how Django handles foreign key relations with non-numeric primary keys, and the explanation about the transaction.atomic() context provides additional context for understanding the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-13992": {
        "explanation": "The issue is well-specified enough to understand the problem and the expected outcome. The user provided a clear example of the code that caused an unexpected behavior, the actual SQL executed, and what they expect instead. The problem of the delete() method generating a harmful SQL when used with distinct() is clear, and the potential solutions (raising an error or fixing the SQL generation) are also mentioned. A software engineer with knowledge of Django's ORM would be able to work on this issue based on the provided information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14007": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the issue, a code example demonstrating the field and model setup, and specific test cases showing the discrepancy in behavior between normal queries and inserts. The reporter explains that database converters are not being called for returning fields on insert operations, which leads to plain integers instead of the expected wrapper class. The example shows what is currently happening versus what is expected. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14011": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the error message and the context in which it occurs. The reporter has already done some investigation, including identifying the change that introduced the issue and a workaround. This provides a clear direction for debugging and fixing the problem.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14014": {
        "explanation": "The issue is reasonably specified. It indicates that when introspecting a database schema for SQLite, the column order for unique constraints is not being returned. While the issue lacks some details, such as what specific code or method is being used for introspection, and what the expected output should be, the general problem is clear enough to guide a solution. A software engineer could reasonably infer that the task is to modify the introspection code for SQLite to correctly capture and return the column order information for unique constraints. This would likely involve modifying the database schema introspection logic to parse and store the column order for unique constraints, similar to how it might be done for other database types. The problem is well-defined enough to make a meaningful attempt at a solution, even if some additional research or experimentation within the codebase might be required to fully understand the implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14016": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem, including the error message, the code that triggers it, and the expected outcome. However, there are some nuances to consider, such as how Django's Q objects should handle non-pickleable types and whether the proposed solution aligns with Django's design principles. The user has also indicated a willingness to work on a patch, but there is a need for agreement on the desired behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14017": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with a minimal example that demonstrates the issue. The user explains that the & operator is not commutative for Q and Exists objects and provides the error traceback. The issue is to fix this inconsistency by implementing the missing __rand__ method somewhere in the codebase. The description includes the expected behavior (the operators should be commutative) and the actual behavior (TypeError is raised when Q() is on the left side of the operator).",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14019": {
        "explanation": "The issue is reasonably specified. The goal is to make the __repr__ methods of Index, UniqueConstraint, ExclusionConstraint, and CheckConstraint consistent. While the current formatting is described as \"slightly different\", the exact desired format is not specified. However, a reasonable approach would be to inspect the current implementations of these __repr__ methods and adjust them to match a common format, perhaps by adopting the format of one of the existing implementations as a standard. The task is clear enough to proceed with an implementation that aligns these representations without further clarification.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14030": {
        "explanation": "The issue is well-specified and provides a clear understanding of the problem. It explains that the never_cache decorator is being used on instance methods in Django's admin login and logout views, which requires using method_decorator instead. The issue describes the current behavior, the expected fix, and the implications of not using method_decorator for other decorators that rely on the request object. The context from a related Django ticket is also provided for reference. This allows for a direct and meaningful solution attempt without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14034": {
        "explanation": "The issue is well-specified with a clear problem description, a minimal reproducible example, and an explanation of the expected versus actual behavior. The problem involves the MultiValueField in Django not correctly handling required sub-fields when all fields are empty. The example shows the current behavior and the expected outcome, making it easy to understand what needs to be fixed. There's enough information to reproduce the issue and determine the correct solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14043": {
        "explanation": "The issue is reasonably specified. It clearly states the problem (password leakage in dbshell commands) and proposes a solution involving a temporary password file for PostgreSQL. However, some details are missing, such as exact implementation specifics and how to extend it to other backends. Despite these gaps, the core idea is clear, and a sensible solution can be interpreted and implemented based on the provided information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14053": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem with the HashedFilesMixin's post_process() method yielding multiple times for the same file. The issue explains the negative consequences (incorrect stats, duplicate work, inconsistency in yielded files) and provides concrete examples of the issue occurring. It also references related issues and the PR where the issue was mentioned. The reporter has a clear understanding of what the desired behavior should be. This level of detail allows a developer to understand the problem and implement a solution to fix the duplicate yields in post_process().",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14071": {
        "explanation": "The issue is well-specified. It explains the problem with admin.E002 not catching .attname mis-references in raw_id_fields, provides a concrete example, and even suggests a specific fix involving checking field.name == field_name and returning a specific error message. There is clear understanding of what the current problem is and what the desired fix should accomplish.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14077": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with a model definition, the data being stored, the query being executed, and the difference in behavior between PostgreSQL and SQLite. The expected behavior (returning booleans) and the actual behavior (returning integers) are clearly stated. The versions of Python, SQLite, and Django are also provided which helps in reproducing the issue. All the necessary information for a meaningful attempt at a solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14089": {
        "explanation": "The issue is well-specified. It clearly states the goal of allowing the OrderedSet to be passed to Python's reversed() function by adding a __reversed__() method. The problem is clearly defined, and the solution approach is suggested, making it possible to implement a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14122": {
        "explanation": "The issue is reasonably specified. It indicates that Meta.ordering fields should not be included in the GROUP BY clause, and it references a previous commit that partially addressed the issue but did not fully resolve it. The issue also references a PR with a test case, which provides additional context and guidance. However, some details about the specific code changes needed may still need to be inferred based on the context provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14140": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the error message, the cause, and a proposed solution (with a link to a patch). The issue explains the current behavior of the Q object deconstruction, the problem with it, and the desired change. All of this information is sufficient to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14151": {
        "explanation": "The issue is well-specified because it clearly states the problem: Django's CsrfViewMiddleware does not handle the case where the HTTP referer header cannot be parsed (e.g., due to a malformed URL). It references the exact line of code in the Django source where the issue occurs and provides an example URL that triggers the ValueError. This information is sufficient to understand the problem and begin working on a solution that addresses the error handling for invalid referer headers.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14155": {
        "explanation": "The issue is reasonably specified. It describes a problem with the __repr__ method of ResolverMatch when handling functools.partial objects. The problem is that it's not showing helpful information about the underlying function and arguments. The issue also provides a suggested approach (unwrap functools.partial objects in ResolverMatch.__init__). While some implementation details are left to the developer, the problem and a general solution direction are clear. The developer would need to implement the logic to unwrap partial objects and include their information in the __repr__ method.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14164": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a code example showing the current behavior and the expected behavior. The example demonstrates that the 'to_locale' function is not idempotent, which is the core of the issue. The reporter also explains the impact of this issue (breaking functionality with locale codes like pt_BR or zh_Hans) and suggests possible solutions (documentation change or making the function handle both inputs). This provides enough information for a developer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14170": {
        "explanation": "The issue is well-specified. It clearly explains the problem with the query optimization in YearLookup for the \"__iso_year\" lookup. It provides code examples that demonstrate the incorrect behavior, including what is expected vs what is actually happening. The issue also describes the root cause (the optimization using BETWEEN instead of EXTRACT for the \"__iso_year\" lookup) and even provides a reference to a PR that is intended to fix the problem. All the necessary information to understand and solve the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14182": {
        "explanation": "The issue is well-specified and clear. It explains that Django's Round function currently only supports rounding to the nearest integer, but the underlying databases (Postgres, Sqlite, MySQL, Oracle) support a second argument for precision. The issue provides evidence and links to documentation for each database, and explains that adding support for the precision argument would be a useful feature. The desired outcome is to modify the Round function to accept a precision argument, similar to how it's done in the workaround provided by the user. This is a clear and actionable feature request with sufficient context and justification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14199": {
        "explanation": "The issue is reasonably specified. The problem is described with a clear example of the code that causes the issue, and the specific error is that Django passes a string to the 'create_decimal_from_float' function when annotating with a decimal field. While more details on the expected behavior or the exact error message could be helpful, the provided example gives enough information to understand the problem and start working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14238": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the error message and a code example that reproduces the issue. It also suggests a potential solution (modifying AutoFieldMeta.__subclasscheck__ to allow subclasses of those classes in the _subclasses property). This is sufficient for a developer to understand the problem and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14266": {
        "explanation": "The issue is reasonably specified. The problem is described as a crash in CookieStorage for contrib.messages after upgrading to Django 3.2. The error is an Invalid base64-encoded string issue. The traceback shows where the error occurs. The user also provided the contents of the messages cookie. While the issue is clear, some context might be missing about how the messages are being stored and retrieved in the application, but a sensible interpretation of the problem is possible. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14267": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the error message, the cause, and a proposed solution (with a link to a patch). The issue explains the current behavior of the Q object deconstruction, the problem with it, and the desired change. All of this information is sufficient to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14271": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue describes a problem with combining two querysets in a subquery in Django 3.2, which results in an error due to a missing column 'V0.user_id'. The problem is clearly outlined with sample code, the expected behavior in Django 3.1.8, the actual error in Django 3.2, and the traceback. The sample project and the specific versions of Django being used are also provided, which would be useful for reproducing and debugging the issue. The solution would involve fixing the query generation in Django to correctly handle the combination of querysets in a subquery. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14311": {
        "explanation": "The issue is reasonably specified. It describes a problem with autoreloading when using the -m option with a dotted module name in Django. It references a previous fix and explains the current issue: when using a dotted name like -m foo.bar.baz, the resulting arguments become -m foo.bar, which is incorrect. This gives enough information to understand the problem and start working on a solution. However, without access to the codebase and the referenced commit, there might be some details that need to be figured out during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14313": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including a minimal reproduction scenario, the exact error message, and the conditions under which the error occurs. The issue mentions that using a specific Django version (3.1.8) resolves the error, and it provides a hypothesis about why the error occurs (the use of .distinct() due to the search involving a many-to-many field). This information would allow a software engineer to understand the problem and work on a solution that addresses the issue in the current version of the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14315": {
        "explanation": "The issue is reasonably specified. The problem is described as the database client's runshell function not respecting os.environ values in some cases, specifically when the environment variable is an empty string. The description points to a specific commit where the bug was introduced and a specific pull request that addresses the issue. The problem is related to passing environment variables to a subprocess, where empty strings are being treated differently than None. This provides enough information for a software engineer to understand the issue and work on a solution, but some details about the expected behavior and specific test cases may still need to be determined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14324": {
        "explanation": "The issue is well-specified. It clearly describes the problem (migration autodetector changes related_name for self-referential ManyToManyField), provides a code example, explains the expected vs actual behavior, and references a commit and related issue. A developer would have enough information to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14334": {
        "explanation": "The issue is reasonably specified. The problem is described as the LocaleMiddleware not recognizing 'zh-Hant-HK' from the accept-language header when both 'zh-hans' and 'zh-hant' are in settings.LANGUAGES, with 'zh-hans' being chosen first. The user also points to the potential faulty code in 'django.utils.translation.trans_real.get_supported_language_variant'. This gives enough information to understand the problem and start investigating. However, there might be some details missing such as the exact versions of Django being used, specific configurations, or test cases to reproduce the issue. Despite these potential missing details, there is a clear understanding of the issue and what needs to be addressed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14336": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with specific examples and code references, and the proposed solution is mentioned as being trivial to implement. The issue is related to case sensitivity in subquery aliases in Django, which could cause errors on case-sensitive databases. The reporter provides a concrete example of a generated SQL query that would fail on such databases, and points out the specific lines of code where the inconsistency in case usage occurs. With this information, an experienced developer would be able to understand the problem, locate the relevant code, and implement a fix that ensures consistent case usage for subquery aliases.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14349": {
        "explanation": "The issue is reasonably specified because it describes the problem (test failures on specific Python versions), provides examples of the failing tests, and suggests potential solutions. However, there are some blanks to fill in regarding the exact implementation of the fix, as there are multiple possible approaches mentioned. The ambiguity lies in choosing between the suggested solutions without explicit guidance.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14351": {
        "explanation": "The issue is reasonably specified. The user describes a problem with Django's Q objects when using OR, leading to a ProgrammingError due to a subquery returning multiple columns. They provided a comparison between working and non-working code, the error message, and examples of the SQL generated. They also included some internal Django code and debug information about Q objects and generated columns. While there are some details that need to be inferred about the exact fix (like how to modify the Django code to only return one column in the subquery), the issue is clear enough to understand what needs to be fixed. A developer would need to look at the Django code related to Q objects and query generation to implement a proper fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14368": {
        "explanation": "The issue is well-specified as it provides clear examples of the problem, explains the current behavior versus expected behavior, and suggests a solution approach. It also references specific code files and lines, making it actionable for a developer. The mention of the ISO-8601 standard and the comparison with python-dateutil adds context and justification for the requested change.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14372": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description provides a clear explanation of the problem, including the error being raised (SuspiciousFileOperation), the cause (a change in Django 3.2.1 related to CVE-2021-31542), and the specific location where the issue occurs (FileField.pre_save). The issue provides steps to reproduce the problem and references a PR that was created to fix it. All necessary information is provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14373": {
        "explanation": "The issue is well-specified because it clearly states the problem (DateFormat.Y() is not zero-padded for years < 1000), provides context (Y specifier is supposed to return a four-digit year padded with zeros), and identifies the specific component (django.utils.dateformat.DateFormat). The issue is clear what the expected behavior is (four-digit zero-padded year) versus the actual behavior (not zero-padded for years < 1000). This provides all the necessary information for a software engineer to locate the code in question and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14376": {
        "explanation": "The issue is well-specified because it clearly states the problem (usage of deprecated parameters in Django's MySQL backend), provides the exact location of the code in the Django repository, references the relevant commits in the mysqlclient repository to show the deprecation and the introduction of new parameters, and explains the compatibility between Django versions and mysqlclient versions. This allows a software engineer to directly address the issue by modifying the code to use the new parameter names and ensuring the fix is backported to the appropriate Django versions. There is no ambiguity in the problem description or the required solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14382": {
        "explanation": "The issue is well-specified because it describes the problem, provides the error message, explains the cause, and even suggests a solution. It clearly states what the problem is (trailing slash causing error), where it occurs (line 77 of django/core/management/templates.py), and how to fix it (use target.rstrip(os.sep)). This information allows a developer to directly address the issue with confidence.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14387": {
        "explanation": "The issue is well-specified because it clearly describes the problem with incorrect SQL generation when filtering OR-combined queries in Django. It provides a detailed model definition, a function that creates the query, and specific examples demonstrating the incorrect behavior. The issue also includes expected vs actual results and the generated SQL queries, making it clear what the problem is and how to reproduce it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14395": {
        "explanation": "The issue is reasonably specified. The problem is that the 'all' method in the CacheHandler class now initializes all caches, causing performance issues. The reporter provides background on a commit that changed the method and explains the before/after behavior. They also provide a snippet that attempts to fix the issue by modifying the 'all' and '__getitem__' methods to avoid unnecessary cache initialization. However, some details are missing, such as the exact expected behavior and potential side effects of the proposed solution. Despite this, the issue is clear enough to attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14396": {
        "explanation": "The issue is reasonably specified. The main task is clear: change the default protocol for Sitemap to https. However, there are some details that need to be filled in, such as the deprecation timeline for the old behavior and how to handle backwards compatibility. These are common considerations when making changes to default behavior in a framework like Django, and there's a sensible way to approach them. The issue is not vague, but there are implementation details to work out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14399": {
        "explanation": "The issue is about improving Django documentation to include information on serving static files when using Hypercorn as the ASGI server. The problem is clearly described with the common workflow and pain points. The suggestion of using Whitenoise is provided, and the motivation for including this in the Django documentation is explained. The issue also references related discussions and workarounds (like using nginx). While the specific implementation details are not given, the general direction is clear enough for a meaningful solution attempt. The main task would involve researching how to integrate Whitenoise with Hypercorn and updating the Django documentation accordingly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14404": {
        "explanation": "The issue is reasonably specified.  It explains that the `catch_all_view()` function is not handling the `FORCE_SCRIPT_NAME` setting correctly.  It describes the problem: `catch_all_view()` is redirecting to `request.path_info` (which excludes the script name), but it should be using `request.path` (which includes the script name).  It also provides a reference to a pull request that attempts to fix the issue.  While the explanation is somewhat concise, a developer with experience in Django and the request object's attributes would be able to understand the problem and implement a fix.  There is some room for interpretation regarding the exact expected behavior, but the general direction is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14411": {
        "explanation": "The issue is well-specified. It clearly describes the problem (the 'for' attribute in the label element points to a non-labelable element) and explains why it's a problem (the widget renders text, not an input, so there's no labelable element). The expected solution is also clear - the 'for' attribute should be removed from the label element. This provides enough information for a software engineer to locate the code responsible for generating this label and make the necessary change.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14416": {
        "explanation": "The issue is well-specified. It describes the problem (incorrect language being displayed due to caching), explains the sequence of events causing the issue, and even suggests a potential solution (adding a Vary header). The problem is clearly explained with specific technical details about the middleware, caching behavior, and the headers involved. A developer would understand exactly what needs to be fixed and how to approach it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14430": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with examples showing the current behavior and the expected behavior. It also includes a suggested solution approach and specific code locations where the change should be made. This allows a software engineer to understand the problem and implement a fix without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14434": {
        "explanation": "The issue is reasonably specified. The problem is that a Table instance is being passed to Columns where a string is expected, which is causing the references_column to be always false. A solution would involve changing the code to pass a string instead of a Table instance. However, there may be some details about the specific code implementation that are not clear from the issue description alone.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14441": {
        "explanation": "The issue is reasonably specified. It clearly states that the get_image_dimensions() function crashes when a nonexistent file or path is passed. However, there are some blanks to fill in, such as how to handle the error (e.g., return an error message, raise an exception with a specific message, or handle it silently). There is also no information on what the expected return type or behavior should be in such a case. Despite these gaps, there is a sensible interpretation that the function should handle the error gracefully, possibly by raising a more informative exception or returning None/False to indicate failure.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14447": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific queries that are causing performance issues and the exact lines of code in the Django repository where the issues occur. The proposed solutions are also outlined, such as passing the count to the _cull method to avoid the second query and implementing a frequency-based culling approach. The issue also discusses the possibility of adding a new setting for the culling frequency. All of these details provide a clear roadmap for implementing the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14451": {
        "explanation": "The issue is well-specified because it explains the problem (lack of self-closing tags in Django's syndication feeds), provides context (Python 3.2 added this functionality), and describes a specific solution (passing an argument to SimplerXMLGenerator). The proposed fix is even provided in a PR link. All necessary information to implement the solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14453": {
        "explanation": "The issue is well-specified. It describes the problem (a typo in 'urlpatterns' leading to a confusing error message), provides the error message, explains that the issue is not related to circular imports but the typo, and mentions that a pull request has been created. All necessary information is provided to understand and resolve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14463": {
        "explanation": "The issue is reasonably specified. It explains the need to add the ability to define comments in tables and columns within Django models. The proposal provides a concrete example of how the new feature should work, with attributes like db_column_comment and db_table_comment in the model and Meta class. While there are some blanks about the exact implementation details and database compatibility, there is a clear direction and a sensible interpretation of what needs to be done. The example code gives a good starting point for implementing the feature.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14471": {
        "explanation": "The issue is well-specified. It explains the problem with unnecessary work when the CSRF cookie has the wrong format, provides a proposed solution involving changes to the _get_token() function and handling the InvalidTokenFormat exception differently in two specific locations, and references a similar issue (#32795) for context. The steps for implementation are outlined, making it clear what the expected outcome is.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14480": {
        "explanation": "The issue is reasonably specified. The request is to add logical XOR support to Q() and Queryset() in Django. The issue provides context about which databases support XOR (PostgreSQL, MySQL, SequelServer, Oracle) and notes that SQLite does not. The issue also references two StackOverflow questions for more context, including an answer that proposes an implementation approach. However, there are some missing details, such as the exact behavior expected for XOR in the context of Q objects and Querysets, and how to handle the lack of XOR support in SQLite. The contributor will need to interpret these details during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14493": {
        "explanation": "The issue is well-specified. The problem is described with a clear reproduction path, including code examples and a traceback of the error. The root cause is identified as an 'UnboundLocalError' due to referencing a variable before assignment. The error location is provided with a GitHub link. The context of why this setting is being used is also explained. All necessary information to understand and resolve the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14495": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a detailed explanation of the error and steps to reproduce it. The user provided a specific error message, the context in which it occurs, and potential expected behavior. This allows for a clear understanding of the issue and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14500": {
        "explanation": "The issue is somewhat clear, but there are some details that are not explicitly provided. The main problem is that when unapplying a squashed migration and the replaced migration files are still present, the MigrationExecutor should mark the squashed migration as unapplied, but it seems to be not doing so. However, there is some ambiguity in the exact expected behavior. For example, it's not explicitly clear if the squashed migration should be marked as unapplied in addition to the replaced migrations or if it should be marked as unapplied instead of the replaced migrations. There are also some technical details about how the MigrationExecutor works that are not provided, which might be important for implementing the fix. Despite these ambiguities, there is a reasonable interpretation of what is required for a successful solution, so this issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14508": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. It describes a problem where a property in a base model conflicts with a field in a child model, but it's not clear what the desired solution is. The user is suggesting a warning should be added during model initialization to better identify this type of conflict, but the implementation details of how to detect and handle these conflicts are not provided. The scope of the solution (what exactly needs to be implemented) is not clearly defined. This issue has elements of being reasonably specified as there's a clear problem and a general direction for a solution, but lacks specific implementation details needed for a meaningful attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14513": {
        "explanation": "The issue is reasonably specified. It explains the problem with the current behavior of showmigrations in Django when dealing with squashed migrations. It describes the disconnect between the output and the actual state of the migrations. However, it does not provide specific details about the desired output format or implementation approach. A developer would need to interpret what a 'soft applied' indicator should look like and how to implement it. The reference to related issue #24900 also adds some context but doesn't provide specific implementation details. The issue provides enough context to understand the problem and the goal, but leaves some implementation details to be filled in by the developer.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14534": {
        "explanation": "The issue is well-specified and provides a clear explanation of the problem, including code snippets that show the current implementation and the proposed fix. It explains how the current implementation of 'BoundWidget.id_for_label' ignores the 'id' set by 'ChoiceWidget.options', and it provides a specific solution for the problem. The issue also explains when the problem occurs (when rendering the subwidgets of a widget of type 'CheckboxSelectMultiple').",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14539": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a specific example showing the expected and actual outputs. It's clear that the urlize() function is not correctly handling HTML-escaped characters and trailing punctuation when generating links. A developer could look at the urlize() implementation and determine how to fix the handling of escaped characters like &lt; and ensure that the trailing punctuation is correctly associated with the link rather than being appended to it. The example provides enough detail to understand what the desired behavior is and how to test if the fix is working correctly.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14559": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described as the bulk_update() function returning None, unlike update() which returns the number of rows matched. The issue also provides a reference to the source code and suggests that the same functionality could be added by summing the return values of the repeated calls to update(). Therefore, it is clear what the expected change is and how to implement it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14580": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce, and expected vs actual behavior. It includes code examples that demonstrate the issue, and identifies where the problem is likely occurring. This provides enough information to attempt a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14584": {
        "explanation": "The issue is asking for the logging output from django.db.backends to include the database alias, which is described as essential for database routing. The request is clear and specific - the database alias should be added to the logging output. While the exact implementation details are not provided, the goal is well-understood, and an experienced developer would know how to modify the logging to include this information. The reference to a specific PR also provides a context and a precedent for the type of change that is expected.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14602": {
        "explanation": "The issue is reasonably specified. The problem is clearly described as needing to tighten up a regular expression to accept fewer 'invalid' options. There is an example provided showing the current behavior where '0:5: ' is parsed as a valid time. The issue references a specific regex pattern and suggests deriving examples of current valid strings to determine if any of them should not be accepted. While there are some details that need to be filled in (such as specific examples of what should be considered invalid and how to modify the regex), the general direction is clear. The goal is to make the regex more restrictive while ensuring that the resulting parsed time is still correct for the input portions that are provided. The mention of being liberal in what you accept provides a guideline for the approach. Therefore, the issue is reasonably specified with some blanks to fill in about the exact changes to the regex and the specific examples to consider.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14608": {
        "explanation": "The issue is well-specified. It clearly explains that the `nonform` CSS class should be added for non-form errors in FormSets, similar to how the `nonfield` class is used for non-field errors in forms. The purpose of the class is described, and the expected outcome is clear. The issue also suggests adding documentation for developers to use this class. A software engineer would understand exactly what code needs to be changed and what the goal is.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14631": {
        "explanation": "The issue is well-specified enough to understand the desired changes. It describes the problem (inconsistent code and potential discrepancies in values), suggests specific changes (accessing values through BoundField objects), and even provides a proposed code example for the changed_data method. The solution would involve modifying BaseForm._clean_fields() and BaseForm.changed_data to use BoundField access and potentially refactoring some logic into the BoundField class. There's enough detail to make a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14634": {
        "explanation": "The issue is reasonably specified. The main goal is clear: to add a mixin that shows a success message when an object is deleted. However, there are some details that need to be filled in, such as how the mixin should be structured, where the message should be displayed, and how the deletion success is determined. Despite these missing details, a software engineer could reasonably interpret the requirements and implement a solution based on common practices in the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14641": {
        "explanation": "The issue is well-specified. It describes the current state (special-case logic in BoundField.initial() for time and datetime objects), the desired change (moving this logic to BaseForm.get_initial_for_field() under the if callable(value) block), and provides code references for both locations. The explanation also includes context about potential future improvements, but the core task is clearly defined. A developer with knowledge of the Django codebase would understand what needs to be done to resolve the issue based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14667": {
        "explanation": "The issue is well-specified. The problem is described with a clear example of the current behavior versus the expected behavior. The user explains the issue with concrete code examples and shows what the actual SQL query is versus what is expected. This allows a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14672": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue describes a bug in Django's ManyToManyRel class where a call to make_hashable is missing on through_fields. The issue includes a detailed description of the problem, the context (version 3.2 changes), and provides a minimal reproducible example that demonstrates the error. The error message and stack trace are also included, showing a TypeError related to an unhashable list. The issue ends with a clear solution suggestion: adding the missing make_hashable call on self.through_fields in ManyToManyRel. All the necessary information to understand the problem and implement the solution is provided without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14681": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce, and expected behavior. The reporter has provided a minimal reproduction app, detailed setup instructions, and outlined specific scenarios for testing. All necessary information is given to understand the CSRF failure during uploads when there are storage issues, making it possible to work on a solution effectively.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14725": {
        "explanation": "The issue is reasonably specified. It describes the problem (model formsets allow new object creation even when extra=0), explains why this is a problem (users can add more forms via JavaScript or POST data), and suggests the desired outcome (provide a way to create an 'edit only' view). However, it does not specify exactly how to implement this feature or what the API should look like. A developer would need to make some reasonable assumptions about how to implement this functionality.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14730": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem (developers may be confused when using related_name with symmetrical ManyToManyFields), and provides a proposed solution (raise an error when this condition occurs). The issue provides enough technical context to understand what the current behavior is and what the desired change is. A software engineer would be able to implement this change by modifying the ManyToManyField code to check for the symmetrical condition and raise an appropriate error when a related_name is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14733": {
        "explanation": "The issue is reasonably specified. The request is to introduce a deletion_widget and get_deletion_widget() in Django, similar to the ordering_widget and get_ordering_widget() that were introduced in Django 3.0. The purpose is to allow overriding of the deletion widget in formsets, which aligns with the existing pattern for ordering widgets. While some implementation details would need to be filled in, the overall goal and context are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14751": {
        "explanation": "The issue is reasonably specified. The problem is described with examples and a specific use case. The desired outcome is clear (makemigrations should output created file paths to stdout), but some implementation details or edge cases might need to be considered.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14752": {
        "explanation": "The issue is well-specified and provides a clear description of the problem and the proposed solution. It explains the current limitation in the AutocompleteJsonView where adding new attributes requires overriding the get() method, which is maintenance-heavy. The issue also provides a specific and detailed solution: introducing a serialize_result() method to handle the object-to-dictionary conversion, making it easy to override and maintain. The example of how the CustomAutocompleteJsonView would look after the change is also provided, making it clear what the expected outcome is. This level of detail allows a developer to understand the problem and implement the solution effectively without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14765": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue states that the ProjectState.__init__() method can now assume that the real_apps argument is passed as a set, due to a previous PR (PR #14760). This means that the method no longer needs to check or convert the real_apps argument to a set, and instead can assert that it is a set when it's not None. The issue provides clear instructions for the change: remove the check for converting real_apps to a set and instead add an assertion that real_apps is a set when it's not None. This is a specific and actionable task that can be implemented without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14771": {
        "explanation": "The issue is not clearly stated, and it's unclear what the exact problem is. The provided commands and code snippets show a scenario where the -X option is being used with Python, and there's a difference in behavior between reloader and non-reloader modes. However, the issue description lacks a clear statement of what is wrong and what needs to be fixed. It appears that the auto-reloader is not passing the -X options correctly, but this is not explicitly stated. Without a clear problem statement and expected outcome, it's difficult to determine what needs to be changed in the codebase to resolve the issue. Therefore, the issue is vague.",
        "label": "VAGUE"
    },
    "django__django-14779": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the scenario where a custom tag with takes_context=True is missing the context parameter and no other parameters are present. The issue explains how the current code throws an IndexError instead of a TemplateSyntaxError. It also provides a code example of the incorrect usage and the traceback showing where the error occurs. With this information, a developer can understand what the problem is and how to fix it in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14785": {
        "explanation": "The issue is well-specified. It clearly describes the problem (NaN values stored in DecimalField cannot be retrieved), provides steps to reproduce the issue, and shows the error traceback. The reporter explains what is happening and the impact of the issue (breaking the admin changelist view). The problem is clearly defined and it would be possible to create a PR to fix this issue without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14787": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the error message and a code snippet that reproduces the issue. The expected behavior is also explained - that method_decorator should preserve the necessary function attributes like __name__ and __module__. The problem occurs when using functools.partial objects which lack these attributes. The issue has a clear goal of making sure the decorator preserves these wrapper assignments so the provided code example would work without raising an AttributeError.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14792": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It describes the problem in detail, including the difference in behavior between Django 3.1 and Django 3.2. It explains how the time zone conversion is handled differently and provides examples of the incorrect and correct SQL queries. The issue also includes Python code examples showing the change in the return value of the _get_timezone_name function. This information is sufficient for an experienced developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14802": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description provides a clear proposal for a new helper function, 'make_and_validate_key', including the code for this function. The issue explains the motivation for the change (reducing repetitive code and ensuring validation) and the alternative approaches considered. A developer with access to the codebase would be able to implement this change with the provided code snippet and understanding of where to place it in the base cache backend. The issue is clear in what is being asked for and how to implement it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14832": {
        "explanation": "The issue is well-specified. It provides a clear problem statement, references specific code locations, and explains the root cause of the issue. The issue describes the current behavior of the floatformat filter being dependent on USE_L10N and not respecting the localization setting within a {% localize %} block. It also mentions that the problem is due to the use of formats.number_format() without the use_l10n parameter. The issue even acknowledges a potential challenge in implementing a solution, as filters do not have access to context. A successful solution would involve making the floatformat filter independent of USE_L10N and allowing forced unlocalized format, which is clearly defined in the problem statement.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14855": {
        "explanation": "The issue is well-specified because it describes the problem in detail, provides the context of a custom Admin Site, and explains the discrepancy in URL generation. It identifies the specific line in the code where the issue occurs and offers a proposed fix by adding the current_app parameter. The issue also shows an understanding of how other parts of the admin handle Admin Site names and acknowledges the need for further testing. This level of detail provides a clear path for implementing and testing the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14861": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description includes a minimal example with models.py and admin.py code, and clearly explains the problem that occurs when toggling the show_inlines field. The issue provides a detailed description of the error that is encountered and the specific scenario in which it occurs. A software engineer would be able to reproduce the issue with the provided code and understand what the expected behavior should be based on the explanation.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14871": {
        "explanation": "The issue is reasonably specified. The problem is described with an example (pt-BR), and the cause is mentioned (lowercase conversion in the code). While the exact implementation details may require exploration of the codebase, the general problem and context are clear enough to start working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14880": {
        "explanation": "The issue is reasonably specified. The problem is clearly described - the error messages for reverse accessor clashes in RelatedField._check_clashes() do not mention the clashing name, making debugging difficult. The issue references a specific PR (django/django#14880) that attempted to address this but caused test failures. While there are some details to work out (like exactly how to modify the error messages and fix the unit tests), the core problem and goal are clear enough to begin working on a solution. The issue provides sufficient context to understand what needs to be improved and why it's important.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14894": {
        "explanation": "The issue is well-specified. The reporter provided a clear problem description, including models, test data, queries, and expected vs. actual outputs. They explained the unexpected behavior when using an empty list in a queryset for subqueries and annotations. The code example is minimal and reproducible, and the issue is clearly defined with the console outputs showing the discrepancy. There is a clear understanding of what is expected versus what is happening. The background story also helps to understand the context and the impact of the issue. Therefore, it is clear what needs to be fixed and how to verify the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14915": {
        "explanation": "The issue is reasonably specified as it provides the error message, a code example that breaks, and a working example for comparison. It also includes context about the Django version change and the specific error encountered. There is a clear problem (TypeError due to unhashable type) and the relevant code is shown, so a solution can be attempted. However, there might be some missing context about the exact setup and the environment that could affect the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14919": {
        "explanation": "The issue is reasonably well-specified but has some areas that require interpretation. The problem is clearly described - there's a discrepancy in error handling between TransactionTestCase and TestCase for durable atomic blocks. The reporter provides context about why this is an issue (errors not surfacing until staging/production). They suggest a solution approach (adding a marker to transactions, using a transaction stack for checking durability). However, there are some implementation details that would need to be worked out, and the proposed solution would require understanding of the existing codebase and how transactions are currently handled in TestCase. The patch link provides additional guidance but would require examining the actual code changes. This is not perfectly clear without looking at the code, but there's enough information to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14935": {
        "explanation": "The issue is reasonably specified. The user is explaining a problem where a callable default for a unique field in a Django model is only called once during migration, leading to the same value being used for all instances. They provided a code example of their model and the generated migration. The request is to add a warning when makemigrations detects this situation. While there are some implementation details that would need to be worked out (such as how to detect if a default is a callable and how to determine if it's intended to generate unique values), the overall goal is clear. The user is asking for a warning to be added during the makemigrations process when unique fields have callable defaults that may not be unique across all instances. This is a reasonable feature request that can be implemented with some effort.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14960": {
        "explanation": "The issue is reasonably specified. The problem is explained, including where the validation is currently performed and what the consequence of the missing validation is. However, it lacks some details about the exact scenario and the expected behavior. For example, it would be helpful to know which specific field is having this issue and what the exact expected validation behavior should be. Despite these gaps, there is a clear understanding of what needs to be fixed - ensuring that command-line passed values in interactive mode are validated properly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-14996": {
        "explanation": "The issue is well-specified. It describes a problem where renaming a field and setting the prior field name as db_column results in unnecessary SQL operations. It includes a test case with code examples, expected behavior, and actual behavior. The issue also references a similar problem (issue #31826) for context. The problem is clear and a solution can be developed based on the provided information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14997": {
        "explanation": "The issue is well-specified. It provides a complete model definition, migration steps, and the exact error message. The problem is clear: applying the migrations with a UniqueConstraint on an SQLite database causes an error related to the '.' operator being prohibited in index expressions. The steps to reproduce are included, and the expected vs. actual behavior is outlined. All the necessary information is present to reproduce and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-14999": {
        "explanation": "The issue is reasonably specified. It describes the problem that a RenameModel operation with a defined db_table should be a no-op (no operation). It also provides context on the current behavior in Postgres and SQLite. However, some details are missing, such as the expected behavior for other databases or the exact conditions under which the RenameModel should be considered a no-op. These can be inferred or clarified during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15018": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the code that is causing the issue, the expected behavior, and the actual behavior. The user is asking for a solution to make the 'call_command()' function work with the given code structure, and the specific failure cases are described. All necessary information to understand the problem and develop a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15022": {
        "explanation": "The issue is reasonably specified. The problem is described with the models, admin options, and the performance issue when searching with multiple words. The cause is explained as unnecessary joins from the 'qs = qs.filter(...)' pattern. However, there are some blanks, such as the exact nature of the attached patch (which is not provided) and the specific changes needed in the current SVN trunk. Despite these missing details, there is a clear understanding of the performance issue and the general approach to fix it.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15031": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: the Django admin's filtering functionality using field lookups (like 'in') doesn't work properly when a value contains a comma. The issue provides a specific example of how the filtering works normally (e.g., ?username__in=johnny,viola,gordon) and explains the limitation (can't include values with commas). The issue also identifies the relevant function (prepare_lookup_value in contrib.admin.util) where the string splitting occurs. While the exact implementation details of how to fix the splitting functionality aren't provided, the problem is clear enough that a developer could investigate the code and implement a solution that properly handles values containing commas. There are some implementation details to work out, but the core problem is well-defined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15037": {
        "explanation": "The issue is reasonably specified. The problem is that the inspectdb command in Django is not correctly handling foreign keys that reference a specific field in another table. It is clear that the other_id field in the bar table should be a foreign key to the other_id field in the foo table, but the generated model is not reflecting this correctly. While there is a potential fix attached, there might be some blanks to fill in regarding the exact implementation details and unit tests, but there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15038": {
        "explanation": "The issue is well-specified. It clearly describes the problem: using --squashed-name with squashmigrations can overwrite existing migration files, leading to potential inconsistencies and circular dependencies. It also provides a specific example of the command that causes the issue and explains the consequences. The proposed solution is to have squashmigrations exit with an error instead of overwriting existing files. This gives a clear goal for the fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15044": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem is described as a lack of thread safety in two middleware classes (CacheMiddleware and FetchFromCacheMiddleware). However, the issue doesn't clearly explain what the exact thread safety problem is, how to reproduce it (beyond mentioning pylibmc and uwsgi threaded), or what the expected fix should be. While there's some context about the error encountered, it's not clear what the specific thread safety violation is or how to resolve it. The issue lacks specific requirements for a solution and doesn't provide a minimal, complete, and verifiable example that would enable a developer to reproduce the problem consistently. The problem seems to be related to Django's cache middleware and pylibmc, but the exact nature of the thread safety issue is not clearly described.",
        "label": "VAGUE"
    },
    "django__django-15061": {
        "explanation": "The issue is reasonably specified. The problem is explained with an example and the proposed solution is to remove the id_for_label method from the MultiWidget class. However, some details about the expected behavior and the impact on other parts of the codebase are not mentioned.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15062": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with specific test cases that demonstrate the issue with Case() and ExpressionWrapper() not working with DecimalField on SQLite. The expected vs actual behavior is clear, and the issue includes a link to a repository with the test cases. The issue also references a similar past issue (#18247) which could be used as a basis for a solution. All the necessary information to understand and reproduce the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15087": {
        "explanation": "The issue is reasonably specified. The problem is that the SQLite backend is currently using regex to extract foreign key constraints from DDL, but it should instead use the PRAGMA foreign_key_list method. The solution involves modifying the get_relations method to use PRAGMA instead. However, some details are missing, such as the exact code changes needed and potential edge cases.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15098": {
        "explanation": "The issue is well-specified with clear steps to reproduce, expected and actual results, and relevant code examples. The problem with i18n_patterns not handling locales with script and region is clearly explained. The reporter has already confirmed the issue can be reproduced on a fresh Django project. This provides enough information for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15102": {
        "explanation": "The issue is well-specified enough to understand the problem and what needs to be fixed. It explains that the 'startproject' command is not honoring the umask setting, leading to permission issues when trying to create files in a read-only environment like the Zero Install cache. The issue provides a concrete example of the problem and the error encountered. There is a clear understanding of what the desired outcome should be: the 'startproject' command should respect the user's umask settings when creating files, so that permission issues like the one described do not occur.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15103": {
        "explanation": "The issue is well-specified. The request is to make the 'element_id' argument of the 'json_script' function optional. The issue provides a clear use case (using json_script inside a <template> tag where an ID is not needed). It also explains why the change is reasonable (no security issues and tests still pass). This provides all necessary information for a developer to understand the problem and implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15104": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user provides a detailed description of the problem, including the error traceback, the context of the problem (a custom ForeignKey field), and a self-contained test case to reproduce the issue. They also suggest a potential fix. This level of detail allows for a clear understanding of what needs to be solved.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15108": {
        "explanation": "The issue is about making the Django ORM's Window function consistent with other parts of the ORM by allowing the use of a descending string syntax (like '-field') in its order_by method. The issue provides sufficient technical details about the current inconsistency (Window.order_by doesn't handle the '-' syntax), identifies where the logic exists in other parts of the codebase (OrderableAggMixin), and even provides a proposed implementation that would standardize the behavior. While the solution would require understanding the Django ORM's internal structure, the problem is clearly defined, and the expected outcome is clear. Therefore, it is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15111": {
        "explanation": "The issue is reasonably well-specified as it describes the problem (django-admin not sending proper user agent header), the consequence (some sites block requests), and provides a reference to an external issue (GitLab/GitLab issue 219669). However, some details may need to be filled in, such as the specific code changes required to set the 'User-Agent' header to 'Django/DJANGO_VERSION'.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15127": {
        "explanation": "The issue is somewhat clear but there are some ambiguities. It mentions that LEVEL_TAGS is not updated when using @override_settings, which causes the Message.level_tag property to return an empty string. However, it's not completely clear what exactly needs to be done to resolve this issue. The problem is identified, but the expected behavior or solution is not explicitly described. More details would be needed about how LEVEL_TAGS should be updated and what the correct behavior should be when using @override_settings. There are some blanks to fill in, but there is a sensible interpretation of what is required.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15128": {
        "explanation": "The issue is well-specified and provides a clear example of the problem, including the code to reproduce the bug, the Python and Django versions where it was observed, and an explanation of the underlying issue. The expected outcome is also defined, which includes a fix for the bug and possibly improved documentation. The detailed explanation of why the assertion error occurs and the suggestion of how to fix it makes it possible to understand what needs to be done to resolve the issue. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15135": {
        "explanation": "The issue is well-specified. The problem is described with a clear example and explanation of the expected vs actual behavior. The example includes model definitions, code that reproduces the issue, and a suggested fix approach. A developer would have enough information to investigate the bulk_update implementation and implement a solution that handles ForeignKey updates correctly by ensuring the ID is properly copied.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15139": {
        "explanation": "The issue is reasonably specified. The goal is to deprecate the PickleSerializer and move it out of the core codebase. However, there are some details that would need to be filled in by the developer, such as how exactly to deprecate it (e.g., adding deprecation warnings), which third-party package it should be moved to, and what the migration plan would look like for existing users. Despite these missing details, there is a clear direction and purpose for the change, making it possible to create a sensible solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15161": {
        "explanation": "The issue is reasonably specified. It explains that the deconstruction of F() expressions should be simplified by using a shorter import path (django.db.models.F() instead of the full path). It also mentions that this same technique should be applied to other expressions to simplify generated migration code. However, it does not explicitly list which other expressions should be modified or provide detailed implementation instructions. A developer would need to research which other expressions are used in migrations and could benefit from this simplification. Despite this gap, there's a clear direction and goal for the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15166": {
        "explanation": "The issue is reasonably specified. It explains that the DatabaseCache backend is not quoting all fields in queries, which is a problem for Snowflake because it requires all fields to be quoted. However, there are a few things not explicitly mentioned, such as how the patch should be applied or what exactly needs to be modified in the code to ensure all fields are quoted. A software engineer with experience in Django and database caching would be able to interpret what needs to be done based on this information, but there are some blanks to fill in. The mention of a patch suggests that some work has already been done, but the exact implementation details are not provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15180": {
        "explanation": "The issue is reasonably specified. It provides a clear problem description, including code examples that demonstrate the issue, error messages, and an explanation of the root cause. The reporter suggests possible solutions (type-checking in _path or system checks). While it doesn't specify exactly how to implement the solution, a experienced Django developer would understand what needs to be done: adding type validation for the kwargs parameter in the path() and re_path() functions to ensure it's a dictionary when provided. The issue is well-explained with reproduction steps and expected outcomes.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15202": {
        "explanation": "The issue is well-specified. It clearly states that the URLField's clean method is raising a ValueError instead of a ValidationError. It provides a specific example of input that causes the issue, and shows the traceback highlighting where the error is raised. The expected behavior is implied - that a ValidationError should be raised instead. The problem is clearly defined with sufficient information to reproduce and fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15213": {
        "explanation": "The issue is well-specified because it includes a clear problem description, symptoms, and examples of both working and non-working cases. The reporter explains that using ExpressionWrapper with a negated Q object (~Q(pk__in=[])) causes the query to break, and provides exact SQL outputs that illustrate the problem. This allows a developer to reproduce the issue and understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15240": {
        "explanation": "The issue is reasonably specified. The problem is clear: the django_migrations table can contain entries for migrations that no longer exist, leading to issues with new migrations having the same name. The proposed solution is to truncate the django_migrations table to include only existing migrations, either automatically or via a custom command. The pros and cons are outlined, and a note is provided about a potential new trap that must be avoided. However, there are still some blanks to fill in about the exact implementation details, such as how to detect existing migrations, how to handle the 'replaces' list, and whether to implement it automatically or via a command. There is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15248": {
        "explanation": "The issue is reasonably specified. The problem is explained (need to track the origin of a delete operation in signals), and the desired outcome is clear (signal listeners should know why an object is being deleted). However, there are implementation details that are not specified, such as the exact API changes or how the origin information should be passed to the signals. A developer would need to make some reasonable assumptions about how to implement this functionality, but the core requirement is clear enough to proceed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15252": {
        "explanation": "The issue is well-specified and provides a clear problem description, including the current behavior, expected behavior, and the specific code paths involved. The user explains their multi-db setup, the db_router implementation, and the unexpected creation of tables in non-default connections. The issue also identifies the relevant code locations and explains why the current behavior is incorrect. This level of detail allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15268": {
        "explanation": "The issue is well-specified. It clearly describes the problem of redundant operations after splitting AlterFooTogether into two types. It provides a concrete example of before and after optimization. The goal is to optimize multiple operations into one when they can be combined. The example shows exactly how the optimization should work. This provides enough information for a software engineer to implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15272": {
        "explanation": "The issue is reasonably specified. It describes the purpose of the management command (optimizemigration) and its functionality (reading a migration, passing it through the optimizer, and rewriting it to disk). However, some implementation details are not provided. For example, the exact behavior of the optimizer is not specified, and there are no details on error handling, input validation, or user feedback. Despite these missing details, a software engineer with experience in the codebase would be able to interpret what is needed and implement a working solution based on the provided description.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15277": {
        "explanation": "The issue is well-specified. It explains the current problem with Value._resolve_output_field and CharField.__init__, provides detailed analysis of the performance impact, and clearly states the proposed solution. The issue includes code examples, benchmark results, and references to existing code (BinaryField.__init__). This provides sufficient information for an experienced developer to understand the problem, evaluate the proposed solution, and implement the necessary code changes.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15278": {
        "explanation": "The issue is well-specified enough to understand the problem. It describes a specific error when adding a nullable OneToOneField in Django using SQLite, provides a clear error message, a relevant code snippet from the migration, and a link to a related issue. This information is sufficient for a developer to reproduce the issue and work on a solution. The problem is clearly defined with all the necessary details to address it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15280": {
        "explanation": "The issue is well-specified. It includes a detailed description of the problem, a minimal test case that demonstrates the issue, and an explanation of what is expected versus what is actually happening. The issue provides enough context and code to understand the problem and reproduce it. The reporter has also already done some investigation into the issue, which makes it easier to understand the root cause. The only thing missing is a confirmation that this is actually a bug and guidance on where to start looking in the codebase, but that doesn't make the issue underspecified - it just means that the reporter is asking for help with the next steps after identifying the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15292": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the technical 404 debug page is displaying an incorrect view name for class-based views (CBVs). The issue provides an example of the incorrect output and what it should be, and it even identifies the commit where the regression was introduced. This gives a clear understanding of what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15297": {
        "explanation": "The issue is well-specified because it provides a clear test case, detailed explanation of the problem, and even suggests a potential solution with a code snippet. The test case shows what the current incorrect behavior is and what the expected correct behavior should be. The explanation gives context about the change in Django (version 4.0) and references related tickets and PRs. This information is sufficient for a developer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15315": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem, including a code example that reproduces the issue. It explains what the current behavior is and why it is problematic (changing hash in a dict breaks functionality). It also references the commit that introduced the issue and provides context about how the problem was discovered. A successful solution would likely involve reverting or modifying the __hash__ implementation to ensure it is immutable as the title suggests.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15316": {
        "explanation": "The issue is vague because it does not provide sufficient details about the specific problem with non-capturing groups in the simplify_regex() function. There is no clear description of what is wrong with the handling of non-capturing groups, what the expected behavior should be, and what the actual behavior is. The issue lacks a detailed explanation of the problem, examples of regex patterns that are not working as expected, and any error messages or incorrect outputs. Without this information, it is difficult to understand the exact nature of the issue and what needs to be fixed. Additionally, there is no information on how the simplify_regex() function is supposed to handle non-capturing groups in general. The mention of Django REST Framework's Schema generator is not sufficient to infer the required behavior of the function in this context. Therefore, the issue is vague and lacks the necessary details for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "django__django-15318": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the current behavior of reverse foreign key and many-to-many (m2m) unsaved model querying, a test case showing the discrepancy, and a reference to an existing patch. The desired outcome is to unify the behavior of these two types of queries. The changes in behavior are clearly outlined, and the reasoning for considering the changes as bug fixes is provided. All of this information provides a clear roadmap for implementing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15320": {
        "explanation": "The issue is well-specified because it clearly describes the problem with the Subquery.as_sql() method generating invalid SQL by removing the first and last symbols. It provides a concrete example with code that demonstrates the issue and the workaround that fixes it. The example shows what the expected output should be and what the actual output is, making it clear what the problem is and what a correct solution should achieve. The issue also suggests a potential solution (setting query.subquery = True in the Subquery constructor). This level of detail makes it possible to understand the problem and work on a solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15324": {
        "explanation": "The issue is well-specified because it includes a detailed description of the problem, steps to reproduce the issue, and example code. The problem is clearly defined as a crash occurring when a file extension contains null characters, and the expected behavior is that it shouldn't result in a 500 error. The example code allows for a clear and reproducible test case, making it straightforward for a developer to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15334": {
        "explanation": "The issue is reasonably specified. The user is describing a problem where the prefetch_related() method is ignored when using Queryset.iterator() in Django. They mention that this behavior is documented, but they believe it is no longer valid given that the iterator now allows chunking. The request is to support the use of prefetch_related() with the iterator, particularly for each chunk. While the general direction is clear, some implementation details are not specified, such as how the prefetching should be integrated with the chunked iteration. However, a software engineer with knowledge of Django's queryset and iterator implementation could reasonably infer what is needed and work on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15352": {
        "explanation": "The issue is reasonably specified. It indicates that session IDs should be cleansed from error reporting, similar to how other credentials are handled. A reference to a Django pull request (#15352) and related tickets (#29714) provide context and a potential approach. However, the exact implementation details for applying the patch or making the necessary changes might require further investigation into the codebase. Additionally, while examples of session IDs in public bug reports are provided, the specific method for ensuring they are cleansed is not detailed. Thus, while the goal is clear, some blanks need to be filled in regarding the implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15368": {
        "explanation": "The issue is well-specified. The problem is described with a clear reproduction example, including code snippets and the expected vs. actual behavior. The user also points to the specific part of the Django source code where the issue occurs, and provides potential fixes. This gives enough information for a developer to understand the problem, locate where it happens in the codebase, and implement a solution. The issue is about handling F() expressions in bulk_update() correctly, and the proposed solutions give guidance on how to approach the fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15375": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example, including the error message and the incorrect SQL query that is being generated. The issue also provides the correct working alternative using Coalesce. It clearly shows that using the 'default' argument in aggregate() after annotate() results in a crash with an OperationalError due to incorrect SQL syntax. The expected behavior is that the aggregate with a default should work similarly to the Coalesce example, without causing a syntax error. All necessary information to reproduce and understand the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15380": {
        "explanation": "The issue is well-specified. The problem is described with a clear error message and a traceback. The steps to reproduce the error are implied (renaming a model and field in a single step), and the context (Django's migration autodetector) is provided. The issue also includes a note that it's a regression, with the commit hash that introduced the problem, which can be useful for debugging. A software engineer with access to the codebase could use this information to identify the cause of the KeyError and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15382": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue provides a clear example of the problem, including a code snippet that demonstrates the issue and the expected vs. actual behavior. It also references a similar issue (#33018) which may provide additional context. The problem is about an exists-subquery with an empty queryset removing the whole WHERE block, and a solution would involve fixing this behavior in the Django ORM. The example shows how to reproduce the issue, and the expected outcome is that the WHERE block should not be removed when using an exists-subquery with an empty queryset. The issue is specific enough to allow for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15388": {
        "explanation": "The issue is well-specified because it includes clear steps to reproduce the problem, a description of the expected behavior (the dev server should restart when files are saved), and a description of the actual behavior (the dev server does not restart). The issue also shows that the reporter has tested different scenarios to confirm the issue is not limited to a specific file. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15401": {
        "explanation": "The issue is reasonably specified. The problem is about deprecating the use of unsaved objects in related filters in Django. The reporter provides a clear example of the problem, describes the change in behavior between Django 1.11 and Django 2.0 through 2.2, and references a related issue. The reporter asks two specific questions about the intended behavior and documentation. While there is a need to interpret the exact scope of the deprecation and how to implement it, the overall goal is clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15413": {
        "explanation": "The issue is well-specified with a detailed description of the problem, including references to the relevant documentation, test code, and implementation details. It also includes a proposed fix with code changes. This allows for a clear understanding of what needs to be fixed and how to implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15414": {
        "explanation": "The issue is reasonably specified.  It identifies a problem with the Django ORM's bulk_update() method where it does not set the _for_write flag before accessing the db attribute.  This results in the method using the read database instead of the write database within a transaction.  While the explanation is concise and assumes some familiarity with Django's internals, it is clear that the goal is to modify the bulk_update() method to ensure it uses the correct database for write operations by setting _for_write before accessing db.  A developer with Django ORM experience could implement a solution based on this information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15421": {
        "explanation": "The issue is well-specified because it clearly explains the problem caused by Python 3.8 on macOS changing the multiprocessing start method from 'fork' to 'spawn'. It describes the error encountered when running tests with the --parallel flag and provides a patch that changes the worker initializer to run django.setup() and set the db name with the test_ prefix. This information is sufficient for an experienced developer to understand the problem and implement a solution. The problem is specific to a known issue with multiprocessing on specific OS and Python versions, and the solution approach is outlined in the patch.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15423": {
        "explanation": "The issue is well-specified. It clearly describes the problem with LazyObject defining magic methods that may not exist on the wrapped object, leading to TypeErrors when these methods are used. It provides a concrete example of how the error manifests, including the actual error messages. The issue is specific enough that a software engineer could understand what needs to be fixed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15433": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, a reproducible example with a Git repository, and specific code examples. The user explains the problem with ManyToManyField and Django's migration system, and provides details about the custom User model and the erroneous migration files. This information is sufficient to understand what the problem is and how to reproduce it, which is essential for creating a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15438": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: when a specific regional translation (e.g., 'de-ch') is not available for the Select2 widget, it defaults to English, but a more generic translation (e.g., 'de') would be better. The proposed solution is to use the language without the region if an exact match is not found. While there may be some details to work out in implementation, the general approach is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15467": {
        "explanation": "The issue is well-specified because it includes a clear problem description, a code example that demonstrates the issue, and a proposed solution with the specific line of code that needs to be changed. The problem is that the 'empty_label' is being overridden in ModelAdmin when 'radio_fields' is used, and the solution is to modify the line of code in options.py to respect the 'empty_label' setting. The code example shows how the user is trying to set a custom empty label, but it is being ignored. The proposed fix is specific and actionable. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15474": {
        "explanation": "The issue is reasonably specified. The problem is that when rolling back the migration 0002 for the contenttypes app on a non-default database (with alias 'other'), the legacy name field is not being populated correctly. It is clear that the migration is supposed to populate this field but it is not doing so for non-default databases. However, there may be some missing details about the exact expected behavior, the context in which the migration is being run, and the underlying reason for the issue. But overall, it's a reasonable and solvable problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15481": {
        "explanation": "The issue is well-specified because it clearly states the problem and provides a concrete example of the current behavior. It also explains the discrepancy with the get_signed_cookie method. The solution would involve updating the set_cookie and set_signed_cookie methods to handle timedelta objects similarly to how get_signed_cookie does. The issue gives enough context and technical detail to understand what needs to be changed and how it should behave.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15492": {
        "explanation": "The issue is well-specified. It clearly outlines the problem: the inability to synchronize user attributes from a remote system to Django user records during authentication when using a custom RemoteUserBackend. The proposed solution is also clearly defined - adding a new method called 'synchronize_user' with the same signature as 'configure_user', which will be called after fetching the user from the database during authentication. The issue explains what this method should do (allow implementors to override it and implement data synchronization) and when it should be called (on every user authentication attempt). There is no ambiguity in the requirements, and the technical implementation details are provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15498": {
        "explanation": "The issue is reasonably specified. It describes the problem (empty string for If-Modified-Since header now raises an exception) and the goal (fix handling of empty string). However, the exact desired behavior when an empty string is provided is not explicitly stated. A developer would need to make reasonable assumptions about whether to ignore the header, return a default value, or handle it in another way. But since the previous behavior was to ignore it, a developer can reasonably infer that the intended fix is to revert to that behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15499": {
        "explanation": "The issue is reasonably specified. It describes an optimization task where two operations, CreateModel and AlterModelManagers, should be combined into a single CreateModel operation during migration. While the general idea is clear, there are likely implementation details that need to be filled in, such as how to merge the operations, what data or parameters need to be combined, and how to handle edge cases. However, the core task is clear and a software engineer could reasonably interpret and implement the requested optimization.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15503": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the JSONField() lookups not handling numeric keys on SQLite, MySQL, and Oracle. The issue provides a specific example with a model and test case that demonstrates the problem, and it even includes the error output. The problem is reproducible with the provided setup, and the expected outcome is clearly defined in the test case. This information gives a clear understanding of what is wrong and what a successful solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15521": {
        "explanation": "The issue is well-specified because it includes a clear problem description, the expected behavior, the actual behavior, and the specific commit that introduced the change. It explains the discrepancy between DjangoTranslation and makemessages, and provides the exact error message and context. This information is sufficient to understand what needs to be fixed and how to approach the solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15525": {
        "explanation": "The issue is reasonably specified. The reporter has provided a detailed description of the problem, including the error traceback, the models, and the data. The problem is that using loaddata with non-default databases fails when natural keys use foreign keys, which works correctly with the default database. The reporter has also provided a test project for reproduction. While the core issue is clear, there might be some nuances in the expected behavior of natural keys across multiple databases that require interpretation. However, the information provided is sufficient for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15526": {
        "explanation": "The issue is well-specified because it clearly explains the problem, provides a specific location in the code (contrib/admin/options.py), identifies the function (get_view_on_site_url), and provides a patch (https://github.com/django/django/pull/15526) that can be referenced. The problem is described as a bug with the redirect in custom admin sites, and the cause is identified as a missing current_app keyword in a reverse call. The impact is also described (users of custom admin cannot use the 'view on site' link when the default admin has extra protections). All necessary information is provided to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15554": {
        "explanation": "The issue is well-specified. The reporter provides a detailed description of the problem, including the code they are using and the observed behavior. They also explain their expected outcome and what is not working as intended. The issue has a clear context, a specific problem statement, and the reporter has done their due diligence in investigating the issue and providing a code example. A software engineer can use this information to understand the problem and attempt to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15560": {
        "explanation": "The issue is well-specified. It describes the problem clearly, provides a code example of the custom User model using UniqueConstraint, explains the error encountered when creating a duplicate superuser, and highlights the expected behavior (username validation). A developer would understand the problem and how to approach fixing the validation logic in the createsuperuser command to properly handle UniqueConstraint.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15561": {
        "explanation": "The issue is reasonably specified. It describes a problem where altering a field with choices in Django generates unnecessary SQL operations for SQLite, unlike PostgreSQL. The issue provides a context (writing a test case for #33470) and a specific behavior to fix (AlterField should be a no-op when adding/changing choices on SQLite). While some technical details may need investigation, the main goal is clear enough to proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15563": {
        "explanation": "The issue is well-specified. The problem is described with a clear example, including the model definitions and the steps to reproduce the issue. The expected versus actual behavior is clearly outlined, and there is enough information to understand what needs to be fixed in the code. A developer can use the example to reproduce the issue and identify where the problem lies in the Django queryset update logic when dealing with multiple inheritance.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15569": {
        "explanation": "The issue is well-specified because it clearly describes the problem: the _unregister_lookup method does not clear the lookup cache, unlike the register_lookup method. It provides specific locations in the code where the issue exists and where changes are needed, including a reference to a test that needs minor adjustments. The goal is clear - to modify the _unregister_lookup method to clear the cache and update the mentioned test.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15572": {
        "explanation": "The issue is about a regression in Django 3.2.4+ where autoreload breaks when an empty string is present in the TEMPLATES DIRS configuration. The problem is clearly described, including the cause (normalization using pathlib.Path), the effect on autoreload, and the specific commits that introduced the change. The solution is also suggested (filtering out empty strings). With this information, a developer can understand what the issue is, why it's happening, and how to fix it by ensuring empty strings are filtered from the DIRS configuration. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15576": {
        "explanation": "The issue is about optimizing the `.exists()` method for distinct querysets in Django. It references a previous fix that introduced an inefficiency, and proposes a specific condition for when to keep the fields on the queryset. However, there is some ambiguity about exactly how to implement this change and how to test it. The reporter seems unsure whether to submit the patch without a test or find a better way to write a test. While the core problem is clear, the implementation details and testing approach are less clear. This makes the issue reasonably specified but with some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15586": {
        "explanation": "The issue is about enabling a cached template loader in development mode, but there are several ambiguities. It references previous changes and discussions in a PR, which are not described in detail. It is unclear what exactly needs to be done to implement this change, how the cached template loader works, and what the implications of enabling it by default would be. Without more specific information about the codebase, the current configuration, and the desired outcome, it's difficult to determine the exact steps required for a solution.",
        "label": "VAGUE"
    },
    "django__django-15607": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue includes reproduction instructions, expected and actual results, and a detailed description of the problem. This allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15620": {
        "explanation": "The issue is well-specified. It explains the current behavior, the problem it causes, and the proposed solution with examples. The examples show exactly what the desired output should look like, including the addition of a comment indicating a no-op migration operation. This provides enough information for a software engineer to locate the relevant code in the codebase that generates these migration outputs and implement the necessary changes. The examples make it clear how the SQL output should be modified to include the no-op comment after each relevant operation header.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15629": {
        "explanation": "The issue is well-specified because it includes a detailed description of the problem, the models involved, the exact error, and a clear example of what the correct solution should look like. The issue explains how the db_collation is not being properly applied to foreign keys when the primary key is modified, causing constraint errors in MySQL. It also provides before-and-after examples of the SQL statements that are generated and shows how adding the collation to the foreign key fields fixes the issue. This information is sufficient for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15643": {
        "explanation": "The issue is not very well specified. It mentions that migrations drop an explicit primary key when it's altered, but it doesn't provide enough details on the specific scenario or context. For example, it's unclear what the initial state of the primary key is, what changes are being made to it, and what the expected behavior should be. Without concrete examples, code snippets, or steps to reproduce the issue, it's difficult to determine the exact problem and how to fix it. Therefore, the issue is vague.",
        "label": "VAGUE"
    },
    "django__django-15648": {
        "explanation": "The issue is reasonably specified. It explains the problem with decorators on methods used by __get_dynamic_attr, provides an example error, and suggests a potential solution. However, it leaves some implementation details to be filled in, such as which specific method to remove and how to handle the change in behavior. The reporter also offers a Python code snippet showing the relevant logic, which helps in understanding the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15651": {
        "explanation": "The issue is reasonably specified, but has some blanks that need to be filled in. The core requirements are clear: implement a RenameIndex operation that works in a backwards compatible way, considering both old (unnamed) and new (named) indexes. The issue provides technical details about how to handle different database capabilities (like MySQL not supporting RENAME INDEX), how to handle multiple indexes found by field names, and how the autodetector should behave. However, some implementation details would require interpretation, like exactly how to interact with the migration framework, how to implement the autodetector logic, and how to handle backwards compatibility in specific edge cases. The approach is outlined, but some code-level specifics would need to be worked out by the developer.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15669": {
        "explanation": "The issue is reasonably specified. The request is to create a --update flag for the makemigrations command in Django, similar to South's functionality. The user provides context and a link to the South documentation, which describes the desired behavior. While the specific implementation details are not provided, the general goal is clear. The developer would need to research how South's --update flag works and implement a similar feature in Django's makemigrations command. There may be some ambiguity about the exact behavior and edge cases, but the overall requirement is understandable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15671": {
        "explanation": "The issue is reasonably specified. It describes the need to allow overriding error messages related to the number of forms in a FormSet. It mentions that moving messages to default_error_messages allows overriding via the error_messages argument when instantiating the FormSet, but the user would also like to be able to override them via inlineformset_factory, though this is noted as a separate task. There is a clear goal to implement functionality for overriding error messages, but the exact implementation details are not specified, which requires some interpretation. However, the general direction is clear enough to attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15678": {
        "explanation": "The issue is well-specified. It clearly states the action to be taken (deprecate CryptPasswordHasher), provides context for the decision (undocumented, not recommended, UNIX-only, and Python 3.11 deprecation of the crypt module), and outlines a timeline (deprecate in Django 4.1 and remove in Django 5.0). The objective is clear and actionable for a software engineer. There is no ambiguity in what needs to be done. The necessary steps would involve marking the hasher as deprecated in the upcoming version, adding deprecation warnings, updating documentation to reflect this change, and planning for its removal in the next major release. The issue provides sufficient information to proceed with the implementation.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15682": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem with the current behavior of the 'nulls_first' and 'nulls_last' parameters in the 'OrderBy' function. It shows examples of how passing False to these parameters does not behave as expected, and it suggests a solution where the parameters default to None instead of False. While there might be some details to consider when implementing the solution (like how to handle the change in existing code that relies on the current behavior), the main problem and proposed solution are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15689": {
        "explanation": "The issue is well-specified because it clearly describes the performance problem caused by the APPEND_SLASH middleware in Django. It explains the historical context (the change in commit 9390da7...), provides concrete data from benchmarks showing the performance impact, and even includes steps to reproduce the issue with a minimal test project. The problem is clearly defined as the unnecessary performance overhead caused by always checking should_redirect_with_slash() on every request not ending with a slash, rather than only on 404 responses as it originally did. This gives a clear understanding of what needs to be fixed and how to verify the fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15695": {
        "explanation": "The issue is reasonably specified. The problem is that RenameIndex() crashes when an unnamed index is moving backward and forward. The issue provides a specific test case and describes the expected behavior. However, there is some ambiguity in the exact implementation steps needed to resolve the issue. The error message suggests that the issue is related to a database constraint violation, but the specific cause and solution are not fully clear. A developer would need to understand the internal workings of the RenameIndex operation and the database schema handling to implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15698": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the error, the context in which it occurs (during a Django version upgrade from 2.2 to 3.2), and the expected behavior compared to the actual behavior. The user also provided a code snippet showing the error and a potential fix that worked for them. This information allows a clear understanding of the problem and the steps needed to address it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15703": {
        "explanation": "The issue is reasonably specified. It asks to deprecate 'index_together' in favor of 'indexes', and it's clear that the functionality of 'index_together' should be replaced by the 'indexes' and 'Index' class. However, some details such as the deprecation timeline, how to handle backwards compatibility, and the exact implementation steps are not specified, which would need to be determined during development. Therefore, it's reasonably specified but requires filling in some blanks.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15731": {
        "explanation": "The issue is well-specified. It clearly describes the problem (inspect.signature returns incorrect signature for manager methods), provides a reproducible example, explains the root cause (metadata is not fully copied), and suggests a concrete solution (use functools.wraps instead of manual assignment). The issue also references specific code locations and expected vs actual outputs. This provides all necessary information to understand the problem and implement the proposed fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15732": {
        "explanation": "The issue is well-specified. The user has provided a clear description of the problem, including the specific error they are encountering when trying to drop a unique_together constraint on a model's primary key. They have explained that there are two unique constraints on the same column (the primary key and the unique_together constraint), and they've mentioned the database (PostgreSQL). This provides enough information to understand what is happening and how to approach a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15737": {
        "explanation": "The issue is well-specified. It provides a clear scenario with ORM models 'Parent' and 'Child', explains the problem of unnecessary lazy reads, describes the current workaround, and even suggests a potential solution with a specific code change. The problem's context (bulk_create() leading to many unwanted SELECT queries) is also given, which helps understand the impact. All necessary details are present to implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15738": {
        "explanation": "The issue is well-specified and provides a clear problem description, including the models involved, the error encountered, and the desired outcome. It also mentions the constraints of working with a production database and the user's attempted solution. All the necessary details for understanding the problem and implementing a solution are provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15741": {
        "explanation": "The issue is reasonably well-specified. It clearly describes a problem where the get_format function in Django is raising a TypeError when it receives a lazy string (such as from the _ function). It provides a concrete example of how the issue occurs (using some_date|date:_('Y-m-d')), and explains the error message that results. However, it does not fully describe the desired solution or the exact expected behavior. A developer would need to understand the context of lazy strings in Django and how the get_format function should handle them. There are some blanks to fill in, but a sensible interpretation of what is required for a successful solution is possible.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15742": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the expected behavior of the blocktranslate asvar functionality, the current bug where variables are double-escaped due to being stored as str instances, and a minimal example that reproduces the issue. The reporter also clearly states the proposed solutions (either assigning a SafeString instance or not escaping variables and marking them as unsafe). This provides enough information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15744": {
        "explanation": "The issue is not very well specified. It describes a problem (the request body is closed prematurely by the ASGI handler) and references a specific PR that introduced a bug related to I/O operations on a closed file. However, it lacks important details that would be necessary for implementing a fix. Specifically, it doesn't explain:",
        "label": "VAGUE"
    },
    "django__django-15747": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with the error encountered (FieldError) when using QuerySet.update() on an ordered queryset with annotated fields. The code for the admin model and the custom action is provided, which helps in understanding the context. The user explains that the error occurs only when sorting by annotated fields and that the action is on a regular model field. The user also notes that the error handling was added to inform users, but the behavior is considered unexpected. However, there are some blanks to fill in, such as the exact conditions under which the error occurs and the full context of the Django version and database backend being used, which could affect the solution. Despite these, the core issue is clear and a developer can work towards a solution with the provided information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15752": {
        "explanation": "The issue is to deprecate a function called make_random_password() which is no longer used. The issue provides the commit hash where it was last used and mentions Carlton's comment. It is clear what needs to be done - mark the function as deprecated, add a deprecation warning, and possibly remove it in a future release. The issue is well-specified because the task is straightforward and the necessary information is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15766": {
        "explanation": "The issue is reasonably specified. It proposes adding a 'robust' keyword argument to on_commit handlers, similar to the send_robust method for signals. The explanation includes a concrete example of how this would work and why it's needed. However, there are some implementation details not specified, such as how exactly the robust handlers would be managed internally, but these can be reasonably inferred from the Django signals implementation and the context provided. Therefore, the issue provides enough information for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15774": {
        "explanation": "The issue is well-specified. The problem is clearly described: Django is currently handling HTTP Accept-Language headers in a case-sensitive manner, but the standards (w3c, rfc2616, bcp47) require case-insensitive parsing. The issue provides a concrete example of the problem (Chrome vs Firefox), and it clearly outlines the two parts of the fix: 1) Fix code for case-insensitivity (specifically mentioning parse_accept_lang_header()) and 2) Fix the documentation. This gives a clear path for implementation and verification. The standards referenced also provide authoritative guidance for implementation. The problem, its impact, and the solution are all clearly defined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15781": {
        "explanation": "The issue is reasonably specified. It clearly shows the current output and the expected output for the help command of a Django management command. The problem is that the example usage in the help output is not properly formatted with line breaks as intended. The reporter has provided code sample, current output, and expected output, which gives a clear idea of what the problem is and what the desired outcome is. However, there may be some implementation details that are not specified, such as exactly how the formatting should be handled in the Django management command framework. But based on the information provided, it's clear what the goal is.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15799": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with code references and an explanation of the discrepancy between the widget's rendering logic and the help text logic in the admin. However, it's not entirely clear what the exact desired behavior should be or how to implement the fix without more context on what the expected outcome is.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15814": {
        "explanation": "The issue is well-specified with a detailed description of the problem, including the error traceback, model definitions, and the command causing the issue. It also provides a proposed fix. This information is sufficient for understanding the problem and implementing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15819": {
        "explanation": "The issue is about the inspectdb command in Django not generating proper related_name attributes for fields that reference the same model, which leads to clashes when the generated models are used. The problem is clearly described with the error message and the hint from Django that indicates the issue. The reporter suggests a potential solution: automatically generating a related_name for each field to avoid the clash. While there might be some details about how to implement this (e.g., exactly how to generate the related_name to ensure uniqueness), the overall problem and desired outcome are clear enough for a meaningful attempt at a solution. There is a reasonable interpretation of what needs to be done.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15828": {
        "explanation": "The issue is vague because it lacks a clear explanation of what the problem is and what the expected behavior should be. It mentions that BaseConstraint.deconstruct() and __eq__ operators don't take violation_error_message into account, but it doesn't explain how they should be modified to do so, nor does it provide any details about the functionality of these methods or the violation_error_message. The mention of a commit hash and a reporter doesn't clarify the requirements for the solution. Without additional context or a more detailed description of the problem and the desired outcome, it's not clear what a successful solution would look like.",
        "label": "VAGUE"
    },
    "django__django-15851": {
        "explanation": "The issue is well-specified. The problem is described clearly, including the expected behavior of psql, the current incorrect behavior when using `dbshell` with additional parameters, and a hint about how to fix it (constructing the args list in the correct order with the database name at the end). A software engineer would be able to understand the problem and implement a solution based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15863": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the floatformat template filter dropping precision when used for Decimal numbers. It provides a minimal working example (MWE) that demonstrates the issue, shows the actual output compared to the expected output, and even points to a prepared pull request with a potential solution. All the necessary information is provided to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15869": {
        "explanation": "The issue is well-specified and provides a clear plan for deprecating the 'length_is' template filter in favor of using the 'length' filter with the 'if' tag. The description explains the problem with the current 'length_is' filter, provides context about its origin, and suggests the preferred approach. A successful solution would involve marking 'length_is' as deprecated, updating documentation, and providing examples showing the recommended alternative. All necessary information is provided for an implementation plan.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15902": {
        "explanation": "The issue is about a deprecation warning related to the use of 'default.html' templates for ManagementForm in a project where forms are not rendered using the {{ form }} expression. The core of the issue is that the deprecation warning is being raised for the management form, even though the template is not used in a visible way (it's just hidden inputs). The user is asking whether it's worth special-casing to avoid the warning for management forms specifically. While the issue is somewhat technical and may require understanding of the framework's internal behavior, it is clear what the problem is (a deprecation warning for ManagementForm) and what the potential solution would involve (special-casing to avoid the warning). The request is specific enough to allow for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15916": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description clearly explains the current behavior of the modelform_factory function and the expected behavior. It provides an example that illustrates the problem and even references previous tickets and tests that are relevant. The problem is described in sufficient detail to understand what needs to be fixed in the Django codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15925": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem, steps to reproduce the error, and details about the error message. Additionally, it mentions the specific scenario where the error occurs (when using the RemoveField migration on an indexed field in Django 4.1 with SQLite 3.35.5+). The issue also includes a minimal example and instructions for testing both the working and failing cases. All these details make it clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15930": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example that reproduces the error, an explanation of the expected behavior, and the actual error that occurs. The issue includes a specific use case (~Q(pk__in=[])) that is causing a crash, and explains why this case is important (as a sentinel value in application code). The error message and the generated SQL are also provided, which helps in understanding where the problem occurs. All the necessary information is present to reproduce the issue and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15957": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem with an example and explains the use case. However, it does not specify the exact expected behavior or how to resolve the issue. A developer would need to understand Django's prefetch mechanism and determine the correct approach to implement slicing with prefetch.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15969": {
        "explanation": "The issue is reasonably specified. It describes a performance problem when using `on_delete=models.SET_NULL` with a large number of child records (30k). The user provides the expected vs. actual SQL queries and explains their workaround using `on_delete=models.CASCADE`. While the issue is primarily a question about the underlying behavior and performance, there's enough information to understand the problem context, including the model structure and observed query patterns. A solution could involve optimizing the update query or understanding why the current query is inefficient. However, the request is more about explanation than a direct fix, which leaves some ambiguity in what exactly needs to be resolved.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15973": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The reporter has provided a clear description of the problem, including the error message, a minimal reproduction case with model definitions, the generated migration, and the traceback. They've also isolated the issue by testing different configurations (moving models into the same file works, while separating the through model into a different app causes the issue). This provides sufficient context and details for a developer to understand what's happening and how to reproduce it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-15987": {
        "explanation": "The issue is reasonably specified. It indicates that when FIXTURE_DIRS contains Path instances, the duplicate check in loaddata does not detect duplicates. This suggests that the duplicate detection logic may not handle Path instances correctly, and it would be necessary to investigate how the current logic compares paths and ensure that it correctly handles Path instances. While the issue does not provide full details on the expected behavior or the exact cause of the problem, a software engineer with access to the codebase could reasonably infer what needs to be fixed and implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15993": {
        "explanation": "The issue is reasonably specified. It describes the problem that a RenameModel operation with a defined db_table should be a no-op (no operation). It also provides context on the current behavior in Postgres and SQLite. However, some details are missing, such as the expected behavior for other databases or the exact conditions under which the RenameModel should be considered a no-op. These can be inferred or clarified during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-15996": {
        "explanation": "The issue is reasonably specified.  It describes the problem (Enum flags with multiple values are not being serialized correctly), and provides an example of the problem and a potential solution.  However, some details are missing to fully implement the solution.  For instance, how to handle the decomposition and reconstruction of the enum values, and how to integrate this with the existing serialization framework.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16002": {
        "explanation": "The issue is well-specified. It includes a clear problem description, steps to reproduce the issue, and a traceback of the error that occurs. The problem is that NaN values can be stored in a DecimalField but cause an error when retrieved. The steps to reproduce are detailed, allowing for the recreation of the issue. The traceback points to the specific error in the code, providing insight into where the problem occurs. All necessary information is provided to understand the issue and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16032": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description includes a test case that reproduces the bug, which clearly demonstrates the problem with the code. The error message is provided, indicating what is going wrong. The test case shows how the 'in' query is not correctly handling the selected fields when 'QuerySet.alias()' is used after 'annotate()'. The expected outcome is also provided, making it clear what the fix should achieve. All the necessary information is provided to understand the issue and how to verify that a solution is correct.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16037": {
        "explanation": "The issue is well-specified. The user describes the problem clearly, provides detailed error messages from both SQLite and PostgreSQL, and includes the relevant code snippets for the PostManager class and models. This information is sufficient to understand the issue with the QuerySet.annotate() method and the Count aggregation, making it possible to attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16041": {
        "explanation": "The issue is well-specified with a clear problem description, expected behavior, and steps to reproduce. The problem occurs when 'empty_permitted' is passed to form_kwargs and causes a KeyError when rendering the empty_form of a formset. The expected behavior is that 'empty_permitted' should be ignored for the empty_form. The steps to reproduce include specific code examples in views.py, urls.py, and the template. This provides enough detail for a developer to understand the issue and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16046": {
        "explanation": "The issue is reasonably specified. It describes a specific error (IndexError: string index out of range) that occurs in the numberformat.py file when handling a null value. The error happens when checking if the first character of a string is a hyphen. The description gives enough context to understand the problem (it mentions admin list_display formatting). While it doesn't specify the exact solution, it's clear what the problem is and a developer can work on fixing the null handling in the code. There are just some details to be filled in about the implementation of the fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16053": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the __str__ method of ContentType and Permission mixes localized and non-localized text. The issue provides context (commit hash, related issue), describes the problem (mixed language strings), and suggests a possible solution (use either all localized labels or none). A developer can understand what the problem is and what the desired outcome should be.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16067": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, including specific examples of the behavior in different Django versions (1.11.29 vs. 2.0.13). It also explains when the change was introduced (with a commit link) and includes a reproducible test case. The request for a solution is clear: to find a way to prevent the validation error in Django 2.0 without using a workaround. All necessary information for identifying and addressing the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16076": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the error message and a minimal complete verifiable example (MCVE). The user is asking to support 'startswith' lookup on relation fields (specifically on a ForeignKey field pointing to a specific field). The current workaround forces a costly join, which is not acceptable for the user. The goal is to allow the 'startswith' lookup directly on the related field without requiring an explicit join. The issue includes the exact error message, the Django versions tested, and the exact code that causes the error and the workaround. All necessary information to understand the problem and reproduce it is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16082": {
        "explanation": "The issue is reasonably specified. It describes a problem with the Django ORM when using the MOD operator with different numeric types (Decimal and Integer), where the result is not being resolved to a Decimal type as expected. This gives a clear direction for investigation and solution. However, some details about the exact context and the expected behavior are not fully provided. For example, it doesn't specify the version of Django where this issue was observed, or provide a minimal example of the code that reproduces the issue. These missing details may require some assumptions or additional research to identify the exact problem and its solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16092": {
        "explanation": "The issue is somewhat clear, but there are several missing details. The main goal is to add a 'Field.db_default' feature for defining database defaults. However, the provided diff is incomplete and seems to reference a specific file (management.py) which may not be the correct location for implementing this functionality. Additionally, the issue mentions applying a diff, but the actual code change is only a small snippet with line numbers that may not be accurate for the current codebase. The requirement that it should work on any database is also a bit vague without specifics on how to handle database-specific syntax for defaults. The implementation would require understanding Django's field system, database backends, and how defaults are currently handled, which are not fully explained in the issue. Therefore, there are enough details to make a reasonable attempt, but some interpretation would be needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16100": {
        "explanation": "The issue is reasonably specified. It points out that the changelist_view in Django admin lacks a transaction and suggests wrapping it to prevent unexpected database states on errors. While some context and implementation details are implied, the core problem and goal are clear enough for a meaningful solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16116": {
        "explanation": "The issue is about the inconsistent behavior of the --check option in the makemigrations command compared to other commands like migrate and optimizemigration. The reporter suggests that makemigrations --check should exit without generating migrations, similar to how migrate --check works. The problem and the proposed solution are clearly described, even if there is a need to understand the codebase and how the --check option is implemented for other commands. The reporter also provides context about where the issue was noticed and references relevant tickets and discussions. This is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16117": {
        "explanation": "The issue is well-specified and clearly describes the problem of Django not detecting migration files due to dots in the file names. It provides a step-by-step reproduction, explains why the problem occurs, and outlines three possible solutions. The problem is specific enough to understand what needs to be fixed, and the suggested solutions give a clear direction for resolving the issue. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16120": {
        "explanation": "The issue is well-specified. It clearly describes the problem: when running 'migrate --check' with an up-to-date database, the pre_migrate and post_migrate signals are still being emitted. It also provides an example of the current output and explains why this is problematic (potential confusion). A successful solution would involve modifying the code to prevent these signals from being emitted in this specific scenario. The steps to reproduce and the expected outcome are clearly defined.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16136": {
        "explanation": "The issue is well-specified. It provides a detailed error message, a clear description of the problem, and a step-by-step guide to reproduce the bug. The reporter has also included the specific versions of Django and Python they are using, as well as a minimal example of the code that causes the issue. All of these details make it possible for a developer to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16139": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the URL structure when accessing the UserAdmin via to_field, the relevant code snippet, and the proposed solution. The explanation of the problem and its cause is clear, and the suggested fix is specific enough to implement. There's also a mention of a pull request, which implies the reporter has already worked on a solution and provided context for the fix. All necessary information to understand and address the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16142": {
        "explanation": "The issue is reasonably specified. The user is explaining that the function get_language_from_request is currently falling back to settings.LANGUAGE_CODE, which they believe should not be the case. They propose that the function should return None instead so that the middleware can handle the fallback. While the high-level goal is clear, there are some implementation details that would need to be determined, such as how to modify the function's logic to avoid the fallback and what impact this change might have on other parts of the system that rely on the current behavior. However, a reasonable interpretation of the required changes can be made based on the description provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16143": {
        "explanation": "The issue is reasonably specified. It explains the problem (TransactionManagementError not being helpful), provides context (error occurs in Django when using Celery), and suggests a solution (track why needs_rollback is set to provide better error info). However, there are some details that would need to be filled in during implementation, such as exactly how to track the reasons for needs_rollback and how to integrate this into the existing Django transaction management system. The core problem and goal are clear, though.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16145": {
        "explanation": "The issue is well-specified because it explains the problem (the server starts at http://0:8000/ which is not usable in browsers), provides the expected behavior (it should start at http://0.0.0.0:8000/), and references the documentation as a source of the correct behavior. The developer can understand what the problem is and what needs to be changed to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16208": {
        "explanation": "The issue is reasonably specified. The problem is described as the lack of logging for database transaction commits and rollbacks in Django. The request is to add logging for these events. While there are some implementation details that need to be considered (such as where to add the logging, the format of the log messages, and how to integrate with the existing logging system), the overall goal is clear and actionable. A software engineer would understand that they need to modify the Django source code to add log statements for transaction commits and rollbacks, similar to how the BEGIN statements are logged. There is no ambiguity about the main objective, but there are some implementation details to figure out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16229": {
        "explanation": "The issue is well-specified with clear steps to reproduce, a minimal code example, and a description of the observed problem. The reporter even suggests a potential fix (forcing show_hidden_initial=False on the field in the form init). This provides sufficient information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16254": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with a clear explanation of the regression behavior in Django 4.1 compared to Django 4.0. The issue includes a detailed reproduction scenario, sample code before and after the change, and exact SQL output showing the difference in behavior. The issue also provides a git commit reference that seems to have introduced the regression. All of these details make it possible to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16255": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem: when a sitemap contains no items but supports a callable lastmod, it raises a ValueError due to the max() function being called on an empty sequence. The issue provides a traceback, explains the scenario, and even proposes a potential solution with code changes. This gives a clear direction on what needs to be fixed. A software engineer with access to the codebase could use this information to locate the relevant code (get_latest_lastmod method) and implement the fix by catching the ValueError in addition to the existing TypeError.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16256": {
        "explanation": "The issue is reasonably specified. The problem is that the async methods acreate(), aget_or_create(), and aupdate_or_create() were added to related managers, but they are not functioning as intended. The description provides some context about where the issue was introduced and what the intended behavior should be. It also includes code examples that show the current implementation and indicates the need for proper versions of these methods for related managers, including six combinations for forward and reverse directions. However, there are some missing details about the exact expected behavior for each method and how they should interact with related managers. The code snippets give an idea of what needs to be done, but there is still room for interpretation about the precise implementation. Therefore, the issue is reasonably specified but has some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16260": {
        "explanation": "The issue is well-specified. The user has provided a clear description of the problem, including code examples, test cases, and their investigation into the Django source code. The problem is that model.refresh_from_db() doesn't clear cached generic foreign keys, which leads to specific test failures. The user has also provided the Django version and noted that the behavior has not changed recently. This information is sufficient to reproduce the issue and understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16263": {
        "explanation": "The issue is reasonably specified. The problem is clear: annotations in a count query are not being stripped when they are not used. The example is given, and the desired behavior is similar to how select_related is handled in count queries. However, the exact implementation details and edge cases are not fully specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16281": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with clear steps to reproduce, including code examples and the specific error that occurs. The user has provided a clear migration scenario and the resulting error, allowing a software engineer to understand the issue and work on a solution. The issue is about a specific error when changing a ManyToManyField target to 'self' and the expected outcome is clear.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16302": {
        "explanation": "The issue is well-specified. The problem is clearly described: the user wants to be able to define a CharField with unlimited length by setting max_length=None, but Django currently throws an error. The issue includes a concrete example of the error, the stack trace, and a proposed solution (modifying the validation code to skip the check when max_length is None). Additionally, the user points out a related issue with FileField. With this information, an experienced software engineer would be able to implement the proposed solution and test it. The requirements are clear and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16306": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly identifies the function BaseForm.__getitem__(), provides a specific GitHub link to the code in question, and explains what the problem is (unnecessary work being done in the happy path). The issue also suggests a solution (return self._bound_fields_cache[name] at the beginning and handle KeyError). This provides enough information to understand the problem and implement the suggested solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16311": {
        "explanation": "The issue is reasonably specified. The problem (BREACH attack) and the proposed solution (implementing the 'Heal The Breach' mitigation by adding randomness to the gzip filename field) are clearly identified. However, there are some blanks to fill in, such as the exact implementation details of how to inject random bytes into the gzip filename field, which libraries or modules in Django to modify, and how to provide a sensible default for this mitigation. These details would require some research and understanding of the Django codebase and the gzip implementation in Python. Despite these blanks, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16315": {
        "explanation": "The issue is well-specified because it includes a clear example of the problem, the error message, and the expected outcome. The user provides the model definition, the bulk_create call, and the resulting SQL with the error. This provides enough information to understand the problem and what the correct behavior should be.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16322": {
        "explanation": "The issue is well-specified because it includes a clear problem description, a minimal example that reproduces the issue, the exact error message, and an explanation of what Django is doing incorrectly. The issue also explains the expected behavior versus actual behavior and suggests a possible solution (producing a warning). There is enough information to understand the problem and create a fix for it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16333": {
        "explanation": "The issue is well-specified. The problem is described as the UserCreationForm not saving data from ManyToMany form fields when used with a custom User model. The cause is identified as the omission of self.save_m2m() in the save method. The user is ready to work on a PR, and there's a reference to a discussion on the mailing list. This provides enough information to understand the problem and know what to fix in the code.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16343": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a concrete example of the vulnerability caused by passing positional arguments to the Signer class. The proposed fix is clearly outlined: changing the __init__ method signature to add a * to enforce keyword-only parameters. This makes the intention of the solution clear.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16379": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the specific race condition in the has_key method of the FileBasedCache class. The code snippet is provided, and the problem scenario is explained (multiple threads racing to read an expired cache). This provides enough information for a software engineer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16398": {
        "explanation": "The issue is not clearly explained, and the solution is not obvious. The issue mentions a problem with the Django ORM's select_related() method when used with multiple filtered relations to a OneToOneField, but it's not clearly stated what the exact problem is or what the expected behavior should be. The issue also references code commit and code location, but doesn't provide a clear description of the issue or the desired outcome. The reference to using 'partial' like the 'remote_setter' is cryptic without additional context about what 'partial' refers to or why this change is needed. The issue is too vague and lacks sufficient detail to understand what the problem is and how to solve it.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "django__django-16408": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem description is quite technical and assumes knowledge of Django's FilteredRelation, select_related, and the specific models involved (PoolStyle, pool, tournament, etc.). Without understanding the model relationships, the expected behavior of FilteredRelation with select_related, and the purpose of the test case, it would be difficult to determine what is wrong and how to fix it. The error message indicates an assertion failure, but it doesn't clearly explain what the expected outcome should be or why the current outcome is incorrect. The description lacks context about what the code is supposed to do, why the test is important, and what the actual problem is. It just shows a test case and its failure output, which is not sufficient for someone who is not already familiar with these specific Django ORM features and models.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "django__django-16411": {
        "explanation": "The issue is reasonably specified because it clearly outlines the desired functionality (exposing a manifest_hash that changes when anything in the manifest changes) and its purpose (allowing SPAs to perform a full reload based on a header change). However, it lacks some implementation details, such as exactly how the hash should be calculated, what format it should take, and how the header should be used. These details can be inferred or filled in during implementation, but they are not explicitly provided in the issue description.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16429": {
        "explanation": "The issue is well-specified. It includes a clear error message (TypeError: can't subtract offset-naive and offset-aware datetimes), a test case that reproduces the problem, and a proposed solution. The issue explains that the problem occurs when using timesince() with a datetime that is one month or more in the past and with USE_TZ=True. The problem is caused by a missing tzinfo in the pivot datetime calculation. The proposed solution is to add the tzinfo to the datetime call. All necessary information to reproduce and fix the problem is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16454": {
        "explanation": "The issue is well-specified. It provides a detailed description of the problem, including code examples and the expected vs actual behavior. The issue also explains the root cause of the problem and suggests a potential solution. All necessary information is provided to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16485": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem, including the error message and specific examples of code that cause the issue. The examples demonstrate the exact inputs that lead to the error, making it easy to reproduce and understand what needs to be fixed. The goal is clear: modify the floatformat() function to handle inputs like '0.00' and Decimal('0.00') without throwing an error when using a precision of 0.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16493": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16502": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described (runserver returns response body for HTTP HEAD requests, which violates RFC 2616). The expected behavior is clearly defined (response should not include body), and an actual behavior is shown. The STR (Steps to Reproduce) is detailed and provides clear instructions on how to reproduce the issue. The issue also references a specific Django version (1.10+) and provides information about when the problem started. The problem is technical in nature and relates to HTTP protocol compliance, which is a clear requirement. The impact is described (broken pipe errors in certain configurations). The issue is clearly related to Django's development server (runserver) and not to production servers. The reporter has provided all the needed information to reproduce and understand the issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16511": {
        "explanation": "The issue is about adding a feature to Django's update_or_create method to support different defaults for create and update operations. The problem is clearly described, including the motivation and a proposed solution (adding a create_defaults parameter). There's a discussion about potential backward compatibility issues and alternative approaches. The example provided shows how the feature would be used in practice. While there are some open questions (such as which approach to take), the core requirement is clear: to allow specifying different default values for create and update operations. A successful solution would involve implementing this functionality in a way that is compatible with Django's existing codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16514": {
        "explanation": "The issue is reasonably specified.  It clearly states the problem (log entries in admin sites show all entries regardless of which admin site they belong to), and it provides a link to a discussion of the problem.  The desired outcome is also clear - log entries should be filtered by the admin site.  However, some details are left to the implementer.  For example, how exactly to implement the filtering logic, what specific behavior to change, and what edge cases to consider.  These are all reasonable inferences that an experienced developer could make based on the context provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16517": {
        "explanation": "The issue is reasonably specified. The problem is described with a specific example and code reference. The problem is that a mixed-case view name is causing a 404 error in the admindocs. A solution would involve investigating the _get_view_func function and how it handles view names. There are some details that would need to be filled in during implementation, but the general problem is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16527": {
        "explanation": "The issue is reasonably specified. The user is suggesting that an additional permission check (has_add_permission) should be added to the 'show_save_as_new' logic in the Django admin. While the explanation is somewhat technical and assumes familiarity with Django admin internals, the core request is clear: modify a specific line of code to include a permission check. There is a clear location (file + line number) and a clear action (add a permission check).",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16560": {
        "explanation": "The issue is reasonably specified. It clearly explains the current limitation (not being able to customize the code attribute of ValidationError) and the proposed solution (adding a new violation_error_message parameter to BaseConstraint). It also provides context about the current workaround (subclassing the constraint and modifying the validate method) and references the relevant Django documentation. However, there are some implementation details that would need to be filled in, such as how exactly the new parameter will be used in the code and how it will interact with existing functionality. Overall, the issue provides a clear direction for a PR but leaves some implementation specifics to be worked out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16569": {
        "explanation": "The issue is well-specified. The problem is clearly described, including the specific conditions under which the error occurs (can_delete=True and can_delete_extra=False), the exact error message (TypeError: '<' not supported between instances of 'NoneType' and 'int'), and a clear code example that reproduces the issue. The proposed fix is also provided (changing the comparison to check index is not None first), along with a self-contained script to reproduce the bug. This gives all the information needed to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16578": {
        "explanation": "The issue is reasonably specified. The task is to change the signature of BaseConstraint to use keyword-only arguments for 'name' and 'violation_error_message', as these are already keyword-only in subclasses. While the exact implementation details (such as how to modify the method signature in Python) may require some interpretation, the overall goal is clear and there is a sensible way to approach the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16588": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description provides a clear problem statement, steps to reproduce the issue, and a detailed analysis of the problem. The issue includes code examples showing the problem, a traceback of the error, and even identifies the specific commit that introduced the bug. All of these details make it possible for a developer to understand the issue and create a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16595": {
        "explanation": "The issue is well-specified because it provides a concrete example of the problem, explains the current behavior, and suggests a possible solution. The problem is clearly described with specific code examples and expected outcomes. There is enough information to understand what the migration optimizer is doing wrong and what the desired behavior would be.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16599": {
        "explanation": "The issue is well-specified because it clearly describes the problem (an OverflowError when using an integer larger than SQLite supports), provides a reproduction step (querying with a very large integer in a specific URL), and includes the error message, Django version, Python version, and exception location. This information is sufficient to reproduce the issue and implement a solution, such as handling large integers or adding validation for input sizes.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16603": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific part of the code where the issue occurs, a reference to the test that is failing, and the expected behavior of the http.disconnect message. The issue explains the context (long-polling), the current implementation's problem (not handling disconnect on requests with bodies), and suggests a potential solution approach (something like Channel's await_many_dispatch()). All the necessary information is provided to understand the problem and start working on a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16612": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the expected and actual behavior. The cause of the issue is also identified - the redirect does not include the query string. A solution would involve modifying the redirect to include the query string when APPEND_SLASH is enabled. The code location is provided, making it possible to implement the fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16614": {
        "explanation": "The issue is well-specified. The problem is clear: the URLField in Django's forms currently defaults to 'http://' when no scheme is provided, and the request is to change this default to 'https://'. The relevant code reference is provided, and the expected behavior is clearly described. A successful solution would involve modifying the URLField's to_python method to use 'https' instead of 'http' as the default scheme. This is a specific and actionable task without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16631": {
        "explanation": "The issue is well-specified because it clearly describes a problem with the SECRET_KEY_FALLBACKS not being used for sessions, provides a detailed explanation of the situation where the secret key was rotated and the expected behavior was not observed. It also references specific parts of the Django source code, indicating where the problem might be. This gives a clear direction for a software engineer to investigate the issue and potentially create a solution. The user also explains their understanding of the problem and the expected outcome, which helps in understanding what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16642": {
        "explanation": "The issue is reasonably specified. It describes a specific problem where the mime type is being improperly guessed for files with extensions 'br' and 'Z'. The issue provides an example of the incorrect behavior and describes what is happening (the content type is being set as text/html when it should be different for these file types). However, the issue does not specify what the correct mime types should be for these file types, which is necessary information for implementing a fix. Despite this missing detail, there is a clear path to investigate the mime type guessing logic and determine what changes are needed to properly handle these file extensions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16649": {
        "explanation": "The issue is about the behavior of annotate() in Django's queryset API, specifically how annotated columns are positioned in the SQL query and how this affects the union() operation. The issue describes a problem that occurs when using values() to control column ordering for union(), and how annotate() columns are not controllable with values(), which can disrupt union(). The issue also suggests that this behavior should be documented.\n\nThe issue is reasonably specified because it clearly describes the problem, provides context about how values() is used to control column ordering, and explains how annotate() columns are not controllable. It also mentions that the issue was reported by a user and suggests a possible solution (documentation). However, the issue does not provide a minimal reproducible example, specific code that demonstrates the issue, or clear steps to reproduce it. These missing details would need to be inferred or filled in by the developer attempting to solve the issue.\n\nThe issue is not vague, but there are some blanks to fill in about the exact nature of the problem and how to reproduce it. A developer would need to understand how annotate() and values() work in Django, and how they interact with union().",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16661": {
        "explanation": "The issue is well-specified enough to understand the problem and the expected solution. The description includes a failing test case that demonstrates the incorrect behavior of the lookup_allowed() method in ModelAdmin when a foreign key is also a primary key. The test case shows that when using a chain of related fields (restaurant__place__country), the current implementation incorrectly raises a DisallowedModelAdminLookup exception. The description explains why this is happening - the admin is treating a foreign key as a primary key as if it were concrete inheritance, leading to an incorrect lookup shortcut (restaurant__country). The test case also shows that this code worked correctly in version 1.8. The expected solution is clear: the lookup_allowed() method should correctly handle foreign key fields that are also primary keys without incorrectly shortcutting the lookup as if it were concrete inheritance. The test case provides a clear way to verify the solution is working.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16662": {
        "explanation": "The issue is well-specified. It clearly describes the problem (migration import ordering violates coding style and isort defaults), provides examples of the current and desired states, references the coding style guide, and links to related issues for context. All necessary information is provided for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16667": {
        "explanation": "The issue is well-specified. The problem is described in detail, including a minimal example to reproduce the issue, the exact error message, and the part of the code where the error occurs. The explanation of why the error happens is also given, and the impact of the issue (server crash) is mentioned. All necessary information is provided to understand and fix the problem.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16686": {
        "explanation": "The issue is well-specified enough to understand the problem. The user is providing a clear example of the code that causes an error, the specific error message they receive, and what they expect differently. The example shows that when they annotate a queryset and try to use values() with the annotation name, they get a FieldError that does not list the annotation as a valid choice. This is a clear problem that can be addressed in the Django ORM codebase by modifying how the values() method handles annotated fields when generating error messages. There is enough information to reproduce the issue and determine what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16693": {
        "explanation": "The issue is well-specified. It describes the current problem with error messages for incorrect context processors in Django, provides an example of the current error message, and contrasts it with a better error message for views. It also suggests a solution by using try/except around the updates.update() line and references Python 3.11's improved exception handling. All necessary information to implement a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16745": {
        "explanation": "The issue is well-specified enough to understand the problem. It explains the discrepancy between client-side and server-side validation when using min_value and step_size in Django's StepValueValidator. The problem is clearly described with an example, and it's clear what the expected behavior is (matching browser behavior).",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16746": {
        "explanation": "The issue is reasonably specified. It indicates that the Paginator class's validate_number method raises error messages that cannot be customized or internationalized. A successful solution would involve modifying the Paginator class to allow for custom error messages and support for different languages. However, the issue lacks specific details on how the customization and internationalization should be implemented (e.g., using a configuration file, passing a dictionary of messages, or integrating with an i18n library). Despite this, there are standard approaches to implementing such features, so a developer can reasonably interpret and implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16750": {
        "explanation": "The issue is well-specified. It includes a clear error message, a code example that reproduces the error, and a suggested solution. The error occurs when using the Chr function with a Value object, and the traceback shows the problem is in converting a string to an integer. The suggested solution is to set output_field = CharField() in the Chr function to avoid this error. With this information, a developer can locate the relevant code in expressions.py and implement the suggested fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16757": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue provides a detailed description of the current behavior, the expected behavior, and the steps to reproduce the problem. The reporter has also provided the error message and traceback for the 500 response, which helps to understand the problem. The issue is asking to add a system check error for reversed foreign keys used in the list_display, similar to the existing error for ManyToManyField. This is a clear and specific request that can be implemented with the provided information.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16786": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the error encountered, the specific conditions under which it occurs, and a workaround. There is a reference to a reproduction repository with tests, and the problematic query is shown. This provides enough information for an experienced developer to understand the issue and create a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16801": {
        "explanation": "The issue is well-specified. It clearly explains the problem (unnecessary post_init signal handler in ImageField causing performance issues), provides context (debugging performance issues in a Django app), and includes a proposed solution (removing the signal handler when width_field/height_field are not set). The performance impact is quantified (30-40% speedup). This provides all the necessary information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16816": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, and the expected outcome. The user has provided a detailed traceback and the context in which the error occurs. There is a clear suggestion for a fix (updating error E108 to cover the case). The information given is sufficient for a developer to understand the problem and start working on a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16819": {
        "explanation": "The issue is asking to reduce AddIndex/RemoveIndex operations during migration optimization, but it lacks specific details on how to achieve this reduction, what criteria to use for reduction, and what the expected outcome should be. There are multiple possible approaches to optimizing these operations, and without more context, it's unclear which approach is expected. For example, it could involve combining operations, removing redundant ones, or reordering them for efficiency. The issue provides a general goal but lacks the specifics needed for a clear implementation plan.",
        "label": "VAGUE"
    },
    "django__django-16824": {
        "explanation": "The issue is well-specified because it provides a clear problem description, steps to reproduce the issue, the error traceback, and even suggests a potential solution (coercing each item in e.cmd to string). The issue explains the context (using a PosixPath for the database name in Django settings), how the error occurs (exiting dbshell with Control-D), and what the actual problem is (TypeError due to PosixPath instead of a string). This information is sufficient for a developer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16830": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the specific behavior that is occurring and the desired outcome. The example code provides a clear illustration of the issue and the explanation of the underlying cause and potential solution is given. The context about why the issue is problematic (deadlocks in a multi-threaded MySQL environment) is also provided. All necessary information is present to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16865": {
        "explanation": "The issue is reasonably specified. The problem is that when using the --update option with makemigrations, the custom name provided with --name is being overwritten. The issue includes a clear example of the current behavior and the expected behavior (that --update should respect the --name option). The user also provides additional observations that suggest broader considerations, but the main request is clear enough to form a solution around. The problem is not entirely ambiguous, but there may be some interpretation needed regarding how to implement the fix or whether it is intentional behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16873": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a detailed explanation of the current behavior versus the expected behavior. The reporter has provided a concrete test case that demonstrates the issue, including the specific test failure output. The issue includes a detailed code example showing the template usage and the corresponding test code. This information is sufficient to understand what is wrong and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16877": {
        "explanation": "The issue is reasonably specified. It describes the need for a new template filter called 'escapeseq' which is intended to escape sequences in a similar way that 'safeseq' works in relation to 'safe'. The example usage is provided, and the context (autoescape being off) is mentioned. While there may be some details to work out regarding the exact implementation, the overall goal is clear and a solution can be reasonably inferred from the given information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-16888": {
        "explanation": "The issue is well-specified. The problem is described clearly, including when it was introduced, what the expected behavior was before and after, and what the current problem is. The reporter provided a test case to reproduce the issue and a stack trace which helps to understand where the error is occurring. The reporter also provides their opinion on what the correct behavior should be, which gives a clear direction on how to resolve the issue. All the necessary information is provided to understand the problem and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16899": {
        "explanation": "The issue is well-specified. The problem is clearly described: the error message for readonly_fields in ModelAdmin does not include the field name, unlike other fields such as list_editable, raw_id_fields, etc. The expected behavior is to unify the error message and include the field name to improve clarity. The explanation includes a specific example of the current error message and what the messages for other fields look like. This provides enough information to understand what needs to be changed in the codebase to fix the discrepancy.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16901": {
        "explanation": "The issue is well-specified. It clearly describes the problem with Django's fallback SQL generation for Q objects when XOR is not natively supported, provides the expected and actual behavior with test examples, and references the commit where the issue was introduced. This provides all the necessary information to understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16903": {
        "explanation": "The issue is well-specified. The user has provided a detailed description of the problem, including the model structure, the error encountered, and an analysis of the Django source code that explains the root cause. They also propose a solution by suggesting where the check for default primary keys should be moved in the code. The example with UUIDField and AutoField with a custom default further clarifies the scenario. All these details make it clear what the problem is and how it can be resolved, allowing for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16910": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem, sample models, sample code, and the expected vs actual SQL queries. This information allows a developer to understand the bug and create a PR to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16920": {
        "explanation": "The issue is well-specified. It clearly describes the problem with Django's default field rendering from an accessibility standpoint, provides a detailed explanation of the WCAG requirements being violated, and offers a concrete solution using aria-describedby. The issue includes code examples before and after the fix, explains the expected outcome for screen reader users, and even acknowledges some limitations or unknowns. The information provided is sufficient for an experienced developer to implement the requested change to Django's form rendering to improve accessibility.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16938": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the error message, the code that reproduces the issue, and the expected behavior. The issue relates to a Django serialization problem when using a custom manager with select_related on a many-to-many relationship. The reporter has also provided a code example that demonstrates the problem, and the error traceback is included. This is sufficient for a developer to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16950": {
        "explanation": "The issue is well-specified with the following details provided: the Django and Python versions, a minimal reproducible example with model definitions, admin configuration, and the specific error encountered. The problem is clearly described, including how to reproduce it and the expected vs. actual behavior. The exception traceback is referenced, and the reporter has indicated the observed issue where the 'id' field is set to null when using inlines in the admin. The reporter has also provided a hypothesis that this is a bug in Django. All necessary information for investigation and reproduction is present.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-16952": {
        "explanation": "The issue is well-specified because it provides a concrete example of the problem, including the code changes made and the error that occurs. It clearly shows the scenario where creating an object with nested multi-table inheritance (MTI) causes a crash, and the specific error message is given. This information is sufficient to understand what the problem is and to start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-17029": {
        "explanation": "The issue is well-specified. It clearly identifies the problem (get_swappable_settings_name cache is not cleared by apps.clear_cache()), provides context (usage in django-stubs with mypy runs), references specific code and discussions, and even suggests a solution (add self.get_swappable_settings_name.cache_clear() to clear_cache method). All necessary information is present to implement the proposed fix.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-17046": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including a minimal reproduction scenario, the exact error message, and the conditions under which the error occurs. The issue mentions that using a specific Django version (3.1.8) resolves the error, and it provides a hypothesis about why the error occurs (the use of .distinct() due to the search involving a many-to-many field). This information would allow a software engineer to understand the problem and work on a solution that addresses the issue in the current version of the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-17058": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It describes the problem (PostgreSQL 15 implementing NULLS [NOT] DISTINCT in unique constraints), explains the need for the solution (adding a nulls_distinct option to UniqueConstraint), and provides a clear implementation goal (preserving default backend behavior while allowing explicit setting on supported backends). The issue also includes relevant references to documentation and context (article, SQL standard, forum thread). The proposed solution is specific and actionable for a software engineer to implement.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-17084": {
        "explanation": "The issue is well-specified with clear details on the problem, including the error message, dependencies, and example code. It's clear what the expected outcome is and what the error is, making it possible to work on a solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-17087": {
        "explanation": "The issue is well-specified. It provides a clear example of the problem, including the model code and the resulting incorrect migration. The problem is that when using a class method from a nested class as the default for a field, the migration does not correctly reference the nested class. The desired solution is to ensure that the migration correctly references the nested class method. The steps to reproduce are clear, and the expected outcome is described. Therefore, an experienced developer can understand the problem and create a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-7188": {
        "explanation": "The issue is reasonably specified.  It is clear that the goal is to allow Django projects to use authentication middleware and context processors without having the auth app in their INSTALLED_APPS.  The issue references a discussion thread, which could provide additional context, but it's not strictly necessary to understand the core problem.  The request also includes adding tests, which is a clear direction.  However, there is some ambiguity in how exactly to implement the changes.  For example, it's not entirely clear how to modify the existing code to achieve the desired behavior while maintaining backwards compatibility.  A developer would need to understand the internal workings of Django's authentication system and potentially make changes to multiple components.  Despite this, there is a sensible interpretation of what needs to be done, so the issue is reasonably specified, not vague or impossible to solve.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-7475": {
        "explanation": "The issue is reasonably specified. The user wants to extend the functionality of the 'diffsettings' command in Django's manage.py to allow comparison against a custom settings module rather than just the default Django settings. The user provides a clear example of their desired usage and a rationale for the change (hierarchical settings with multiple inheritance). While the exact implementation details and edge cases are not specified, the general direction is clear enough for a developer to work on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-7530": {
        "explanation": "The issue is reasonably specified. The problem is that the allow_migrate() method is being called with incorrect (app_label, model) pairs during makemigrations, which is causing problems with a custom router. The issue references another ticket and a PR, which implies that there is more context available. While the description gives a general idea of what needs to be fixed, there are some details that would need to be filled in to fully understand the scope of the problem and how to approach the solution. For example, it would be helpful to understand exactly how the incorrect pairs are being generated and what the expected behavior should be.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-8119": {
        "explanation": "The issue is reasonably specified. It describes the need to allow expressions in .filter() calls, which would enable third-party apps to create query syntax extensions and unify the ORM experience. However, some implementation details are missing, such as specific examples of the desired expression syntax, how to handle different types of expressions, and potential compatibility considerations. Despite these gaps, there is a clear direction and understanding of the feature to implement.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-8961": {
        "explanation": "The issue is reasonably specified as it describes the problem with the program name in Django's command-line utility and outlines the specific problems that need to be addressed. However, there are some areas where clarification may be needed, such as the exact approach to replace __main__.py and the handling of manage.py on different platforms. Despite these uncertainties, a sensible interpretation can be made to resolve the issue based on the information provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-9296": {
        "explanation": "The issue is well-specified. The request is to implement the __iter__ method in the Paginator class to allow iteration over all pages using a natural Pythonic approach. The desired functionality is clearly described with a code example showing the intended implementation. The problem and the proposed solution are both clearly defined, making it possible to create a meaningful pull request to address this issue.",
        "label": "WELL_SPECIFIED"
    },
    "django__django-9703": {
        "explanation": "The issue is reasonably specified. The user wants the management command invocation to suggest commands for mistyped commands. The user mentions they often can't remember the full management command name but can remember part of it. This implies that the system should provide suggestions based on partial or misspelled input. While there are some details that need to be filled in (like the exact algorithm for suggesting commands, how suggestions are presented, etc.), there is a sensible interpretation of the requirement. The mention of a patch and screenshot (which are not included here) suggests that the user has a specific idea in mind, and the general direction is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "django__django-9871": {
        "explanation": "The issue is reasonably specified. The problem is clearly described, and the goal is to reorder the output of the --help command to prioritize command-specific arguments. However, there are some missing details about how exactly to implement the reordering, which parts are considered 'boilerplate', and what specific changes are needed in the code. But the general direction is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-13859": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described clearly, with a specific code example that reproduces the crash, and the actual error outcome is stated. A solution would involve identifying why a zero-width figure causes libpng to crash and implementing a fix to handle such cases gracefully.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13908": {
        "explanation": "The issue is well-specified. It provides a clear bug report with a code example for reproduction, shows the actual and expected outcomes with images, and specifies the Matplotlib version and environment. All necessary information for understanding the problem and attempting a solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13913": {
        "explanation": "The issue is well-specified. It provides a clear bug report with a summary, code for reproduction, actual and expected outcomes, and environment details. The problem is that `is_color_like` returns `True` for strings of integers, which are invalid colors for `plt.scatter`. The expected solution is to make `is_color_like` return `False` for these cases. This is clear and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13959": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with examples of what is working and what is failing. The core issue is that the 'c' parameter in the scatter() function is being treated differently than 'x' and 'y' in terms of shape handling. The issue explains that while 'x' and 'y' can be of any shape and will be flattened (as long as they have the same size), 'c' must match the shape of 'x' or 'y', not just the size. It provides specific examples of what works and what fails, which clearly defines the problem. The issue also references a specific pull request and comment for context. This level of detail provides a clear understanding of the problem and what needs to be fixed. Therefore, it is well-specified and ready for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13980": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example in a Jupyter Notebook, and the unexpected behavior of the y-axis limit in polar plots is demonstrated. The user explains why the current behavior is confusing and what they expect instead. The example shows the difference between the 'expected' and 'unexpected' plots, and the printed ylim values provide concrete evidence of the issue. All necessary information for reproduction and understanding is provided.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13983": {
        "explanation": "The issue is well-specified. It includes a clear description of the problem, a minimal working example that reproduces the issue, and even some analysis of the root cause in the code. The user explains that removing a shared axis with the `remove()` method prevents the remaining axis from using unit-provided formatters, while using `fig.delaxes()` doesn't exhibit the same bug. This information gives a clear understanding of what needs to be fixed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13984": {
        "explanation": "The issue is well-specified. The problem is clearly described: the `ax.tick_params` method does not change the color of tick marks on `Axes3D`, only the color of tick labels. A code example is provided that demonstrates the issue, and an image is included to show the actual result versus the expected result. The issue also includes a reference to a StackOverflow question and mentions that this used to work in an older version of the library. This information gives a clear understanding of what needs to be fixed and how to verify the fix.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-13989": {
        "explanation": "The issue is well-specified. The problem is clearly described, with a code snippet for reproduction, the actual and expected outcomes, and the context of the bug being traced back to a specific commit. All necessary information is present to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-14471": {
        "explanation": "The issue is well-specified with a clear bug summary, steps to reproduce, and expected vs actual outcomes. The problem involves a change in behavior in a specific Matplotlib version that causes existing FigureCanvasQT objects to be destroyed when calling plt.figure. The issue includes code for reproduction using 'nexpy' and details about the environment. The explanation provided by the user about where they think the problem might be occurring is also helpful for understanding the issue. This provides enough information for a developer to attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-14623": {
        "explanation": "The issue is well-specified. It provides a clear bug report with a summary, code for reproduction, actual and expected outcomes, and system information. The problem is described in a way that it's clear what the issue is and what the desired behavior should be. A developer would be able to understand the problem and work on a solution without needing additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-17810": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear code example that reproduces the error, and the error message is provided. The issue has been observed with specific versions of the relevant libraries and the environment is described. A solution would involve investigating the interaction between the `animation.save` and `fig.savefig` functions in Matplotlib to determine why they interfere with each other and raise a StopIteration exception. The issue is not vague and there is a clear path to a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-18869": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the current version information in matplotlib is limited to a string `__version__`, and there is a request to add a more comparable version info, either as a tuple `version_info` or a `LooseVersion` instance. The proposed solution is also discussed with some preference mentioned, though there's a slight ambiguity between the two options. However, the core problem and the general direction of the solution are clear. The user is asking for a way to have easily comparable version information, which is a common practice in other packages, as noted in the additional context. The developer can reasonably proceed by implementing either a `version_info` tuple or a `LooseVersion` instance, as both are standard approaches for version comparison in Python. The ambiguity in the preference between the two options is a minor detail that can be resolved during implementation or by checking the project's conventions and community preferences.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-19743": {
        "explanation": "The issue is a feature request for adding constrained_layout support to the `figure.legend` function in a plotting library (likely Matplotlib, given the context). The request is quite brief and only mentions the desire for `constrained_layout` support for `figure.legend`. While the general direction is clear (i.e., enabling `constrained_layout` to work with `figure.legend`), there are no specific details about how this should work, what the expected behavior is, or any examples of current issues when using these together. The implementation details would require understanding how `constrained_layout` currently interacts with `figure.legend`, what the desired outcome is, and any constraints or edge cases to consider. These details are missing, making the issue somewhat vague in terms of what exactly needs to be done to fulfill the request.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-19763": {
        "explanation": "The issue is well-specified because it includes a clear bug summary, steps to reproduce the problem with a minimal code snippet, actual and expected outcomes, and system information. The problem with the multicursor disappearing and high CPU usage on the nbagg backend is described in detail, and there's an indication that it works correctly on the qt backend. The issue even references a related discussion and includes screenshots and a gif for visual context. This provides enough information for a software engineer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20374": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail with a clear explanation of the bug, a minimal example to reproduce it, and a clear expected outcome. The issue provides all necessary information to understand the problem and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20470": {
        "explanation": "The issue is well-specified with a clear problem description, code for reproduction, actual and expected outcomes, and the Matplotlib version. The problem is that the 'label' keyword argument for the 'text' function in Matplotlib is not creating a handle or label for the text in the legend, which is the expected behavior. All the necessary information is provided to understand the issue and create a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20488": {
        "explanation": "The issue is reasonably specified as it provides a test name, the error encountered, and a stack trace that points to the location in the code where the error is happening. The problem seems to be a ValueError in the LogNorm class when a test is run. The error is not consistently reproducible and is suspected to be related to a numpy change. This gives a clear starting point for investigation. However, there is a lack of information on what exactly needs to be changed in the code to fix the issue. One would need to understand the root cause of the ValueError, which could be related to the values of vmin or vmax. Without further information on the expected behavior or the desired outcome, there are some blanks to fill in. However, the interpretation of what is required for a successful solution is still sensible.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-20518": {
        "explanation": "The issue is well-specified because it provides a clear bug summary, code for reproduction, actual and expected outcomes, and the matplotlib version. The problem is that `set_sketch_params()` is being ignored by the PGF backend, and the reporter is working on a fix. This gives enough context to understand the issue and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20584": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user has provided a clear description of the problem, including a minimal working example (MWE) that reproduces the issue, as well as visual evidence of the problem (before and after images). The expected behavior is clearly stated (that 'lc.set_segments(lc.get_segments())' should do nothing), and the actual behavior is described (the result is much coarser). The MWE includes all necessary imports, data generation, and plotting code, and the specific version of matplotlib that exhibits the issue is mentioned. This provides all the information needed to reproduce the issue and understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20676": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear bug summary, code for reproduction, actual outcome, and expected outcome. The code example is minimal and provides a concrete way to reproduce the issue. The expected behavior is also clearly defined by referencing a previous version of the library where the behavior was as expected. This information is sufficient for an experienced software engineer to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20679": {
        "explanation": "The issue is well-specified with a clear problem description, code for reproduction, and expected vs actual outcomes. It explains the behavior change between old and new implementations and provides a specific use case.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20693": {
        "explanation": "The issue is about a deprecation warning when updating the color of a selector in MNE. The user provides code that was previously used and notes that it now emits a deprecation warning. They mention that they looked into related issues and couldn't find an alternative, and suggest a potential workaround. However, the user is unsure if this is the correct solution and notes that it feels like a hack. The issue is reasonably specified because it clearly identifies the problem (deprecation warning), provides context (code example), and indicates that the current workaround is not ideal. However, it leaves some blanks about what the correct replacement code should be and how the selector's properties should be updated without triggering the deprecation warning. The solution would require understanding how the selector's properties are now intended to be modified in the newer version of the library and implementing that correctly. The user is seeking guidance on the correct way to update the code, which is clear, but the exact solution is not explicitly provided in the issue, so some investigation into the library's updated API would be required.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-20805": {
        "explanation": "The issue is reasonably specified, but there are a few things that need to be clarified or inferred. The main problem is that when the spine position is set after the tick_params, the labelrotation is not respected. The code for reproduction is provided, along with the actual and expected outcomes. However, the exact behavior difference between when the spine command is before and after the tick_params is not clearly explained. A potential solution would involve understanding the order of operations in matplotlib for spines and tick_params and ensuring that the labelrotation is applied correctly regardless of the order. The user is asking for suggestions, which indicates that there might be multiple ways to approach the solution, but the core issue is clear enough to attempt a fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-20826": {
        "explanation": "The issue is well-specified. It clearly describes a bug that occurs when using `ax.clear()` with shared axes in matplotlib, and provides detailed steps to reproduce the problem. The issue includes code to reproduce the bug, expected vs actual outcomes (with images), and environment information. This is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-20859": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a bug summary, a minimal code snippet to reproduce the bug, the actual outcome (including an error traceback), the expected outcome, and the environment details. The user even provided a potential fix by changing a specific line in the legend.py file. All these details provide clear information about the problem and what the expected behavior should be. A software engineer can use this information to understand the issue and create a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21042": {
        "explanation": "The issue is well-specified with a clear bug report, code for reproduction, actual and expected outcomes, and environment details. All necessary information is provided for a meaningful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21318": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed bug report, including a minimal code example to reproduce the issue, the actual outcome (error message), expected outcome, and environment details. The error message explains the specific problem: 'adjustable='datalim' is not allowed when both axes are shared'. This gives a clear understanding of the cause and expected resolution. The code for reproduction allows for testing the fix and verifying that it resolves the issue. The comparison with an older version (2.0.2) where the code works also provides context for the change in behavior. All necessary information to understand the issue and implement a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21481": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a concise bug summary, a minimal reproducible example, the actual outcome (error traceback), and the expected outcome. The environment details (operating system, Matplotlib version, backend, and Python version) are also provided. This information is sufficient for a developer to understand the issue, reproduce it, and work on a fix.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21490": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed bug summary, steps to reproduce, actual and expected outcomes, and relevant code examples. The explanation of the current behavior, the proposed solution (copying inputs), and the justification for the change are all provided. This allows for a clear understanding of what needs to be fixed and how to approach the solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21542": {
        "explanation": "The issue is reasonably specified.  The problem is clearly described: old-style format strings are used in colorbar tick formatting, and this is inconsistent with the new-style format strings used elsewhere in the codebase.  The proposed solution is outlined, though it leaves some implementation details to be filled in.  The problem is a code consistency issue, and the solution involves modifying how format strings are handled in the colorbar code to align with the rest of the library.  The proposed solution mentions a possible approach (removing an `if` statement), but also acknowledges that a deprecation cycle might be necessary and suggests an alternative approach involving checking the type of format string in `Axis._set_formatter`.  While the exact implementation path is not fully specified, a competent developer with experience in the codebase could use the information provided to implement a solution that addresses the inconsistency.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-21550": {
        "explanation": "The issue is well-specified for a meaningful attempt at a solution. The bug report includes a clear summary of the problem, a complete and reproducible code example, the expected and actual outcomes, and detailed environment information. The specific versions of matplotlib and other dependencies are mentioned, and the issue is clearly about a regression between two specific versions of matplotlib. This information allows for setting up the environment and reproducing the issue to debug and fix it.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21559": {
        "explanation": "The issue is well-specified because it provides a clear bug summary, a complete code example for reproduction, the actual error output, and the expected outcome. The user is reporting that the 'eventplot' function in matplotlib is not handling multiple datetime.date series as inputs, which results in a TypeError. The code example is self-contained and includes two datetime.date lists passed to 'eventplot', which is sufficient to reproduce the problem. The error traceback is provided, pinpointing the issue to the 'set_positions' method in 'collections.py' where it attempts to sort 'datetime.date' objects and convert them to floats. The expected outcome is also clearly stated: an eventplot with one time series per row on the y-axis. The user also mentions a related issue (#5248) which indicates that this may have been a previously fixed problem that has resurfaced. Given all this information, a software engineer can understand the problem and create a PR to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21568": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described as a change in datetime axis spacing when using usetex in matplotlib version 3.4 compared to 3.3. The issue includes code for reproduction, showing the difference in output between versions. The expected outcome is clearly stated as having the spacing from version 3.3 while using LaTeX formatting. The operating system, matplotlib version, and installation method are also provided, which helps with reproduction and debugging. All necessary information is present to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-21617": {
        "explanation": "The issue is well-specified because it provides a clear bug summary, detailed steps to reproduce the problem, and specific examples of the actual and expected outcomes. It also includes the testing environments and versions of the software involved. The code for reproduction is provided, which is crucial for identifying and fixing the bug. All the necessary information is there for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22719": {
        "explanation": "The issue is well-specified. The user provides a clear bug description, a minimal code example to reproduce the issue, the actual and expected outcomes, and additional context. The problem is a deprecation warning when empty data is passed to an axis with category units. The provided code, error messages, and explanation of the inconsistency in the API make it possible to understand and address the issue. The user also explains why the warning is misleading and suggests that the issue may be due to an unhandled edge case with empty data. This is sufficient information to create a PR that resolves the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22767": {
        "explanation": "The issue is well-specified. The bug is clearly described, with a specific line of code identified as the problem (line 1377) and an explanation of what the default for the indices keyword should be changed to. There is a code snippet provided that can reproduce the issue, along with the actual and expected outcomes. The error message is also included. All of these details make it clear what the problem is and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22835": {
        "explanation": "The issue is well-specified because it includes a clear description of the bug, a reproducible example, the exact error message, and context about the problem. The error occurs when using BoundaryNorm with imshow and hovering over the image, which causes a ValueError due to BoundaryNorm not being invertible. The reporter also suggests possible approaches to fix the issue, such as a special check, a try-except block, or making BoundaryNorm approximately invertible. With this information, a developer can reproduce the issue, understand the root cause, and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22865": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, with a detailed explanation of the bug and how to reproduce it. The expected and actual outcomes are shown with images, and the code for reproduction is provided. The user is using Matplotlib version 3.5.1, which helps in reproducing the issue. All necessary information for reproducing the bug and understanding the desired outcome is present.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22871": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a specific scenario where the ConciseDateFormatter does not show the year when plotting less than 12 months. The issue includes a reproducible code example, actual and expected outcomes, and detailed environment information. This provides all the necessary information for an experienced software engineer to understand the problem, reproduce it, and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22883": {
        "explanation": "The issue is reasonably specified. The problem is that some f-strings are missing the 'f' prefix, which is causing variable interpolation to fail. The user provided an example link to the specific line of code. However, the issue does not specify which particular strings are missing the prefix or how many there are, so some investigation would be needed to identify all affected areas. The solution is generally clear: add the 'f' prefix to the relevant strings. There is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-22926": {
        "explanation": "The issue is well-specified. The user provides a clear description of the bug, including the code to reproduce the problem, the actual outcome (error message), and the expected outcome. They also mention the specific line in the code that is causing the problem and suggest a potential fix (commenting out the line). This provides enough information to understand what needs to be fixed and how to approach the solution. The user also provides information about their environment (operating system, Matplotlib version, Python version).",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22929": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description includes a clear bug summary, specific cases that reproduce the issue, code examples for reproduction, actual and expected outcomes, and additional information about the environment. The user has also provided a potential fix direction by pointing to the specific code section where the error occurs. All necessary information is provided to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-22945": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the bug, including the specific commits where the issue appears (a9dd8b999a74d7cefc92f3c599bee6c11958d05a and 396a010a6147e232d7ab101db9e4b5c6a48d0b36). The code for reproduction is provided, along with the actual and expected outcomes. The error traceback is included, pointing to the specific line causing the problem in the code. The issue also mentions the operating system, Matplotlib version, backend, and Python version, which are all helpful for diagnosing the problem. Although the code may not be fully self-contained, it provides enough information to reproduce the error and understand the context. The problem seems to be related to the use of `fig.tight_layout()` within the `_init_anim` function, which is causing an AttributeError because it's trying to access an attribute of a NoneType object. Therefore, the issue is well-specified, and a solution can be attempted based on the provided information.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23031": {
        "explanation": "The issue is well-specified with a clear summary of the problem, relevant code examples, and a proposed direction for the solution. The problem revolves around ensuring that matplotlibrc and style files are read with UTF-8 encoding instead of the locale encoding, as the current implementation fails with non-ASCII encodings. The example test case and error traceback highlight the current limitations and the motivation for the change. While the proposed fix is not explicitly detailed, the context and reasoning are sufficient for an experienced software engineer to implement a meaningful solution. The discussion around encoding cookies provides an optional path, but the core requirement (specifying UTF-8) is clear.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23057": {
        "explanation": "The issue is well-specified with a clear bug summary, steps to reproduce, actual and expected outcomes, and additional context. The regression was traced to a specific commit, and the problem is described across multiple backends. The provided code sample allows for testing and verifying the fix, and the environment details help ensure accurate replication. All necessary information is present for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23088": {
        "explanation": "The issue is well-specified. It provides a clear bug summary, steps to reproduce the problem, the actual and expected outcomes, and additional context. The user explains that an error occurs when plotting a dataframe with a typo in the column header, resulting in a confusing error message about formatting instead of a KeyError. The provided code snippet is sufficient to reproduce the issue. The expected outcome is to get a more informative error message or a warning when a KeyError occurs. The issue also includes the relevant code section and mentions the specific versions of the software involved. All the necessary information is present to understand the problem and to work on a solution. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23174": {
        "explanation": "The issue is well-specified with a clear bug summary, steps to reproduce the problem, the actual outcome including an error traceback, and the expected outcome. The code example provided is sufficient to reproduce the issue, and the problem is clearly defined as a crash when adding clabels to subfigures in a specific version of Matplotlib. The error traceback pinpoints the issue to a missing attribute in the SubFigure object, which gives a clear direction for the solution. Therefore, it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23188": {
        "explanation": "The issue is reasonably specified. The problem is that the default date limits are causing issues when day tickers are added without specifying limits. The proposed fix is to change the default date limits to a specific range that would make the float conversion more manageable. The explanation provided gives enough context for an experienced developer to understand what needs to be done, but there may still be some details to figure out, such as exactly where in the codebase the default date limits are set and how to implement the proposed change. The mention of specific test failures also provides a way to verify the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-23267": {
        "explanation": "The issue is reasonably specified.  The problem is clearly described, including a code example that demonstrates the inconsistency in behavior when using the 'location' keyword argument with automatically created Axes versus manually created Axes. The proposed solution is also outlined, suggesting the addition of a 'location' keyword argument to the Colorbar constructor that would set both 'orientation' and 'ticklocation' and be mutually exclusive with those parameters.  While some details about the implementation might need to be worked out, the general direction and the expected outcome are clear.  A software engineer with knowledge of the codebase and the matplotlib library would be able to make a meaningful attempt at a solution based on this information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-23299": {
        "explanation": "The issue is well-specified. It includes a clear bug summary, code for reproduction, actual and expected outcomes, and relevant environment information. The problem is described in enough detail to understand what the expected behavior should be and how to reproduce the issue. A developer would be able to use this information to investigate and fix the bug in the get_backend() function related to clearing figures created under an rc_context.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23314": {
        "explanation": "The issue is well-specified with a clear problem description, a reproducible example, and expected vs actual outcomes. The code example provides all the necessary information to reproduce the bug in the specified environment. The problem statement is straightforward, making it possible to understand what the solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23412": {
        "explanation": "The issue is well-specified. The description includes a clear bug summary, code for reproduction, actual and expected outcomes with visual examples, and additional information such as the operating system, matplotlib version, and backend. All necessary details are provided to understand and reproduce the bug, making it possible to work on a solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23476": {
        "explanation": "The issue is well-specified with a clear bug description, steps to reproduce, actual and expected outcomes, and additional context. The provided code allows for replication of the problem, and the specific conditions (M1 Mac, Matplotlib 3.5.2, MacOSX backend) are outlined. The expected fix is to prevent the DPI from doubling upon unpickling to avoid the overflow error.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23562": {
        "explanation": "The issue is well-specified because it provides a minimal example that reproduces the error, includes the exact error message with traceback, and specifies the versions of the library where the issue was tested. The problem is clearly described as an AttributeError for '_facecolors2d' in 'Poly3DCollection' object. All necessary information for diagnosing and potentially solving the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23563": {
        "explanation": "The issue is reasonably specified as it provides a clear description of the bug, the steps to reproduce it, and the expected vs. actual outcomes. The code sample is provided, and it includes the error traceback, which can help in diagnosing the problem. However, there are some gaps in the information, such as the exact shape and data type of the numpy arrays being used, and the specific changes that cause the error to persist after the first run. These details could be important for understanding the root cause and ensuring a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-23742": {
        "explanation": "The issue is reasonably well-specified, but there are some missing details that would need to be filled in during the solution process. The issue clearly describes a bug related to toolbar instantiation in a notebook environment, provides a specific error traceback, and includes relevant environment information (matplotlib version, python version, etc.). However, the problem appears to be in a specific combination of libraries (MNE-Python, traitlets, matplotlib) and the solution would require understanding of how these libraries interact. The issue mentions that a minimal working example (MWE) will be provided \"tomorrow\" but that hasn't been included yet. Without the full context of the MNE-Python codebase and the specific code that's causing the error, there are some blanks to fill in. The error message indicates a trait validation issue where the expected toolbar type doesn't match the actual type being passed. This suggests the solution will involve understanding the traitlets validation and how the toolbar is being created/used in the MNE-Python codebase. The issue provides enough information to understand what's wrong and what the expected outcome is (no error), but there are implementation details that would need to be worked out during the solution process.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-23964": {
        "explanation": "The issue is well-specified. It includes a clear bug summary, a code snippet for reproduction, the actual and expected outcomes, and additional information such as the affected operating system, matplotlib version, and a potential fix. All necessary details are provided to reproduce the issue and understand what the solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-23987": {
        "explanation": "The issue is well-specified. It clearly describes the bug, provides a code snippet for reproduction, states the actual and expected outcomes, and includes relevant environment details. A developer can use this information to investigate why the UserWarning is being triggered even when constrained_layout is set to False and implement a fix. The provided code is straightforward and should allow for consistent reproduction of the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24013": {
        "explanation": "The issue is about function shadowing its own module in matplotlib, specifically with the tripcolor function and module. The reporter explains the problem in detail, provides examples of the behavior, and suggests a solution (renaming the submodule). They also ask if this is a general concern and if there's a desire for obj.__module__+obj.__name__ to give a valid fully qualified name. The problem is clear, the reporter understands what they are describing, and the suggested solution is specific. There is a clear goal to achieve - to have non-clashing names so that obj.__module__+obj.__name__ works as expected. Therefore, this issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24026": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The user is reporting that `stackplot` in matplotlib is causing an error when trying to use the 'Cn' color references, which are typically used for the Axes color cycle. The issue description includes a clear example of the problem, including the error message and a sample script that reproduces the issue. The problem is that `stackplot` is changing the Axes' color cycle, which breaks the expected behavior of keeping the color synchronization across different plot types. The goal is to modify the `stackplot` function so that it does not change the Axes' color cycle in a way that causes errors with 'Cn' references. This is a specific and well-defined problem with a clear test case and expected outcome, making it well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24149": {
        "explanation": "The issue is well-specified. It includes a clear bug summary, steps to reproduce the problem, the actual and expected outcomes, and some additional debugging information. The issue is about the `ax.bar` function raising an exception when passed all-nan data in matplotlib 3.6.1, which breaks seaborn's histogram function. The code for reproduction is provided, along with the traceback of the exception and the expected behavior from the previous version (3.6.0). The additional information includes some test cases that demonstrate the specific condition under which the error occurs. All these details make it clear what the problem is and what the desired solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24177": {
        "explanation": "The issue is well-specified with a clear bug description, steps to reproduce, and expected vs actual outcomes. The provided code and repository allow for testing and verification. The problem is clearly defined: when using histtype='step' with density=True, the y-axis scale is not adjusted correctly. This is sufficient for creating a PR to fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24189": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear bug summary, a minimal code example to reproduce the problem, the actual error message, the expected outcome, and additional context about why the issue occurs. The problem is described as a bug in the subplot_mosaic() function of matplotlib when using width_ratios with nested mosaic layouts. The issue also includes a detailed error traceback and information about the expected behavior, which is to create a plot with specific layout ratios. The user also provides their analysis of the problem and suggests potential solutions (either implementing the feature for nested lists or improving the error message). The issue includes all necessary information about the environment (operating system, matplotlib version, python version, etc.). This level of detail makes it possible to understand what the bug is, how to reproduce it, what the expected behavior should be, and what potential solutions might look like.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24257": {
        "explanation": "The issue is reasonably specified. It suggests documenting how to distribute style files as Python packages and creating a template package. While there are some details to work out, the main goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-24334": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reference to the function's documentation and a specific example. The proposed solution is also clear, indicating that kwargs should be checked for validity in all cases. This provides sufficient information to understand the problem and implement a solution. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24362": {
        "explanation": "The issue is well-specified. The user provides a clear description of the bug, including code to reproduce the issue, the actual and expected outcomes, and a suggested fix. The problem is that using 0 or 1 as values for sharex/sharey in subplots is not working as expected, raising an error instead of being interpreted as boolean values. The user's suggested fix is to modify the type checking in gridspec.py to accept 0 or 1 as valid boolean representations. This is a specific and actionable problem with a clear goal: to make 0 and 1 be treated as False and True respectively in the sharex/sharey parameters. The error message is also provided, which helps in understanding where the issue is occurring. All the necessary information to reproduce and fix the issue is provided, making it well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24431": {
        "explanation": "The issue is well-specified. The user is asking to allow a list of alpha values for the eventplot function in matplotlib, similar to how a list of colors is allowed. The problem is clearly demonstrated with a code example showing that using a list of colors works, but a list of alpha values throws an error. The error traceback is provided, showing that the alpha parameter expects a float or None, not a list. The goal is clear: modify the eventplot function to accept a list of alpha values, one per event line, like the color parameter does. The necessary context (matplotlib version, Python version) is also provided.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24538": {
        "explanation": "The issue is reasonably specified. The problem is about the lack of documentation for the 'legendHandles' attribute in the Legend class of the matplotlib library. The user is asking for documentation of this attribute or a getter method for it. While the request is clear, there might be some blanks to fill in regarding the exact details of how the documentation should be structured or if a getter method should be implemented. However, a sensible interpretation would be to document the 'legendHandles' attribute and possibly add a getter method or improve the existing documentation to make it more discoverable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-24570": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The issue clearly describes a bug in the `align` parameter of `HPacker`, where `top` and `bottom` seem reversed. It provides a code example for reproduction, shows actual and expected outcomes with images, and specifies the Matplotlib version. With this information, a developer can reproduce the issue, understand the expected behavior, and work on a fix. All necessary information is provided to investigate and resolve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24604": {
        "explanation": "The issue is reasonably specified.  It clearly outlines a problem with the current API when trying to use subplot_mosaic with different projections and proposes a solution involving a new method (gridspec_mosaic) that would return subplot specs.  The benefit of this approach is explained, and example usage is provided.  While there might be some details to work out regarding the implementation of gridspec_mosaic and how it integrates with the existing API, the overall direction and goals are clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-24619": {
        "explanation": "The issue is well-specified with a clear bug description, steps to reproduce, expected vs actual outcomes, and even suggested fixes. This allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24627": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a specific example and the expected behavior. It explains that when an artist is removed from axes using 'remove()', the '.axes' attribute is set to None, but when 'cla()' is used, it is not. The issue provides a test case that demonstrates the current behavior and indicates the desired outcome. A solution would involve modifying the 'cla()' and 'clf()' functions to also unset the '.axes' and '.figure' attributes of deparented artists, similar to what happens with 'remove()'.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24637": {
        "explanation": "The issue is well-specified. The user provides a clear description of the problem: the gid set on an AnnotationBbox is not being passed to the SVG renderer. They provide a detailed example with code that reproduces the issue, including the expected behavior (the gid should be included in the SVG output) and the actual behavior (it is missing). They also reference a related pull request that may be relevant and provide their environment details. All the necessary information is present to investigate and potentially fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24691": {
        "explanation": "The issue is reasonably specified. It describes the current problem (not being able to set facecolor and edgecolor alpha separately), provides an example of how the user is currently working around the issue, and proposes a solution (allowing alpha to take a tuple for patch methods, similar to prior art in imshow). The example image helps to visualize the desired outcome. While there are some details that would need to be worked out during implementation (like the exact API design and how it integrates with existing code), the core idea is clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-24768": {
        "explanation": "The issue is well-specified because it includes a clear bug summary, code for reproduction, actual and expected outcomes, and additional information about the root cause and affected versions. The problem is described in detail, making it possible to understand what needs to be fixed. The error traceback and environment details also help in diagnosing and resolving the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24849": {
        "explanation": "The issue is well-specified. It includes a clear bug summary, code for reproduction, the actual and expected outcomes, and even a suggestion for a fix. The problem is clearly defined, and it's clear what the expected functionality should be. A software engineer would be able to understand the problem and the desired solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24870": {
        "explanation": "The issue is well-specified. It describes the problem of using the contour() function with boolean 2D arrays and the current behavior of drawing multiple levels when only a single level at 0.5 should be used. It provides a specific example with code and a visual comparison, and proposes a clear solution of autodetecting boolean inputs and setting the default levels to [0.5]. The comparison to imshow's behavior gives an idea of how this could be implemented. There is a clear understanding of what needs to be changed and how to verify the solution. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24924": {
        "explanation": "The issue is well-specified with a clear bug description, reproduction steps, actual and expected outcomes, and even a suggested fix. The provided code example makes it easy to reproduce the problem. All necessary information for understanding and solving the bug is present.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-24970": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce the bug, and expected outcome. The deprecation warnings from NumPy 1.24 when using matplotlib's get_cmap() function with a specific data type are clearly outlined. The provided code is straightforward and the warnings are explicitly shown. This gives enough information to investigate the cause and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25027": {
        "explanation": "The issue is reasonably specified as it outlines the problem with `pcolor` not supporting RGB(A) arrays, references a related fix in `pcolormesh`, and mentions the dependency on another PR (#25027). However, there are some blanks to fill in about the exact implementation details of how to add the RGB(A) logic to `pcolor`. A developer would need to study the changes made in #25027 and the existing logic for handling RGB(A) in `pcolormesh` to determine how to adapt it for `pcolor`. While the general direction is clear, the specific code changes required are not detailed, leaving some room for interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-25052": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The user is reporting a documentation inconsistency in matplotlib where the `bbox` parameter for `matplotlib.axes.Axes.table` is described as requiring an instance of `matplotlib.transforms.Bbox`, but in practice, it expects a list of bounds (e.g. [1, 1, 1, 1]) which is similar to the `from_bounds()` method of Bbox. The error traceback confirms this discrepancy and the user provides a clear suggestion for improvement. A solution would involve updating the documentation to reflect the actual expected input format for the `bbox` parameter.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25122": {
        "explanation": "The issue is well-specified because it clearly describes the bug in the `mlab._spectral_helper` function related to the incorrect use of `np.abs` when applying a window function. It provides the exact lines of code where the bug occurs, a comparison with the correct implementation in SciPy, and a reproducible example that demonstrates the discrepancy. The expected and actual outcomes are clearly defined, which gives a clear target for the fix. Additionally, the issue references the specific version of Matplotlib and explains why the `np.abs` is problematic for windows with negative values like `flattop`. All the necessary information is present to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25126": {
        "explanation": "The issue is well-specified. The bug is clearly described, and there is a complete code snippet for reproduction, as well as actual and expected outcomes provided. The versions of the operating system, matplotlib, and other relevant software are also specified, which is helpful for understanding the environment in which the issue occurs. All necessary information to understand, reproduce, and potentially fix the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25281": {
        "explanation": "The issue is well-specified. It describes a bug where invalid non-string values for the 'loc' argument in the 'legend' function are not validated until 'show()' is called. It provides clear steps to reproduce the bug, shows the actual and expected outcomes, and even points to the relevant code section. This information is sufficient to understand what the problem is and what the expected solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25287": {
        "explanation": "The issue is well-specified. The description includes a clear bug summary, steps to reproduce the issue, the actual and expected outcomes, and even a patch that seems to fix it for simple use cases. The problem is that the offset text is being colored based on 'tick.color' instead of 'tick.labelcolor'. The code for reproduction is provided, making it straightforward to test and verify any potential fixes. The provided patch gives a direction on how to approach the solution. Therefore, with this information, a meaningful attempt at a solution is possible.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25311": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a code example that reproduces the bug, an explanation of the actual and expected outcomes, and relevant environment information. This provides all the necessary context to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25332": {
        "explanation": "The issue is well-specified. It includes a clear bug summary, a minimal code example to reproduce the issue, the actual and expected outcomes, and additional context such as the operating system and Matplotlib version. The problem is defined as a failure to pickle a figure after using `align_labels()`, with a specific error message provided. All necessary details for reproducing and addressing the issue are included, making it possible to understand and resolve the problem without further information.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25346": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described, with code to reproduce the issue, an image showing the actual outcome, and a description of the expected outcome. All necessary information is provided for a developer to understand the issue and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25404": {
        "explanation": "The issue is reasonably specified as it provides the error message, a summary of the problem, and a proposed fix. However, there is some ambiguity about the exact implementation details of the set_props function and how the comment symbol should be placed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-25425": {
        "explanation": "The issue is reasonably specified. The problem is explained with context about a previous change and the inconsistency with the numpy API. The proposed solution includes two possible options (adding get_shape as an alias for get_size, or making get_shape return self._A.shape including more information), but no single clear solution is provided. A developer would need to understand the codebase and make some decisions about the best approach, but the general goal (making the API more consistent with numpy) is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-25430": {
        "explanation": "The issue is well-specified. The problem is clearly described, with a reproducible example, an explanation of the actual outcome (including the error message), and an expectation of what the outcome should be. The issue relates to the use of the 'metadata' keyword argument with the 'savefig' function when saving a file with a '.jpg' extension, which results in an error because 'metadata' is not a recognized argument for 'FigureCanvasAgg.print_jpg()'. A solution would involve either modifying the code to handle the 'metadata' argument for JPG files, ignoring the argument for JPG files, or providing a more informative error message. The specifics of the solution are clear and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25433": {
        "explanation": "The issue is well-specified because it includes a clear bug summary, a complete code example for reproduction, a description of the actual and expected outcomes, and detailed system information. The problem is reproducible with the provided code, and the expected behavior is clearly defined. All necessary information is present to understand and attempt to resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25442": {
        "explanation": "The issue is well-specified with a clear bug description, steps to reproduce, actual and expected outcomes, and additional context including versions and environments. All necessary information is provided for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25479": {
        "explanation": "The issue is well-specified. The user has provided a detailed example that demonstrates the problem with the colormap name handling in matplotlib. They've included the exact error message, a code snippet that reproduces the problem, and an explanation of what they expected to happen. The problem is clearly described as a discrepancy between the name used when registering the colormap and the name that's actually used when trying to access it. The user also explains the confusion this caused when importing colormaps from other modules. This information is sufficient for a developer to understand the issue and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25498": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem of updating a colorbar after changing the norm instance of the colorbar. The issue provides a reproducible example with the code snippet and the error output when using the `update_bruteforce` method. The expected outcome is also implied - to find a way to update the colorbar correctly without encountering the ZeroDivisionError exception.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25547": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes two distinct bugs related to handling NaN values in Matplotlib functions. For each bug, the issue provides code for reproduction, expected and actual outcomes, and stack traces. The first part describes a UserWarning inconsistency in scatter plots with all-NaN and partial-NaN color arrays. The second part describes a StopIteration error in ax.errorbar with all-NaN yerr. Both issues have clear examples and context about what is happening versus what is expected. The issue also provides environment information (matplotlib version, python version, etc.) which is important for debugging. The request is to fix these inconsistent behaviors - making them well-defined problems with clear acceptance criteria.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25565": {
        "explanation": "The issue is well-specified with a clear bug report, including code for reproduction, the actual and expected outcomes, and an analysis of the problem. The provided code allows for reproducing the issue, and the explanation describes the root cause and a potential fix. This makes it possible to understand what the solution should achieve and how to test it. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25624": {
        "explanation": "The issue is well-specified because it includes a clear bug summary, a code example for reproduction, and details about the Matplotlib version. The problem is that the kwargs in tight layout are not having the expected effect when the rcParams 'figure.autolayout' is set to True. This is a specific and reproducible issue that can be addressed with a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25631": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: using `bbox_inches='tight'` with `grab_frame()` in the FFMpegWriter results in an unexpected outcome (a 'snowflake movie'). A complete code example for reproduction is provided, along with clear descriptions of both the actual and expected outcomes. The issue is specific to the `grab_frame()` method when `bbox_inches='tight'` is used. This information is sufficient for a software engineer to investigate the issue, understand how `grab_frame()` and `bbox_inches='tight'` interact, and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25667": {
        "explanation": "The issue is well-specified. It clearly describes a bug in the bar/barh functions of matplotlib where datetime units are not being properly recognized. The issue includes a code snippet to reproduce the issue, shows the actual and expected outcomes with images, and even provides a workaround. All necessary information to reproduce and understand the problem is present. The main task would be to modify the bar/barh functions to check for datetime units in the bottom/left parameters and apply the appropriate converter.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25712": {
        "explanation": "The issue is well-specified with a clear bug summary, code for reproduction, actual and expected outcomes, and additional context. The problem is described in sufficient detail to understand what the issue is and how to reproduce it. The code example provided is minimal and complete, and the expected outcome is clearly defined. The additional information provided also helps to understand the root cause of the issue. Therefore, it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25772": {
        "explanation": "The issue is reasonably well-specified. It describes a specific error when using the `%matplotlib qt` magic command in VS Code's interactive mode, which results in an ImportError related to Qt bindings. It provides a detailed error trace, steps to reproduce the issue, and relevant environment information including OS, Python version, and package versions. While some additional context about the expected behavior and the exact conditions under which this occurs could be helpful, the information provided is sufficient to understand the problem and begin investigating a solution. The main challenge would be to determine why the Qt bindings are not being correctly recognized or imported in this specific environment and usage scenario.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-25775": {
        "explanation": "The issue is well-specified. It clearly identifies the problem with Text objects not having get/set_antialiased methods like other artists. It proposes a solution to add these methods and adjust annotations if needed. The scope is reasonably defined, and the implementation challenge is mentioned. A software engineer with knowledge of the codebase can use this information to implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-25794": {
        "explanation": "The issue is reasonably specified. The problem is described as the precedence of singular forms over plural forms in `plt.scatter` when both are specified, causing confusion for downstream libraries and users. The proposed solution suggests raising an error when both forms are used. There is a clear understanding of the problem and a reasonable direction for the solution, though there are some open questions about the reasoning behind the existence of plural forms and the extent of the changes required. The mention of prior art and the general approach in matplotlib for similar situations adds context but does not fully clarify all implementation details. However, a meaningful attempt at a solution is possible with this information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-25859": {
        "explanation": "The issue is reasonably specified. The problem is clear: the `add_axes` method is accepting arbitrary positional parameters (`False, 1` in the example) which is not readable and seems to be non-intuitive. The reporter is suggesting a fix that involves either documenting the behavior clearly or deprecating extra positional parameters if they don't have any purpose. However, the issue does not explicitly specify which approach (documentation or deprecation) should be taken, leaving that decision to the implementer. This requires some interpretation, but the general direction is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-25960": {
        "explanation": "The issue is well-specified. It provides a clear bug summary, a minimal code example for reproduction, the actual outcome, and the expected outcome. It also includes the relevant OS, software versions, and backend information. All these details allow for a meaningful attempt at a solution without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26011": {
        "explanation": "The issue is about a bug in matplotlib where the 'xlim_changed' callback is not being triggered on shared axes when the change is induced by another shared axis. The problem is clearly described with a code example and the user has even provided some analysis and a potential solution. The user is asking if there is a good reason for the current implementation and suggests a possible fix. The issue is well-specified because it includes the bug summary, relevant code snippet, and the user's observations. There is a clear understanding of what the problem is and what the expected behavior should be. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26020": {
        "explanation": "The issue is well-specified with a clear problem description, a minimal code snippet for reproduction, and a detailed error traceback. It explains the root cause (a difference in behavior of the `axis` attribute between `mpl_toolkits.axes_grid1.mpl_axes.Axes` and `GeoAxes`) and points to the specific function where the error is raised. This provides enough information for an experienced software engineer to understand the issue and create a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26024": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem clearly states that certain mathematical operators are missing from the `tex2uni` mapping in `_mathtext_data.py`. The proposed solution lists the Unicode code points (in hex) of the missing operators and provides references to look up their corresponding symbols and LaTeX names. Additionally, it gives guidance on which symbols should be prioritized for inclusion, such as those in standard LaTeX and those from AMS. The task is to add these missing entries to the mapping in the codebase. This is a concrete task with clear instructions and resources for lookup. The only potential ambiguity is the interpretation of 'be a bit discriminate when adding these,' but the guidance toward standard LaTeX and AMS symbols provides a clear direction.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26078": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear bug summary, code for reproduction, actual and expected outcomes, and a detailed explanation of the problem and potential solution. The issue is related to the handling of units in parasite axes in Matplotlib, and the reporter has already identified the cause of the issue and provided a potential fix. All necessary information is provided to understand and solve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26101": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem with a code snippet for reproduction, and it describes the expected outcome. However, the exact method to achieve the center alignment of mathtext markers is not specified. The solution might require understanding the internal workings of Matplotlib's mathtext rendering and how markers are positioned, which are not detailed in the issue. There are some blanks to fill in about the technical approach, but the overall goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-26113": {
        "explanation": "The issue is well-specified with a detailed bug report including code for reproduction, actual and expected outcomes, and references to relevant code sections. The reporter clearly explains the problem and even suggests a resolution, making it clear what needs to be fixed in the codebase. The code examples provided allow for precise identification of where the behavior differs based on the presence of the C parameter. The reporter also understands the underlying issue and provides context from the code history. This level of detail makes it possible to directly address the inconsistency in the hexbin function's behavior.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26122": {
        "explanation": "The issue is about changing the behavior of the `imshow()` function in Matplotlib when a `transform` is provided. It explains that currently, `imshow()` sets the axes aspect to equal by default, which affects the scaling of the image in data coordinates. However, when a `transform` is passed that is not the default `ax.transData`, this behavior is problematic because the image is no longer in data coordinates and the aspect should not affect the relative sizes of x- and y-data. The proposed change is to make the default `aspect=None` mean 'don't modify the aspect' when a non-default `transform` is used. The issue also references related tickets (#14057, #14117) and acknowledges that this change would introduce non-obvious interactions between parameters. The explanation is detailed and provides context, reasoning, and potential consequences of the change. While there is a discussion about the trade-offs of the proposed change, the core issue is clearly defined: to modify the behavior of `imshow()` when a non-default `transform` is used to prevent it from modifying the axes aspect. The problem is well-understood, and the desired outcome is specific enough to guide a solution. The technical details are sufficient to understand what needs to be changed in the codebase. The only ambiguity is the exact implementation of how to detect when a transform contains `transData` as a branch, but this is mentioned as a reference to another issue (#13642) which likely contains more details. Overall, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26160": {
        "explanation": "The issue is reasonably well-specified as it clearly describes the problem and the desired outcome. It explains that the current implementation of axline() does not allow for the modification of its control points and slope after instantiation. The issue also suggests a solution approach by mentioning the addition of setters for specific properties. However, there are a few areas that require interpretation and decision-making on the part of the developer. For example, the issue states that it might be sufficient to not allow setting xy2 if slope is set and vice versa, but it does not specify which one should take precedence or how to handle conflicts. Additionally, the issue mentions that changing xy1/xy2 is needed for a use case, but it does not provide specific details about this use case. Despite these minor ambiguities, the overall goal is clear and the proposed solution is feasible. A developer with experience in the codebase should be able to interpret the requirements and implement the necessary changes. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-26184": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear bug summary, steps to reproduce, actual and expected outcomes, and additional information. The provided code examples allow for reproducing the issue, and the expected solution is to resolve the warning related to constrained_layout not being applied when using AnnotationBbox. The additional information also suggests a workaround (set_in_layout(False)) which provides insight into the desired behavior.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26208": {
        "explanation": "The issue is well-specified. It clearly describes a bug in Matplotlib where the data limits (dataLims) of the first axis get changed to \u00b1inf when a stackplot is used on the second axis in a twin x-axis chart. The issue includes a code snippet for reproduction, the actual and expected outcomes, and additional information such as the operating system, Matplotlib version, backend, Python version, and more. All the necessary information to reproduce and understand the bug is provided. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26232": {
        "explanation": "The issue is well-specified. The problem is clearly described as a bug where pcolor fails when using read-only masked arrays. There is a code snippet for reproduction, the actual and expected outcomes are clearly stated, and the stack trace is provided. The issue also points to the relevant code in the repository that needs fixing. All necessary information for diagnosing and fixing the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26278": {
        "explanation": "The issue is about improving the handling of keyword arguments (kwargs) in the ContourSet class of a plotting library (likely matplotlib). The problem is that while other plotting functions pass kwargs to their underlying artists/collections, contour/contourf functions do not do this, making it difficult to apply clipping paths directly via a keyword argument. The issue provides a clear explanation of the problem (with code examples showing what works and what doesn't), the current workaround, and a suggested solution (either adding a set_clip_path method to ContourSet or overhauling how kwargs are passed to be consistent with other functions). While there is some discussion and suggestions, the core issue is well-defined: contour/contourf kwargs are not being passed to collections, unlike other plotting functions, and the reporter wants them to behave consistently. There are some details to decide (like the exact implementation) but the goal is clear. This is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-26285": {
        "explanation": "The issue is reasonably specified.  The user is reporting a bug where a specific function call to `set_yticks` is raising a confusing error message.  The issue includes a code snippet that reproduces the error, the exact error message, and the user's expectations.  While there are some missing details about the environment, the core problem is clear enough to attempt a solution.  The solution might involve improving the error message or adjusting the function to handle the keyword arguments more gracefully.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-26291": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce the bug, the actual and expected outcomes, and detailed environment information. All necessary details are provided to understand and address the issue with the `inset_axes` function.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26300": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear bug summary, steps to reproduce the issue, expected and actual outcomes, and additional information about the environment and context. The user even suspects the specific commit that introduced the issue and suggests a potential fix direction. All of this provides sufficient information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26311": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a bug summary, reproduction code, actual outcome (including a traceback), expected outcome (with a reference to an image), and even a proposed fix via a commit reference. The additional information also explains challenges with testing and provides context about the operating system, software versions, and backend. All the necessary information is present to reproduce the issue and understand what the expected fix should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26342": {
        "explanation": "The issue is reasonably specified. The problem is clearly described as a workaround in the Cartopy library where paths on a ContourSet are being replaced in an undesirable way. The proposed solution is also provided, suggesting the use of a set_paths method. While there is some room for interpretation in how exactly to implement the set_paths method, the general direction is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "matplotlib__matplotlib-26466": {
        "explanation": "The issue is well-specified. The bug is clearly described with a detailed explanation of the problem, a reproducible code example, the actual outcome (with an image), expected outcome, and environment information. The problem is about an annotation arrow position being updated when the array passed to it is modified, and it's suspected that the library is keeping a reference to the array instead of making a copy. The code example demonstrates the issue and even includes a workaround (using .copy()) that helps identify the problem. All necessary information is provided to understand and reproduce the bug, making it clear what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "matplotlib__matplotlib-26469": {
        "explanation": "The issue is well-specified. It clearly states the problem (PdfPages generates invalid PDF files when no figures are added), provides background information on why this is an issue, and suggests a solution (change the default value of keep_empty to False and eventually deprecate the parameter). The issue also explains the current behavior, the proposed change, and even hints at potential deprecation strategies. All necessary information to understand what needs to be done is provided.",
        "label": "WELL_SPECIFIED"
    },
    "mwaskom__seaborn-2457": {
        "explanation": "The issue is reasonably specified. It describes a specific scenario where the lineplot function is being called with ci=None, and it should trigger a warning and reformat the arguments to use errorbar=None. The expected behavior is clear - a warning should be issued and the arguments should be adjusted. However, there may be some implementation details that need to be filled in, such as the exact wording of the warning message and the internal process of reformatting the arguments. Despite these minor details, the overall goal and expected outcome are clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "mwaskom__seaborn-2766": {
        "explanation": "The issue is well-specified as it provides a clear problem description, a specific error message, and the context in which the issue occurs. It also references a potential fix (#2466) and suggests a possible solution (releasing a new patch version). All necessary information is provided for someone to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "mwaskom__seaborn-2853": {
        "explanation": "The issue is well-specified because it clearly states that the x_estimator error bars should now inherit the alpha parameter from scatterplot settings, similar to how the x_estimator bars do. It references a specific GitHub issue (#2538) and explains the problem and the proposed fix. There's enough information to understand what needs to be done: making the error bars' alpha value consistent with the scatterplot's alpha when using x_estimator. The reference to a specific issue also implies that there's more context available for the developer to review if needed.",
        "label": "WELL_SPECIFIED"
    },
    "mwaskom__seaborn-3010": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem and a traceback. It shows that PolyFit is not handling missing data (represented by None in the input data) correctly, which leads to a LinAlgError when trying to perform a polynomial fit. The example code, the error message, and the traceback all indicate the problem area and the expected behavior. However, the exact method of handling missing data (e.g., interpolation, exclusion, imputation) is not specified, so some assumptions would need to be made in the solution. This is a reasonable assumption to make since the most common approach is to exclude missing data.",
        "label": "REASONABLY_SPECIFIED"
    },
    "mwaskom__seaborn-3069": {
        "explanation": "The issue is reasonably specified but has some blanks to fill in. The description provides a clear goal of making nominal scales behave like categorical scales in seaborn with three specific behaviors. It also outlines some implementation considerations and potential challenges. However, it lacks specific details on exactly how to implement these changes (like code locations, exact APIs to use), and there are open questions about how to handle theme deferral and user overrides. A developer could make reasonable assumptions to implement the core functionality, but would need to make some decisions about implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "mwaskom__seaborn-3187": {
        "explanation": "The issue is well-specified because it clearly describes the problem, provides a reproducible example, and even suggests where in the code the issue may be originating from. The user explains that the ScalarFormatter is not including the multiplicative offset value in the legend for large number ranges and provides an example using a specific version of the software. The example shows the wrong behavior and the user believes the issue is due to not using the offset value of the ScalarFormatter. The user also mentions the relevant rcParam settings that may be involved. All of this information gives a clear understanding of the problem and what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "mwaskom__seaborn-3190": {
        "explanation": "The issue is well-specified. The problem is clear: passing boolean data to the color parameter in the Plot function causes a TypeError due to attempting to subtract boolean values. The provided code example, traceback, and specific error message give enough information to understand the issue and start working on a solution. The solution would involve handling boolean data correctly in the color mapping process, perhaps by converting it to a numeric type before performing operations that require subtraction.",
        "label": "WELL_SPECIFIED"
    },
    "mwaskom__seaborn-3394": {
        "explanation": "The issue is well-specified with a clear description of the problem, a reproducible example, and an expected behavior. The user explains that using pd.NA causes axis ordering to reverse, provides a workaround with np.nan, and includes code that demonstrates the issue. The system information is also provided, which is helpful for debugging. All necessary information is present for a successful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "mwaskom__seaborn-3407": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal reproducible example (MRE) that demonstrates the KeyError when using a MultiIndex DataFrame with seaborn's pairplot function. The stack trace shows where the error occurs, and a workaround is provided. The goal is clear: fix the KeyError in pairplot when handling MultiIndex DataFrames. All necessary information is provided to reproduce the issue and understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "pallets__flask-5014": {
        "explanation": "The issue is reasonably well-specified. It clearly states that a ValueError should be raised when a Blueprint is given an empty name. However, there are some details that need to be filled in, such as exactly where in the code this validation should happen and what constitutes an 'empty' name (e.g., whitespace only, zero-length string, etc.). But these are reasonable assumptions that can be made based on standard practices for input validation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1142": {
        "explanation": "The issue is reasonably specified. The user is describing a problem where requests.get is sending a Content-Length header in a GET request, which is causing a 503 error on http://amazon.com. The user is suggesting that the behavior should be to not automatically add this header in GET requests, or at least provide an option to not send it. This is a clear description of a problem and a proposed solution, though it may require some investigation into the HTTP specification and the implementation of requests.get to determine the best approach for resolution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1327": {
        "explanation": "The issue is well-specified with a clear problem description, reproduction steps, and proposed solutions. It explains the problem with transport adapters in the Requests library not working reliably due to dictionary key ordering. It provides the context of the issue, shows an example of the problem with code, and outlines several possible solutions with their tradeoffs. This provides all the information needed to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1339": {
        "explanation": "The issue is well-specified. The problem is clearly described with a test case and example output showing the current behavior versus the expected behavior. The reporter provides a proposed fix by modifying the __setitem__ method. All necessary information is present to understand the issue and implement a solution. The code examples clearly demonstrate the issue and the proposed solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1376": {
        "explanation": "The issue is well-specified because it provides the exact error message and test case that is failing. The test is checking that the multipart/form-data encoding is correctly handling unicode fieldnames. The test is asserting that the body contains 'name=\"stuff\"' but not 'name=\"b\\'stuff\\'\"', but the assertion is failing because it is true. This is a clear problem that can be addressed by ensuring that the multipart/form-data encoding is properly handling unicode fieldnames without adding extra byte string representations. The issue is specific enough to understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1537": {
        "explanation": "The issue is reasonably specified. The user is experiencing a TypeError when using a float in the data parameter with the files parameter in requests.post. They mention that this was a previous bug related to datetime data. The provided code example and traceback help to understand the problem and reproduce it. However, the exact desired outcome or expected behavior is not explicitly stated, requiring some interpretation to determine the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1657": {
        "explanation": "The issue is reasonably specified. The problem is described as session hooks being broken because request hooks are merged with session hooks, and one list overwrites the other. This provides enough context to understand the problem and work on a solution, but some details about the expected behavior of the hooks and how they should be merged are not provided. The developer would need to understand the intended functionality of the hooks and determine the correct way to merge the request hooks with the session hooks without overwriting. However, the core issue is clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1713": {
        "explanation": "The issue is well-specified because it provides the following details:\n\n1. It clearly describes the problem: Using MozillaCookieJar with requests 2.0.1 causes an error.\n2. It provides a complete error traceback showing the AttributeError when MozillaCookieJar is used.\n3. It shows a minimal, reproducible code example that demonstrates the issue.\n4. It identifies the specific commit that introduced the change causing the issue.\n5. It explains the root cause: MozillaCookieJar is being treated as a dict when it needs to be handled as a CookieJar object.\n\nWith all this information, a developer would have everything needed to understand the problem and implement a fix. They would know exactly what's broken, why it's broken, and how to reproduce it to test any potential solutions.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1724": {
        "explanation": "The issue is well-specified. It clearly describes the problem (UnicodeDecodeError when using Unicode method names in Python 2.7.2), provides reproducible examples showing both working and failing cases, includes detailed error traceback, and points to the specific line of code that appears to be causing the issue. The user also explains their understanding of the problem (that u'POST' is causing issues with headers) and provides context about their environment (Python 2.7.2, requests 1.2.3). This provides all the information needed to understand the problem and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1733": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific error message and a code snippet that reproduces the error. The request is to allow the Response class to be pickled, and the error traceback shows exactly what is wrong. This gives enough information to understand what needs to be done to fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1766": {
        "explanation": "The issue is reasonably specified. The problem is clear: the 'qop-options' directive in Digest Auth should be quoted with double quotes according to RFC2617. The current implementation may not be doing this, and curl does. The issue also explains that some servers are sensitive to this difference. However, there are some missing details: the specific code location to fix, the exact format of the qop-options string, and the testing procedure. Despite these gaps, the core problem and desired outcome are clear enough for a developer to find and fix the relevant code.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1776": {
        "explanation": "The issue is reasonably specified. The problem is described as cookies being persisted to the session when they shouldn't be. A specific line of code is pointed out as the location of the problem. However, there is some ambiguity around exactly what the expected behavior should be and what constraints exist (notably that removing the line breaks a test case from another issue). The issue provides a direction to investigate but leaves some implementation details to be determined by the developer.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1888": {
        "explanation": "The issue is well-specified because it clearly explains the problem (a 301 redirect is causing an error due to a Unicode string being passed to pyopenssl which expects bytes), provides the exact environment (Python packages and versions), includes a test case that reproduces the issue, and shows the error traceback. All the necessary information is present to understand what is happening and how to fix it. A developer would need to ensure that byte strings are being passed to pyopenssl rather than Unicode strings during the redirect process.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1921": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem (setting a header to None sends 'None' as the value instead of removing it), provides code examples of the current approach and the expected outcome, and shows a working alternative. The objective is clear: fix the behavior so that setting a header to None removes it from the headers rather than sending 'None' as the value.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-1944": {
        "explanation": "The issue is reasonably specified as it provides a clear problem description, steps to reproduce, and error logs. However, there are some blanks to fill in regarding the exact solution and the underlying reasoning for the current behavior. While the issue highlights that Requests is attempting to decode the response body of a redirect which is causing an error, and it's noted that other programs do not exhibit this behavior, the solution would require understanding the design decisions in Requests and how to modify them to align with the expected behavior without introducing new issues. The core problem is well-explained, but the implementation details of the fix are not explicitly outlined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-1962": {
        "explanation": "The issue is reasonably specified. The user is pointing out that the 'history' attribute of a request object can sometimes be a tuple instead of a list, and suggests that it should consistently be a list to reduce surprise. The user has provided a link to the specific line of code in the requests library where this occurs. This gives enough context to understand the problem and implement a solution, but there may be some details about the implementation and potential side effects that need to be considered. For example, changing a tuple to a list may have performance implications or affect other parts of the code that expect a tuple. However, the general direction of the fix is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-2148": {
        "explanation": "The issue is reasonably specified. It provides a specific error scenario where a socket.error is not being caught or wrapped in a requests exception. The issue includes a detailed stack trace and describes the expected behavior (wrapping socket errors in requests exceptions). However, there are some details that would need to be clarified or investigated further to implement a solution, such as which specific parts of the codebase need to be modified to catch and wrap these exceptions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-2153": {
        "explanation": "The issue is reasonably specified. It explains that a socket.timeout exception is being raised instead of the expected requests.exceptions.Timeout exception during a requests.post call. The issue includes a stack trace that shows the exception is coming from the socket.read method. The user is suggesting that requests should catch the socket.timeout and raise its own Timeout exception instead. While there is some ambiguity about the exact fix, the problem is clear enough to understand what needs to be addressed. A developer could investigate how requests handles socket timeouts and determine if there is a missing exception handling case.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-2193": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear example of the problem, including the specific error that occurs (urllib3.exceptions.ProtocolError not being wrapped). The example shows how to reproduce the error with the given version of requests. The problem is clearly defined as a regression, and there is enough information to understand what is expected: to ensure that the ProtocolError is properly wrapped. This would allow for a targeted solution to address the issue in the specified version of the library.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-2317": {
        "explanation": "The issue is reasonably specified. The problem is described as a conversion issue where a binary string is being converted to a literal string, leading to a 404 Not Found response. The user provides context on the environment (Python 3.4, requests 2.4.3, neutronclient 2.3.9) and suggests that the issue does not occur in Python 2.6. While the exact cause (bug in neutronclient or requests) is unclear, the problem is reproducible and the expected behavior is clear: requests should handle binary strings for the method correctly. There is enough information to investigate and propose a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-2617": {
        "explanation": "The issue is well-specified with a clear example of the problem, the expected behavior, and the actual error that occurs. The user has provided a minimal, reproducible example which includes the code that causes the issue, the conditions under which it occurs (Python 2.7 with 'unicode_literals' imported), and the exact error message. All the necessary information to understand and reproduce the problem is present.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-2674": {
        "explanation": "The issue is about urllib3 exceptions passing through the requests API and not being properly wrapped in requests.exceptions types. The reporter mentions specific exceptions (DecodeError and TimeoutError) that are not being caught by the requests exception handling. However, there is ambiguity about whether this is an intended design or a bug, and the reporter is also suggesting an opinion about what should be done. This ambiguity makes it unclear what a successful solution would look like without further clarification. The issue is vague because it is not clearly defined what the expected behavior is or what specific changes are needed.",
        "label": "VAGUE"
    },
    "psf__requests-2678": {
        "explanation": "The issue is about urllib3 exceptions passing through the requests API and not being properly wrapped in requests.exceptions types. The reporter mentions specific exceptions (DecodeError and TimeoutError) that are not being caught by the requests API, requiring additional handling. While the issue is somewhat technical and may require domain knowledge to fully understand, it clearly identifies the problem (unwrapped exceptions), provides specific examples of the exceptions involved, and explains the impact (need to catch additional exceptions). The request for clarification on whether hiding urllib3 exceptions is a design goal suggests there may be some ambiguity in the intended behavior, but the problem itself is well-defined. The reporter is asking for a resolution to ensure these exceptions are properly wrapped or handled through the requests API.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-2821": {
        "explanation": "The issue is well-specified as it provides a detailed error traceback, version information, and context about the problem occurring after an upgrade. The user clearly states the issue is related to the 'memory view' error when upgrading from version 2.7.0 to 2.8.0, and confirms that downgrading resolves the issue. This information is sufficient to investigate the source of the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-2873": {
        "explanation": "The issue is well-specified with a clear example of the problem, including code that reproduces the issue and expected outcomes. It explains the current behavior and desired outcome, making it clear what the solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-2931": {
        "explanation": "The issue is reasonably well-specified. It provides a code example that demonstrates the problem, indicating that sending a binary payload with encoded Unicode characters fails in version 2.9 but works in 2.8.1. The reference to the related GitHub issue gives additional context. However, there are some details that might need to be clarified, such as the exact error message or traceback, and the expected vs actual behavior. Despite these minor gaps, the core problem is clear enough to guide a solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-3362": {
        "explanation": "The issue is not about implementing a specific feature or fixing a bug, but rather about understanding the behavior of the requests library in Python. The user is confused about the difference in behavior between r.text and iter_content(decode_unicode=True). The issue does not provide a clear request for a code change or a specific problem to solve, but rather asks for clarification on observed behavior. This is more of a usage question than a development task, making it impossible to solve through a PR without further information about what specific change or clarification is needed.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "psf__requests-4106": {
        "explanation": "The issue is well-specified. It clearly describes the problem (AttributeError when accessing requests.packages.urllib3), provides expected vs actual results, and includes detailed reproduction steps and system information. This allows for a clear understanding of what the problem is and how to verify a solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-4356": {
        "explanation": "The issue is well-specified with a clear description of the problem, expected vs actual results, and steps to reproduce. It also includes a traceback and system information. However, the question about where to fix the issue (requests, urllib3, or urlparse) introduces some ambiguity on the solution approach. Despite this, the core issue is clear enough for a meaningful solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-5087": {
        "explanation": "The issue is well-specified with a clear description of the problem, expected result, actual result, and reproduction steps. The problem is that accessing `response.content` twice causes the error to be forgotten and an empty string to be returned instead of re-raising the exception. The expected result is that the exception should be raised again. There are clear reproduction steps and the problem is well-explained. This is all the information needed to attempt a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-5414": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, including the expected and actual results, reproduction steps, and system information. It also references related code and previous discussions. This information is sufficient for understanding the issue and implementing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "psf__requests-6028": {
        "explanation": "The issue is reasonably specified. The user has provided a clear problem description (407 error when using proxies in Python 3.8.12), expected outcome (200 status code), and an example code snippet. They also mention a potential cause related to Python 3.8.12 changes and provided system information. However, there are some missing details like the actual proxy setup (especially since it's a paid service and not included in the example) and the exact error message or traceback. Despite these minor gaps, the core issue is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-774": {
        "explanation": "The issue is reasonably well-specified as it provides a traceback and a specific line of code that is causing the problem. The solution involves adding a try/except block around the problematic line to catch the UnicodeError. While there might be some details about how exactly to handle the error that are not specified, the overall task is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "psf__requests-863": {
        "explanation": "The issue is well-specified.  It explains the current behavior (hooks argument can only take one function per hook), the problem this causes (passing a list results in a list of lists, which is not callable), the workaround (register_hook multiple times), and the proposed solution (modify Request.__init__ to handle lists in hooks argument values).  The problem and solution are both clearly described, making it possible to implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-2905": {
        "explanation": "The issue is reasonably specified as it provides a minimal example, problem description, expected output, and context about the change that caused the issue. However, some implementation details may require further understanding of the xarray codebase and how the Variable.__setitem__ method works with objects having a 'values' property. There are some blanks to fill in about the exact approach to fix the issue, but the problem itself is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-2922": {
        "explanation": "The issue is reasonably specified. The request is to add an average function to a data structure (possibly a DataFrame or similar) that can compute weighted averages, likely for geographic data. The user mentions that this would require axes to be in a predictable order or weights per dimension, but these are just notes about potential implementation details. The core request is clear - to add an average function that supports weighted averages. The exact implementation details (like how weights would be specified, what data types are supported, etc.) would need to be determined by the developer, but the overall goal is clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-3095": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce, and examples of the expected and actual behavior. The problem is a regression in xarray >= 0.12.2 where the deep copy of Dataset and DataArray objects is casting Unicode indices to object type, which is not the expected behavior. The issue also includes sample input and output, which helps in understanding the problem and verifying the solution. The version where the issue was introduced is also mentioned, which can be helpful in debugging. All the necessary information to understand the problem and start working on a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3114": {
        "explanation": "The issue is well-specified. It describes a problem with the 'expand_dims' function in xarray causing the underlying numpy array to become read-only, and changing the behavior of the '.loc' method. It provides a detailed example of the problem and the expected behavior, along with the output of xr.show_versions() for context. All the necessary information for a meaningful attempt at a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3151": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal code example that reproduces the error. The expected output is stated (no error), and the actual error message is provided. The issue also explains the discrepancy between the documentation and the current implementation. All necessary information is provided to understand the problem and reproduce it. The error message gives a clear indication of what needs to be fixed in the implementation. The issue is specific, actionable, and well-documented.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3159": {
        "explanation": "The issue is well-specified because it clearly explains the problem (need to create an empty DataArray with a default value instead of a full numpy.ndarray), provides a concrete example from pandas for reference, and describes a specific desired behavior. The request to allow passing a default value for the `data` argument in DataArray is clear and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3302": {
        "explanation": "The issue is reasonably specified. It describes the problem with the current `limit` argument in `interpolate_na()` and suggests a feature request for an additional argument to handle small gaps of NaNs based on their block size. While the specific implementation details are not provided, the intended behavior is clear enough to guide a meaningful attempt at a solution. The examples and references to similar solutions in other projects help clarify the scope and potential approach.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-3305": {
        "explanation": "The issue is well-specified. It provides a minimal code example that reproduces the problem, shows the current output, and specifies the expected output. The problem is clear: the 'keep_attrs' parameter in 'DataArray.quantile' is not functioning as intended. The code example is simple and complete, allowing for a direct approach to resolve the issue. The expected output gives a clear target for the fix. Therefore, a solution can be meaningfully attempted based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3520": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a minimal code example (MCVE) that demonstrates the current behavior and the expected behavior. The output of the xr.show_versions() is also provided, which can be useful for debugging. The issue is about incorrect selection from a MultiIndex in xarray, and the code example shows the current output and the expected output. The user is asking for a fix for this problem.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3631": {
        "explanation": "The issue is well-specified because it provides a minimal code example that reproduces the error, a detailed error traceback, a clear problem description explaining the root cause, and a suggested solution path. The issue describes the problem with converting cftime coordinates during interpolation, explains why the current approach fails (due to handling of datetime.timedelta objects), and provides context about why supporting long time periods is important. The problem has a clear goal (fixing the interp method to work with long cftime coordinates) and the suggested solution direction (writing custom conversion logic instead of relying on pandas/NumPy).",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3649": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including a minimal code sample to reproduce the issue, the expected output, and the current error message. The specific function that needs to be modified is identified, and the proposed change is clearly stated (allowing for missing panels in the hypercube and replacing missing tiles with fill_value). The issue also explains why the current implementation is causing an error and suggests a solution approach (separating the check for consistent dimension lengths from the hypercube completeness check). This provides enough information for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3677": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is that the `ds.merge()` method fails when merging a Dataset with a DataArray, while the top-level `merge()` function works. The code example shows the issue with a minimal working example and the error output. A solution would need to address the incompatibility between the `merge` method and DataArrays by ensuring that the method can handle DataArrays correctly, possibly by modifying the `merge_core` function to properly handle DataArray inputs.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3733": {
        "explanation": "The issue is reasonably specified. The user wants to implement a `polyfit` method for xarray DataArray objects, similar to numpy's polyfit. They provide an example of how they expect it to work, including example code and an equivalent numpy implementation. While there are some implementation details that would need to be worked out (such as handling dask arrays, error checking, etc.), the core functionality and use case are clearly described. The user also explains why this feature is needed (to simplify polynomial fitting for users compared to using apply_ufunc).",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-3905": {
        "explanation": "The issue is reasonably specified as it provides a clear problem description, a minimal code example, and an expected output. However, there are some missing details that need to be inferred by the developer. The main task is to truncate the array representation based on line count, but the exact implementation details such as the truncation logic (e.g., how many lines to show at the beginning and end, how to handle different array dimensions, etc.) are not explicitly specified. The issue mentions 'something like 40 lines is probably a reasonable place to truncate', which gives a general idea but leaves room for interpretation. Despite these gaps, a sensible solution can be developed by implementing a truncation mechanism that limits the array representation to around 40 lines, showing the beginning and end of the array with an ellipsis in between. Therefore, the issue is reasonably specified but requires some assumptions to be made by the developer.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-3976": {
        "explanation": "The issue is well-specified because it includes a clear problem description, a minimal code example to reproduce the issue, and a detailed error traceback. The expected behavior is also clearly outlined. All necessary information is provided to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-3993": {
        "explanation": "The issue is about API inconsistency between DataArray.integrate and Dataset.integrate, specifically the use of 'dim' versus 'coord' arguments. The problem is clearly described with code examples showing the inconsistency. The reporter also provides reasoning for why 'coord' is the correct argument to use for integration (since coords carry information about grid spacing). The issue also references a previous discussion where this was acknowledged as an oversight. The only remaining question is whether a deprecation cycle is needed, which is a secondary concern for implementation. Given all this clarity, the issue is well-specified enough for a meaningful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4075": {
        "explanation": "The issue is well-specified. It includes a minimal code example that reproduces the problem, shows the current and expected outputs, explains the underlying problem with boolean weight normalization, and provides a proposed fix. The problem is clearly described with specific details about the incorrect behavior of the weighted mean function when boolean weights are used. The explanation of how the weights are being calculated incorrectly and the suggested correction provides clear guidance on what needs to be fixed. This information is sufficient for an experienced software engineer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4094": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a minimal code example that reproduces the error, an explanation of what the expected output should be, and a description of the actual problem. The error message is provided, which helps to understand what is going wrong. All of these elements make it possible to understand the issue and work towards a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4098": {
        "explanation": "The issue is vague because it does not specify what the expected behavior is when using 'name=None' with the 'groupby' function. It lacks context, details about the current behavior, and a clear description of the desired outcome. Without understanding the specific problem or enhancement being requested, it's difficult to determine what changes need to be made to the codebase.",
        "label": "VAGUE"
    },
    "pydata__xarray-4248": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The request is to display units in the dataset overview, with specific examples provided. The desired format for showing units is clearly outlined, making it possible to understand what changes need to be made to the dataset representation. The hypothetical dataset and the expected output demonstrate exactly what the feature should look like after implementation. There are no ambiguities in the requirements, and a software engineer with knowledge of the codebase would be able to make the necessary changes based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4356": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem, a proposed solution, and relevant code context. However, there might be some interpretation needed on how exactly to implement the fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-4419": {
        "explanation": "The issue is well-specified because it provides multiple code samples that demonstrate the problem, along with the expected and actual outputs. It clearly explains that the xr.concat function is changing the order of dimensions and coordinates, which is not the intended behavior. The issue also includes the versions of the software and dependencies, which is important for context. There is a clear description of what the problem is and what the expected outcome should be.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4442": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a code sample that reproduces the issue, a problem description, and an error traceback. The expected behavior is mentioned (a series/dataframe with a multiindex with names a,b,c), and the actual behavior is described (a NotImplementedError). The issue is specific to the case when a DataArray has a multiindex dimension (produced by stack) and other dimensions as well. The code sample shows both the failing case and a working case (when there is only one dimension, which is stacked). The versions of the libraries involved are also provided. This information is sufficient to understand the problem and to start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4510": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including code that reproduces the issue, expected behavior, and actual behavior. The user explains that the 'rolling' function is dropping attributes and name, even when 'keep_attrs=True' is used. The provided code demonstrates the issue, and the user's question is clear about what should be happening. All necessary information for a successful solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4629": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimal complete verifiable example, and the expected behavior is outlined. The user has also provided a suggested fix (changing `return variable_attrs[0]` to `return dict(variable_attrs[0])`) and pointed to the specific line in the code where the change should be made. This level of detail allows for a clear understanding of what needs to be done to resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4684": {
        "explanation": "The issue is well-specified with a clear problem description, a minimal code example to reproduce the issue, and an expected output. The user is encountering a loss of millisecond precision when round-tripping datetime64 data through disk using xarray. The code provided demonstrates the problem, and the expected output shows what the correct behavior should be. This is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4687": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: using xr.where on a DataArray with attributes results in a new DataArray without attributes. There is a minimal complete verifiable example provided, which demonstrates the issue. The expected output is also clearly stated. The issue is about preserving attributes when using xr.where, which is a specific and well-defined problem. The ticket includes information about the environment and versions, which is helpful for debugging. Therefore, the issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4695": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a code sample that shows the issue when using the name 'method' for a dimension, and the error message is included. The expected behavior is also described - the name of the dimension should be irrelevant and not cause an error. The issue also includes the output of xr.show_versions() for environment information. This provides enough information to understand the problem and work towards a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4759": {
        "explanation": "The issue is well-specified. It describes a problem where the data type (dtype) of coordinates in an xarray Dataset or DataArray changes from a string or unicode type (like '<U1' or '|S1') to an object type after certain operations, specifically when using xr.concat or adding a DataArray. The issue includes detailed code samples that demonstrate the problem, shows the unexpected output, and explains what the expected behavior should be. The issue also references a potentially related existing issue and provides environment information. This level of detail allows for a meaningful attempt at a solution without requiring further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4767": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is clearly described with a reproducible example and the expected behavior versus the actual behavior is outlined. The error message and the relevant tracebacks are provided, which helps to understand the source of the inconsistency between DataArray and Dataset transpose operations. The user also points out where in the code the issue might be occurring (the infix_dims function being called twice). This is sufficient information for an experienced developer to investigate and fix the inconsistency.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4802": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem, including a code example that reproduces the error, the error message itself, and context about when the issue started occurring (version 0.16.2). The issue also explains the root cause (python list instead of numpy array for scale_factor) and provides context about how this situation can occur in practice (with h5netcdf engine and zarr). The expected behavior is implied - it should work similarly to when scale_factor is a numpy array. This provides enough information for a software engineer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4819": {
        "explanation": "The issue is reasonably specified. It describes a problem where the user wants to drop indices from a dimension that doesn't have coordinates using a function similar to `drop_sel`, but for integer positions like `isel`. The error encountered is clear, and the desired behavior is explained by analogy to existing functions. While some implementation details might need to be worked out, the intent and expected outcome are understandable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-4879": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, what was expected, and provides a minimal complete verifiable example. The user also explains that the issue occurs when using the jupyter repr and how it affects future reads of the netcdf file. The problem is reproducible and the environment is detailed, making it clear what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4911": {
        "explanation": "The issue is well-specified. The problem is described with a clear example, including what happened and what was expected. The issue is about the `sum` method on a lazy array with `min_count` parameter causing immediate evaluation, which is unexpected. The provided code is a minimal complete verifiable example that reproduces the problem, and the expected behavior is clearly stated. The issue also mentions that if there's a limitation in the implementation, it should be documented. All necessary information for understanding and addressing the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4940": {
        "explanation": "The issue is well-specified with a clear description of the problem, a minimal code example to reproduce the issue, and the observed output. The problem is that calling the mean method on a Dataset drops the coordinates, which is different from the behavior when the mean is called on a DataArray where the coordinates are preserved. The code sample and outputs clearly demonstrate this discrepancy. This is a clear bug report with sufficient information to understand and reproduce the issue.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4966": {
        "explanation": "The issue is well-specified with clear details about the problem, the expected behavior, and the specific location in the code where the fix should be applied. The user also provided reproducible examples and references to relevant documentation and conventions. All necessary information is present to implement the fix.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-4994": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user clearly describes the problem (missing 'date' attribute in the datetime accessor), provides a minimal complete verifiable example that demonstrates the issue, and even suggests a solution (adding a specific line of code to a particular file). The expected behavior is clearly stated as matching the functionality of the 'time' attribute. The error message is shown when trying to access the missing 'date' attribute. All the necessary information is provided to understand the problem and implement a solution. This includes the code to reproduce the issue, the expected outcome, and a suggested implementation approach.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-5033": {
        "explanation": "The issue is reasonably specified. The user is requesting a change to allow adding custom backends to xarray by passing a function to the engine parameter. While the general idea is clear, there are some implementation details and edge cases that would need to be considered when implementing this change, such as how to handle different types of engines, error handling, and ensuring compatibility with existing functionality. However, the core requirement of allowing function-based engine parameters is clear enough to begin work on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-5126": {
        "explanation": "The issue is reasonably specified. It asks for an option to collapse the HTML display in notebooks, similar to the existing xarray.set_options. The main goal is clear, but there are some implementation details and questions that need to be filled in. The issue also asks for guidance on which files need to change and potential pitfalls, indicating that there are some blanks to fill. The additional question about the text repr adds another layer of consideration but is not mandatory for the main solution. Overall, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-5131": {
        "explanation": "The issue is well-specified and clear. It describes the problem of a trailing whitespace in the text representation of a DatasetGroupBy object in xarray, explains why it is a problem (conflict with flake8 and doctest), and even offers to make a pull request if it's acceptable to remove the trailing whitespace. The request is specific and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-5180": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, what was expected, a minimal complete verifiable example, and a suggested fix. The example shows how the current behavior is different from the expected behavior and provides a workaround. The documentation references and environment information further support understanding the issue. All necessary details are provided to reproduce and resolve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-5187": {
        "explanation": "The issue is well-specified. The problem is described clearly with a code example that demonstrates the issue. The expected output is stated, and the actual output is shown for different chunk sizes. This provides enough information to understand the problem and begin working on a solution. The code example is self-contained and reproducible. The issue is about the bfill (backfill) method not working correctly with small chunk sizes in dask arrays, which results in NaN values not being filled as expected. The code shows that with unchunked data and medium chunk sizes the bfill works correctly, but with small chunk sizes (chunk size of 1) it fails to fill the NaN.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-5233": {
        "explanation": "The issue is reasonably specified with some blanks to fill in about the issue, but there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-5362": {
        "explanation": "The issue is reasonably specified. The problem is that weighted operations do not raise an error when non-existent dimensions are passed, unlike unweighted operations. A minimal example is provided. However, the solution requires determining the correct behavior (whether it should raise an error or not) and implementing it, which involves some interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-5365": {
        "explanation": "The issue is well-specified for a meaningful attempt at a solution. The user is requesting a feature to add a vector cross product function to the xarray library, similar to how xarray.dot() works. The issue includes a proposed implementation, example usage, and even raises the question of where this function should live (in xarray or another package). The user has also provided the cross function implementation they're currently using, along with example usage. While there are some TODO comments in the code that indicate potential areas for improvement, the core functionality and requirements are clear. The issue is specific, actionable, and provides all necessary context for implementing the feature. The user even offers to create a PR if the maintainers are interested in adding it to xarray directly. This level of detail makes it possible to understand exactly what needs to be done and how it could be implemented.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-5455": {
        "explanation": "The issue is well-specified because it clearly outlines the problem with Xarray's current backend registration and provides a detailed proposal for changes to the plugin protocol. It explains the desired behavior of functions like `guess_can_open()` and `installed()`, and even provides an example of the expected error message. This level of detail allows for a direct implementation approach without significant ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-5580": {
        "explanation": "The issue is reasonably specified. It requests increasing the default 'display_max_rows' value in 'xr.set_options()' because the current default of 12 is too low and causes problems with backward compatibility and functionality. The issue provides context about why this change is needed (e.g., for checking data integrity and doctest failures). However, it doesn't specify the exact new value for 'display_max_rows', though it suggests options like 100, 1000, or 10000. The developer would need to choose a reasonable default based on common usage patterns and system constraints. Despite this minor ambiguity, the overall goal is clear enough for a meaningful solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-5731": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user is encountering a NameError when using xarray.corr on two DataArrays, and the error is due to dask not being installed in their environment. The minimal complete verifiable example is provided, which demonstrates the error. The expected behavior is also clearly stated as obtaining the correlation values without dask interfering. The environment details and the full error traceback are also given. All necessary information for understanding and reproducing the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6386": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem (TypeError when resampling a dataset with a function that returns a DataArray), what was expected (it worked before a specific PR), a minimal complete verifiable example, relevant log output showing the error location, and additional context about the potential cause. The issue also explains the discrepancy in the _overwrite_indexes() method between DataArray and Dataset, and suggests possible solutions (either restricting functions to return Datasets with an explicit error, or fixing the regression if DataArrays should be accepted). This provides sufficient information for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6394": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is described as a regression where DataArray groupby returns Dataset broken in some cases, with a reference to a similar issue (#6379) and a potential solution (#6386). A minimal complete verifiable example is provided, which demonstrates the issue with a code snippet that causes an error. The relevant log output is included showing the TypeError, which points to a problem with the _overwrite_indexes method. The environment information is also provided, indicating the specific xarray version where the issue occurs. All these details provide sufficient information to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6400": {
        "explanation": "The issue is well-specified with a clear problem statement, a minimal complete verifiable example, and performance metrics. The example demonstrates the issue with the html repr of large multi-indexes taking 12 seconds. The reference to a previous PR suggests where to look for potential fixes. This provides enough information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6461": {
        "explanation": "The issue is well-specified enough to understand the problem. The error message is provided, the code that reproduces the error is given, and the environment (xarray version) is mentioned. The problem occurs when using xr.where with a scalar as the second argument and keep_attrs=True, which causes an IndexError. The workaround is known (passing keep_attrs=False). While the expected behavior isn't explicitly described, the problem is clear and actionable for a developer familiar with xarray's codebase.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6548": {
        "explanation": "The issue is well-specified. The user provides a clear description of the problem, including what they expected to happen, what actually happened, and a minimal complete verifiable example that demonstrates the issue. The example shows that xr.polyval requires the coordinate DataArray to have a name attribute, and explains how to reproduce the KeyError when the name is missing. The user also provides context about the workflow and potential solutions. All necessary information to understand and reproduce the issue is included, making it well-specified for a meaningful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6598": {
        "explanation": "The issue is well-specified. The user has provided a clear description of the problem, a minimal complete verifiable example, and attached a CDL file that can be used to reproduce the issue. The expected behavior is outlined, and there is a clear distinction between the 'good_time' and 'time' variables that should help in understanding the problem. The relevant log output also helps in understanding the discrepancy between the two times. All necessary information is present to attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6599": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with `polyval` when using `timedelta64` coordinates, showing that the output is incorrect in the latest version compared to a previous version. The issue includes a minimal complete verifiable example that others can run to reproduce the problem. It also provides the expected behavior (same results in both versions) and the actual wrong results. The issue also contains relevant log output from both versions showing the discrepancy. All necessary information for diagnosis and potential resolution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6601": {
        "explanation": "The issue is well-specified. The user provides a clear description of the problem, including a reproducible example and the exact output differences between two versions of the library. The example uses specific data and code that can be used to reproduce the issue, and the user explicitly states the observed behavior in different versions and is asking whether this change is expected and if it should be documented as a breaking change. All necessary information is provided to understand the problem and reproduce it, making it well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6721": {
        "explanation": "The issue is well-specified because it clearly describes the problem (accessing the chunks attribute loads the entire array into memory), provides a minimal example, and includes relevant log output that shows the problem in detail. The expected behavior is also defined (accessing the encoding attribute instead of loading the entire array). This provides all the information needed to understand the issue and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6744": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user is clearly describing a discrepancy between two methods of computing a rolling mean in xarray. They have provided a minimal, reproducible example with code snippets that demonstrate the problem, and they clearly state what they expect versus what is actually happening. The problem is reproducible, the inputs and outputs are clearly defined, and the desired behavior is well-explained. A software engineer would be able to run the provided code, reproduce the issue, and understand what needs to be fixed - namely, ensuring that manual iteration over DataArrayRolling objects respects the 'center' parameter as it does in the automated version.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6804": {
        "explanation": "The issue is a request to use PyTorch as a backend for xarrays, which is a data structure library for labeled multi-dimensional arrays. The request is motivated by several factors: similarity to NumPy, potential GPU acceleration, and integration with deep learning algorithms. However, the issue does not provide clear requirements or specifications for implementing this feature. It is a general request for adding a new backend, which involves significant design and implementation considerations that are not outlined in the issue. The issue also appears to be more of a feature request and inquiry about interest rather than a specific problem to solve. Therefore, the issue is vague and lacks the necessary details for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "pydata__xarray-6823": {
        "explanation": "The issue is well-specified. It clearly describes the problem (RuntimeError when formatting sparse-backed DataArray in f-string after upgrading xarray), provides a minimal complete verifiable example, shows the expected vs. actual behavior, and includes relevant error logs and environment information. A developer would have all the necessary context to understand the problem and work on a fix. The issue also mentions the expected outcome, which is to either prevent the error or document the breaking change.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6882": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a minimal working example (mwe.py) that reproduces the error, and the error message is provided in detail. The issue involves a ValueError when handling a zero-sized time coordinate dimension in xarray when reading NetCDF files. The code example shows how the error is triggered, and the expected behavior (reading the file without error) is implied. The stack trace shows where the error is occurring in the codebase, providing a clear path for debugging and fixing the issue. All necessary information is provided to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6889": {
        "explanation": "The issue is well-specified and provides all the necessary information to understand the problem and reproduce it. The issue describes the problem clearly, provides a minimal complete verifiable example, and even includes the relevant log output. The user explains that after using xr.concat on a dataset with a MultiIndex, functions like reindex_like break due to alignment issues. The example provided reproduces the error, and the traceback shows exactly where the problem occurs. This makes it clear what the expected behavior is (working alignment) and what the actual behavior is (ValueError due to conflicting indexes). The environment information is also provided, which helps in understanding the context. All the necessary information is present to investigate and resolve this issue.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6938": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The reporter provides a clear description of the problem, including what was expected to happen and what actually happened. The issue includes a minimal complete verifiable example with code that demonstrates the unexpected behavior. The code example shows that `.swap_dims()` is modifying the original object in a way that was unexpected. The reporter also mentions that this behavior was not expected and explains the context of the problem. The issue is well-structured with confirmation that it meets the criteria for a minimal, complete, and verifiable example. The reporter has also provided additional experiments in a Gist for further investigation. This information is sufficient for a software engineer to understand the problem and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6971": {
        "explanation": "The issue is discussing the potential addition of a public API method called `set_xindex` to Xarray's DataArray and Dataset classes. It references previous discussions and provides reasoning for the change, but it is framed as a question/suggestion to the community (@pydata/xarray) rather than a concrete task to implement. The issue lacks specific instructions on what code changes need to be made, what functionality should be implemented, or what tests should be written. It presents different design options and asks for feedback, rather than defining a clear implementation task. Without more concrete requirements and specifications, it would be difficult to create a meaningful PR that addresses this issue. The issue is more of a discussion starter than a well-defined task.",
        "label": "VAGUE"
    },
    "pydata__xarray-6992": {
        "explanation": "The issue is well-specified because it provides a clear problem description, a minimal complete verifiable example, and points to the specific line of code where the error occurs. The problem is about a ValueError after an index refactor in xarray, and it explains that the assumption in DataVariables is now wrong because there can be more _coord_names than _variables. The MVCE reproduces the error, and the relevant log output shows the specific error message. This information is sufficient for an experienced software engineer to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-6999": {
        "explanation": "The issue is well-specified. It includes a clear description of the problem, what was expected, and a minimal complete verifiable example. The example demonstrates the issue and shows how it differs from the expected behavior. A solution would need to either prevent the use of rename_vars to set dimension coordinates or ensure that an index is created in this scenario. All necessary information is provided to understand and address the problem.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7003": {
        "explanation": "The issue is reasonably specified. The user has provided a clear error message and context about the `get_unique()` method failing with a `TypeError: unhashable type: 'MultiIndex'` when used with `indexes`, but working with `xindexes`. This provides enough information to understand what the problem is and what needs to be fixed. However, without seeing the full codebase and the dataset `ds`, there are some details that would need to be filled in while implementing a solution. For example, understanding exactly how the `get_unique()` method is implemented and what it's trying to do with the indexes. But there's a clear path forward to address the issue based on the information provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-7089": {
        "explanation": "The issue is reasonably specified.  It identifies a specific function (Dataset.copy) and a specific parameter (deep=True), and describes the unexpected behavior (attrs are not deep copied).  A solution would likely involve modifying the Dataset.copy method to ensure that .attrs are deep copied when deep=True is specified.  However, there is some ambiguity about the exact implementation details that would be needed to fix the issue.  For example, it is not clear if the .attrs are a simple dictionary or a more complex object that requires special handling.  Additionally, it is not clear if there are any performance considerations or backward compatibility issues that need to be taken into account.  Despite these ambiguities, the overall goal of the fix is clear, and a reasonable solution can be devised based on the information provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pydata__xarray-7101": {
        "explanation": "The issue is well-specified and includes a minimal, complete, and verifiable example that reproduces the problem. It also provides a detailed explanation of the problem, including a traceback, and a proposed test to verify the fix. The issue clearly explains what is happening, what was expected, and provides enough code to reproduce the issue and verify the solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7105": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the groupby function on a multi-indexed DataArray or Dataset in xarray, provides a minimal complete verifiable example, and specifies the expected versus actual output. The code examples show what the user is experiencing in the current version versus what they expect based on a previous version. This is sufficient for a software engineer to understand the issue and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7147": {
        "explanation": "The issue is well-specified. The problem is clearly described: when a variable in a Dataset has times that cannot be represented as `cftime.datetime` objects, the error message does not include the problematic variable's name. The issue provides a concrete example of the problem, showing the current error output and explaining that it lacks information about which variable is causing the issue. The desired solution is clear - modify the error message to include the name of the problematic variable. This is a specific, actionable task that can be implemented by modifying the relevant code in the xarray library to include the variable name in the error message. The issue also provides a minimal example to reproduce the problem, which would help in testing any proposed solution. There is no ambiguity about what the issue is or what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7150": {
        "explanation": "The issue is well-specified and contains a detailed explanation of the problem, a minimal complete verifiable example, and a clear error message. The reporter has also provided information about what they expected to happen and has confirmed that the issue is not a duplicate. This information is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7203": {
        "explanation": "The issue is well-specified. The problem is described clearly: loading data for reprs of datasets with many small variables is slow. The expected outcome is fast reprs. A minimal verifiable example is provided, along with timing information showing the issue. The specific code location is referenced, and there's a clear indication of the impact of the problem. All necessary information is provided to understand and address the issue effectively.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7229": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a minimal complete verifiable example (MVCE), and the expected outcome is clearly outlined. The issue explains that the xr.where function with keep_attrs=True is overwriting coordinate attributes when it should be preserving them. The MVCE demonstrates the problem, and the expected output is provided in the log output. The issue also provides context about when the problem may have started (2022.06.0) and references a specific pull request (#6461) that may have introduced the issue. This information provides enough detail for a software engineer to investigate the codebase, reproduce the issue, and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7233": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimal complete verifiable example. The expected behavior is stated (coordinates should remain coordinates after coarsen.construct). The actual behavior is demonstrated with code showing how non-dimensional coordinates are demoted to variables. The example is complete and can be copied into an IPython prompt or notebook. All relevant information about the environment and potential duplicates has been considered. This provides sufficient information for an experienced software engineer to understand the issue and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7347": {
        "explanation": "The issue is somewhat vague. It references an external GitHub issue and a minimal example that is not directly visible here. The core problem seems to be about the `assign_coords()` function in xarray resetting dimension coordinates to a default pandas index. However, without seeing the actual code example or the exact expected vs. actual behavior, there is some ambiguity about what exactly should be fixed. The reporter mentions preserving the index of coordinates that are not updated or not part of a dropped multi-coordinate index, but the specifics of how this should be implemented are not clear. The issue is not impossible to solve, but there are some gaps in the information that would need to be clarified before a precise solution can be developed.",
        "label": "VAGUE"
    },
    "pydata__xarray-7391": {
        "explanation": "The issue is well-specified. The problem is clearly described: binary operations on Datasets ignore the `keep_attrs` option, unlike DataArrays/Variables. A minimal example is provided to reproduce the issue, and the desired behavior is stated (datasets should behave like DataArrays/Variables regarding `keep_attrs`). The issue provides enough context and clarity for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7393": {
        "explanation": "The issue is well-specified. The user provides a clear explanation of the problem, a minimal complete verifiable example, and what they expected to happen. The example shows that the data type of a coordinate changes from int32 ('i4') to int64 ('i8') when using the stack method in xarray, and the user expects that the data type should remain unchanged. The example is concise, self-contained, and can be run to reproduce the issue. All relevant information is provided to understand and address the problem.",
        "label": "WELL_SPECIFIED"
    },
    "pydata__xarray-7400": {
        "explanation": "The issue is reasonably specified. It asks to modify the concat function to add missing variables with np.nan instead of raising an exception when concatenating datasets with disjoint variables. The PR includes tests, documentation updates, and adheres to coding standards. While some details about the implementation might need to be filled in, the overall goal is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-4330": {
        "explanation": "The issue is reasonably specified. The user clearly describes the problem of the spellchecker flagging code within backticks in comments and docstrings. They provide an example of the issue and suggest a potential solution of ignoring text flanked by backticks, similar to how Sphinx directives are handled. While there is some implementation detail to work out (such as how to integrate this with the existing spellchecker logic), the general goal is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-4339": {
        "explanation": "The issue is about supporting file output for Pylint when used with tox on CI servers. It explains the problem (tox can't redirect commands to files, making it hard to output results to a single file for CI), describes what was tried before (the --file-output option which was removed), and provides context from similar tools (flake8 added this feature for the same reason). The issue is well-defined, with a clear problem statement and desired outcome (support for outputting results to a file in a way that works with tox on CI servers).",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-4398": {
        "explanation": "The issue is reasonably specified. It explains the current behavior of pylint's --fail-under option and the desired change. The user provides two possible solutions, which gives guidance on the direction to take. The main requirement is clear: add a new option (--fail-on) that causes pylint to return an error code if specific issues or types are found. While some implementation details may need to be worked out, the overall goal is clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-4421": {
        "explanation": "The issue is well-specified. It provides detailed steps to reproduce the problem, including a link to an external issue, a downloadable configuration file, and a script to run. It clearly describes the current and expected behavior, shows the exact error traceback, and identifies the probable cause. This information is sufficient for an experienced developer to understand the problem and work on a fix.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-4516": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-4551": {
        "explanation": "The issue is well-specified. The user provides a clear example of the current behavior and the expected behavior. They also explain the problem with pyreverse not reading Python type hints. The request is to use Python type hints for UML generation, which is a clear goal. The example code, screenshot, and version information all contribute to making this issue well-defined and actionable for a software engineer attempting to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-4604": {
        "explanation": "The issue is well-specified. The problem is clearly described with steps to reproduce, current behavior, expected behavior, and relevant version information. It also references a related issue. A solution would involve modifying the linter (likely Pylint) to not report the 'unused-import' warning when a module is used in a type comment. This is a specific, well-defined problem that can be addressed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-4661": {
        "explanation": "The issue is reasonably specified because it clearly outlines the goal of making pylint compliant with the XDG Base Directory Specification. It identifies the problem (the .pylint.d directory in the home folder) and suggests a solution (changing variables/constants to use the appropriate XDG directories). However, there are some blanks to fill in, such as exactly which variables need to be changed and how the codebase currently handles directory creation and configuration. An experienced developer would have a good understanding of what needs to be done, but would need to explore the codebase to implement the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-4970": {
        "explanation": "The issue is well-specified. The problem is clearly described: when `min-similarity-lines` is set to `0`, pylint does not behave as expected (i.e., disabling duplicate code checking). The desired solution is also clearly stated\u2014setting the parameter to `0` should disable the check, as is the case with other linters like flake8. There's even a reference to a related open issue (#214), providing additional context. All necessary information to understand the problem and what is expected from a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-5136": {
        "explanation": "The issue is well-specified. The problem is clearly described, including the current structure of the code, the specific problem with typing due to the dual dependency, and the proposed solution. The impact of the issue (mypy errors) is mentioned, and a branch is provided for testing. The desired solution is straightforward - to merge MessagesHandlerMixIn into PyLinter to resolve the typing conflicts. The information provided allows for a meaningful attempt at a solution without requiring significant additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-5446": {
        "explanation": "The issue is about the inability to disable the duplicate-code (R0801) check in Pylint for specific portions of a file. The reporter notes that this is not possible and explains that the source code suggests it's not a trivial fix due to maintaining the same scope semantics as other disable comments. However, the issue lacks specific details about how the feature should work, what exact changes are needed in the codebase, or how the disable comment should be implemented for duplicate code checks. While the problem is clear, the solution requires interpretation and assumptions about the desired behavior and implementation approach. Therefore, the issue is reasonably specified but has blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-5595": {
        "explanation": "The issue is about making the score system of a tool (pylint) more beginner-friendly by changing the scoring from a 0-10 scale to something else, possibly inspired by other tools. However, the issue lacks specific details on what the new scoring system should look like, how to implement it, and what exactly makes the current system unfriendly. There are several ways one could interpret the request, such as changing the scale, adjusting the weighting of issues, or introducing a different metric altogether. Without more concrete requirements or examples of alternative systems, the solution path is not clearly defined.",
        "label": "VAGUE"
    },
    "pylint-dev__pylint-5613": {
        "explanation": "The issue is reasonably specified. It describes the current workaround being used to run pyreverse with specific arguments and shows the desired solution the user would like to use instead. While there are some details that would need to be filled in during implementation (like exactly how the parameters map to functionality and error handling), the general goal of creating a more direct API for pyreverse is clear. The example code shows the expected interface and usage pattern.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-5839": {
        "explanation": "The issue is reasonably specified. The problem is clearly described as allowing reuse of old msgid/symbol that have been deleted. The expected behavior is also mentioned as making it impossible to use old message ids or symbols. However, some details about how to implement this (e.g., specific functions or files to modify, how to enforce this restriction) are not provided. An experienced developer would need to look into the existing codebase, especially the parts handling message ids and symbols, to understand how to implement this restriction effectively. There's a mention of a related mechanism for renamed messages, which could provide some guidance, but the exact implementation path is not clear without further investigation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-6059": {
        "explanation": "The issue is reasonably specified. It asks to determine if the `__gt__` method in `BaseChecker` is required. If it is, add a unit test; if not, remove the method. While there is some ambiguity about what \"required\" means exactly, there is a clear path to investigation and resolution: checking how the method is used in the codebase, understanding its purpose, and determining if it's necessary. The issue provides enough context to begin working on it, even though some interpretation is needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-6196": {
        "explanation": "The issue is reasonably specified.  The problem with the `@check_messages` decorator is clearly described, including its current behavior, misuse, and the resulting problems.  The desired solution includes improving documentation, potentially changing the decorator's name and behavior, and establishing best practices.  However, the solution isn't a single, concrete task. It involves making decisions about the future of the decorator, which could be influenced by community consensus.  The issue is not vague, but it does require interpretation and potentially some design choices.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-6386": {
        "explanation": "The issue is well-specified. The problem is clearly described with a bug report format, including a detailed bug description, command used, pylint output, and expected behavior. The user is reporting that the short option for verbose in pylint expects an argument while the long option does not, and they want the short option to behave like the long option. The specific version of pylint is also provided which is helpful for debugging. All the necessary information is provided to reproduce and fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-6412": {
        "explanation": "The issue is reasonably specified. The problem is that PyLinter uses a non-standard `__implements__` attribute to categorize checkers, and the proposed solution is to change interfaces to use `ABCMeta` metaclass and switch to `isinstance` checks. While the general direction is clear, there are some implementation details and potential backward compatibility concerns that would need to be clarified before making changes. For example, how to handle transition from the old system to the new one, whether to deprecate the old system gradually, and how to modify all relevant interfaces and classes to use ABCMeta. These are reasonable assumptions to make but require some interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-6506": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, including the command used, the actual output (including the traceback), and the expected behavior. The user also provides an example of how another tool (mypy) handles the same situation, which gives a concrete idea of what the desired outcome should look like. The Pylint version and Python version are also provided, which is helpful for reproduction and debugging. All necessary information to understand and reproduce the bug is present, making it possible to work on a solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-6517": {
        "explanation": "The issue is well-specified. It includes a clear bug description, steps to reproduce, configuration, command used, expected vs actual output, and environment information. The problem with the 'confidence=' setting in pylintrc causing Pylint to pass unexpectedly is clearly described. All necessary information is provided to understand and reproduce the issue, making it possible to work on a solution without additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-6526": {
        "explanation": "The issue is asking about how pylint determines the location for its stat files and why they are being written to the current working directory instead of a user-specific directory. While the question provides context (e.g., they are using the VS Code Python extension, passing code via stdin, and running pylint with `runpy.run_module`), it lacks specific instructions about what needs to be fixed or what outcome would constitute a successful solution. The core of the issue appears to be a diagnostic question (debugging why the stat files are being written to the wrong location) rather than a request for a specific change or feature. As such, it is not fully clear what the desired solution is, though there are enough clues to reasonably interpret the goal as debugging and fixing the issue. Therefore, it falls into the 'REASONABLY_SPECIFIED' category.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-6528": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed bug description, specific commands used, expected vs. actual behavior, and relevant documentation excerpts. The reporter has provided concrete examples of the issue, including what they expected to happen versus what actually happened. The Pylint version and Python version are also provided. All of these details make it possible to understand the problem and work on a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-6556": {
        "explanation": "The issue is about being unable to disable the 'bad-option-value' warning in pylint when trying to suppress other warnings that may not be recognized by older versions of pylint. The issue provides a clear problem description, steps to reproduce, current and expected behavior, and even examples of what has been tried (like using 'disable=bad-option-value' and 'disable=E0012'). This information gives enough context to understand the problem and work toward a solution. However, there are some ambiguities in the exact technical implementation and how the solution should be applied. For example, it's not entirely clear whether the fix should be in the pylint configuration, a code change to pylint, or a workaround in the code using the disable comments. The issue is reasonably specified, but some interpretation is needed to determine the best path forward.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-6820": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed bug description, steps to reproduce the issue, expected behavior, and the actual behavior. The reporter has provided a specific example of the command that causes the issue, the output that is observed, and what the expected output should be. All the necessary information to understand the issue and work on a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-6903": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear bug description, including the specific function causing the problem (pylint.run._query_cpu()), the values read from system files that lead to the issue, and the exact calculation that results in 0. It also includes the error traceback, expected behavior, and even suggests a potential solution (appending 'or 1' to the calculation line). All of these details make it clear what the problem is, why it occurs, and what the desired outcome should be. The issue provides sufficient context about the environment (Kubernetes pod, Python 3.9, etc.) and the specific command that triggers the failure. This level of detail allows for a direct and focused implementation to fix the problem.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-7080": {
        "explanation": "The issue is well-specified. It clearly describes the problem: when using the --recursive=y option, the ignore-paths configuration in the pyproject.toml file is being ignored. The issue provides a detailed example of the configuration being used, the command executed, and the output that results from it. The expected behavior is also clearly stated (that src\\gen\\* should not be checked). All the necessary details are present to understand the issue and to begin working on a solution. There are no ambiguities or missing pieces of information that would prevent a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-7114": {
        "explanation": "The issue is well-specified because it provides a clear problem description, steps to reproduce, current and expected behavior, and additional information about the side-effects. All necessary details for understanding the problem and attempting a solution are included.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-7228": {
        "explanation": "The issue is well-specified. The problem is clear: using the regex pattern with '\\p{Han}' in the .pylintrc configuration file causes an error in Pylint. The error trace is provided, showing that it's related to the regex parsing. The expected behavior (no error) is stated, and the versions of Pylint, astroid, and Python are given, which can help in reproducing and understanding the problem. The configuration is also provided. All necessary information is included to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-7277": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific line of code that causes the issue, a way to reproduce the problem, and the expected behavior.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-7993": {
        "explanation": "The issue is well-specified because it clearly describes the problem, provides the steps to reproduce it, and explains the expected vs actual behavior. The reporter shows that custom braces in the message template work in an older version of pylint but not in a newer version, and provides detailed output from both versions. This gives enough information for a developer to understand what's broken and why it might be happening. The issue has a clear goal - to make the custom brace syntax work in the newer pylint version as it did in the older one.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-8124": {
        "explanation": "The issue is well-specified. The problem is clearly described: Pylint is raising a false positive 'useless-import-alias' error when using a specific pattern for re-exporting symbols in Python packages. The issue explains the structure of the package, the purpose of the pattern (to avoid implicit re-exports for mypy compatibility), and provides concrete examples of the problem in the real world. The expected behavior is clearly stated as no 'useless-import-alias' errors being flagged. The issue also includes diagnostic information like the Pylint version and the exact error output. All necessary information is provided to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-8281": {
        "explanation": "The issue is reasonably specified because it clearly states the current problem with specifying multiple source roots and proposes a desired solution using globbing patterns. However, there are some details that need to be filled in during implementation, such as the exact syntax and behavior of the globbing patterns, how they are parsed, and how they interact with existing command line parsing logic. The implementation would require determining which globbing pattern syntax to use (e.g., Unix shell-style globbing or something else), how to handle edge cases, and how to integrate this with the rest of the application. These are all reasonable assumptions that can be made based on common practices for globbing in command-line tools.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-8312": {
        "explanation": "The issue is reasonably specified. It describes the current problem with supporting globbing patterns in pylint's input specification, references related discussions, and clearly states the desired solution (adding globbing support in a specific line of code). However, there are a few blanks to fill in, such as the exact implementation details of the globbing support and how it should integrate with pylint's existing functionality. A developer would need to research the best way to implement globbing in this context and ensure it works correctly with the rest of the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pylint-dev__pylint-8799": {
        "explanation": "The issue is well-specified because it clearly describes the problem (pylint taking too long to run even when all checks are disabled), provides specific examples with timing data, and explains the impact on usability. The expected behavior is clearly stated. A solution would involve optimizing pylint to short-circuit processing when all checks are disabled to avoid unnecessary computation.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-8819": {
        "explanation": "The issue is well-specified. It clearly describes the problem: the order of enable/disable options in the rcfile affects the outcome, which is counter-intuitive and different from CLI behavior. The reporter provides examples of the current behavior and explains the desired outcome. A solution would involve changing the code that processes the rcfile options to apply enable/disable in a consistent and logical order, regardless of their position in the file. The reporter also explains why the current behavior is problematic and what the expected behavior should be.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-8898": {
        "explanation": "The issue is well-specified. The problem is clearly described: the 'bad-name-rgxs' option in pylint is splitting on commas, causing issues when a regular expression contains commas. The issue includes a configuration example that reproduces the problem, a command to trigger it, and the expected output. The traceback from pylint is provided, showing exactly where the error occurs. The expected behavior is clearly stated: valid regular expressions should be allowed, or a way to escape commas should be added. The pylint version, OS, and environment are also provided. All of these details make it clear what the problem is and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "pylint-dev__pylint-8929": {
        "explanation": "The issue is well-specified. The problem is clearly described with steps to reproduce, current and expected behavior, and relevant version information. The reporter explains that when exporting to JSON, the score is not included even when the '--score=y' option is used. This provides enough information for a developer to investigate the codebase and implement a fix for the JSON output to include the score when appropriate. The JSON format is also shown, so the developer knows the structure to modify.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-10051": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific example of the conflict between `caplog.get_records()` and `caplog.clear()`. The issue provides a detailed explanation of the behavior discrepancy, including code references and a reproducible test case. The expected outcome is also clearly defined through the assertion in the example.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-10081": {
        "explanation": "The issue is well-specified. It clearly describes a bug where the `tearDown()` method is being executed for classes marked with `unittest.skip` when running `pytest --pdb`. The issue provides a detailed description of the problem, including a minimal reproducible example, the expected vs. actual behavior, and environment details (Python version, pytest version, OS). The user has also noted that this is similar to a previous issue but with a class-level skip rather than a function-level skip. All necessary information for reproducing and understanding the bug is present.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-10115": {
        "explanation": "The issue is well-specified and provides a clear problem (replacing an unmaintained dependency) and a proposed solution (copying necessary parts into the project). It explains the context (PyPI 2FA enforcement leading to dependency issues) and the specific dependency in question. The necessary information for implementation is present.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-10343": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is that the deprecation warning for old-style hookimpl does not provide location information (file or plugin name), making it difficult for users to identify the source of the issue among multiple plugins. The request is to modify the error message to include either the plugin name or the Python file where the problematic hook is implemented. This is a clear and actionable request that can be implemented by modifying the warning message to include stack trace information or other source identification details.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-10356": {
        "explanation": "The issue is about how pytest handles markers when multiple inheritance is used. The reporter provides a detailed explanation of the problem, including code examples that demonstrate the issue. They explain that when a class inherits from two base classes with different markers, only one of the markers is picked up by default, and they propose that markers should be merged using the Method Resolution Order (MRO). They've also provided a metaclass implementation that solves the problem by aggregating markers from all base classes in the MRO. The issue also includes a clear expectation of what the desired outcome should be. However, there are some details that would need to be clarified for a complete implementation, such as how to handle marker conflicts and whether this behavior should be enabled by default or require a configuration change. Despite these details, the core of the issue is clear and actionable. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-10442": {
        "explanation": "The issue is reasonably specified as it explains the current behavior, the desired change (keeping directories only for failed tests), and the goal (saving disk space). However, it refers to external links for the full proposal, which might contain additional details important for implementation. Without accessing those links, some nuances might be missing, but the core idea is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-10552": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example that demonstrates the inconsistent behavior of pytest when dealing with staticmethods and classmethods. The user explains which cases work and which do not, and what the expected behavior should be (at least a warning or error for undetected tests). The environment details (Python version, pytest version, OS) are provided. All necessary information to reproduce and understand the problem is given.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-10758": {
        "explanation": "The issue is reasonably specified because it describes a problem with the walrus operator in PyTest, provides a code example, and explains the discrepancy between Python terminal and PyTest. However, there are some missing details like the exact versions of Python and PyTest being used, which could help in understanding the problem better. The test's expected behavior is also not entirely clear for someone unfamiliar with the walrus operator.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-10893": {
        "explanation": "The issue is reasonably specified. It describes two specific problems related to Python 3.12 alpha changes and how they affect pytest. The first issue is the deprecation of `onerror` in `rmtree` causing a warning, and the second is the missing `addDuration` method in `TestCaseFunction`. The issue provides specific GitHub links to the relevant code in pytest and the Python CPython issues, which would help in locating the problem areas. However, there are some details that would need to be filled in, such as how exactly to implement the changes to avoid the warnings and ensure compatibility with Python 3.12. The solution would require modifying the `rm_rf` function to use `onexc` instead of `onerror` and adding the `addDuration` method to `TestCaseFunction`. While the overall direction is clear, the exact implementation details and testing procedures are not specified. Therefore, it is reasonably specified but has some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-10988": {
        "explanation": "The issue is well-specified with a clear description of the problem, a detailed stack trace, and a concrete example of the failure. The user also provides a potential solution or at least a direction to investigate (a try/except block around the `exists()` call). All relevant environment details are included. The root cause seems to be a missing exception handling for the `exists()` call when processing command line arguments, which leads to a crash when the filename is too long. The issue is reproducible with the given example and the expected outcome is clear (pytest should not crash and instead handle the error gracefully).",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-11041": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example that reproduces the error, the error message is provided, and the versions of pytest where the issue occurs and does not occur are specified. The user also points to a specific pull request that may be related to the issue. All necessary information for reproducing and understanding the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-11044": {
        "explanation": "The issue is reasonably specified as it provides context and a clear objective to emit a warning or error when 'testpaths' does not match any files or folders. However, there are some details to consider, such as the severity (warning vs. error) and specific implementation details within the codebase. Despite these, there is a sensible interpretation of the solution requirements.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-11047": {
        "explanation": "The issue is well-specified. The problem is clearly described, including a detailed example of the current behavior versus the desired behavior. The request is to support the `%f` strftime specifier in pytest's log date format options. The user has also provided a workaround and explained why the current workaround is not ideal. This provides enough information to understand the problem and what needs to be implemented to solve it.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-11125": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the error message, the context of the setup, and the versions involved. A software engineer can understand the issue and devise a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-11143": {
        "explanation": "The issue is reasonably specified as it provides the error message, context of the error, and a traceback. The core problem seems to be that pytest's assertion rewriting is failing because it's trying to process a number (int) as a docstring. This is likely happening when the first line of a test file is a number instead of a proper docstring. While some specifics about the exact file structure or code that triggers this issue aren't provided, the information given is sufficient to understand the general cause and work on a solution. The user has also mentioned that the first expression of the file being a number is causing the issue, which gives a clear direction for investigation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-11160": {
        "explanation": "The issue is well-specified with a detailed explanation of the problem, a clear example of the expected vs actual behavior, and even a proposed fix. The minimal working example demonstrates the issue and the test case shows what the expected outcome should be. This provides enough information to understand the problem and implement a solution. The user also provides context about the environment and pytest version, which can be helpful for reproducing the issue.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5205": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the error message, the cause of the issue (incorrect placement of <properties> tag in the XML), and a method to reproduce the issue. The issue also references relevant GitHub issues and provides the version information of the packages involved. All the necessary information is provided to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5262": {
        "explanation": "The issue is well-specified with a clear problem description, a detailed error traceback, and a minimal example to reproduce the problem. The problem is that `_pytest.capture.EncodedFile` is using a binary mode ('b') which causes an error with youtube-dl when it tries to write bytes. The issue includes specific details about the error and how it manifests, making it clear what needs to be fixed. The reporter has provided all the necessary information to understand the problem and reproduce it, which is essential for implementing a solution. The fix likely involves changing the mode used by `_pytest.capture.EncodedFile` to not include 'b' when it is not appropriate.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5281": {
        "explanation": "The issue is reasonably specified because it provides the error traceback, identifies the problematic code in _pytest/terminal.py, and suggests a possible solution. While there is some ambiguity about the type handling (unicode vs bytes) in the function and whether removing the 'u' prefix is the correct solution, the core problem is clear: the unicode literal is causing an error in Jython. A software engineer can attempt to modify the code as suggested and test it to verify if it resolves the issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-5356": {
        "explanation": "The issue is reasonably specified. The user has provided a link to a Travis CI job where the problem occurs, along with the pytest version (4.6.0) and operating system (Ubuntu Xenial). They've also noted that rolling back to 4.6.0 fixed the issue. However, some details are missing that would help in reproducing the issue, such as specific test files or code that is being skipped. The problem seems to be related to a version change in pytest, but without more concrete information on what tests are being skipped and under what conditions, there are still some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-5404": {
        "explanation": "The issue is reasonably specified as it provides a detailed error message, a minimal working example (MWE), and information about the environment and dependencies. However, there are some blanks such as the pip list of the virtual environment, which is noted as not being provided. Despite this, there's enough information to attempt a solution based on the described KeyError and the context of the error when importing from a specific package. The error seems to be related to the 'sty' package and how it interacts with pytest and tox. A reasonable interpretation would be to investigate the interaction between 'sty' and pytest, particularly around the '__wrapped__' attribute handling in the inspect module. Therefore, the issue is reasonably specified enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-5413": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a comparison between normal exception handling and pytest.raises context handling. The reporter provides a minimal, complete, and verifiable example that demonstrates the discrepancy in behavior. They explain the current workaround (using e.value) and make a clear feature request to change the behavior to be more consistent. All the relevant information needed to understand and address the issue is present, including the pytest version and environment details.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5479": {
        "explanation": "The issue is about a UnicodeEncodeError when using pytest.raises with a Unicode match string in Python 2. The error occurs because Python 2 has limited Unicode support and the 'ascii' codec is used by default for string encoding. The goal is to make the Unicode match assertion work correctly with pytest.raises in Python 2.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5495": {
        "explanation": "The issue is reasonably specified. The problem is that the assertion message when comparing byte strings is confusing because it shows the ASCII ordinal instead of the actual character. The user provided examples that demonstrate the issue, and the problem is clearly described as being related to how the diff is displayed for byte string comparisons. While the exact solution is not provided, it is clear what the issue is and what needs to be improved: the assertion message should display the byte string contents in a more understandable way rather than showing ASCII ordinals. This gives a clear direction for solving the problem, even if specific implementation details need to be worked out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-5550": {
        "explanation": "The issue is about the XML format generated by pytest when using the 'junit_family=xunit2' option. The problem is that it doesn't contain a root <testsuites> tag as expected by some tools. The issue also provides a sample output showing the generated XML format which lacks the <testsuites> root tag. Additionally, it mentions that the xunit2 format is supposed to have this root tag. Based on this information, it is clear what the problem is and what the expected fix would be - to modify the code responsible for generating the XML report to include the <testsuites> root tag when the xunit2 format is specified. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5555": {
        "explanation": "The issue is well-specified enough to understand the problem and what needs to be fixed. It provides a clear example of the issue with stepwise not working with xfail strict failures. The expected behavior is that stepwise would skip tests after the first failure, but in this case, all tests are run and marked as failed. The specific configuration and error output are also included, which helps in understanding the problem.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5559": {
        "explanation": "The issue is composed of two separate parts. The first part is a detailed report about a problem with pytest's stepwise functionality and xfail strict failures, including a code example and a test output. It shows a clear problem scenario and expected behavior. The second part is about the recommendation to add `pytest-runner` to `setup_requires` causing unnecessary installations and pip-related issues, with references to documentation and related GitHub issues. Both parts have clear problems and context. However, it's unclear if the user wants to solve both issues or if they are separate issues accidentally combined. The issue description is not very clear on whether these are separate problems or if they are related. This ambiguity makes the issue not well-specified for a single, meaningful solution.",
        "label": "VAGUE"
    },
    "pytest-dev__pytest-5631": {
        "explanation": "The issue is well-specified with a clear error message, a detailed stack trace, and a specific code example that triggers the error. It explains the change in behavior between pytest 3.1.3 and 3.6.0, identifies the specific commit that introduced the issue, and describes the root cause (the 'p.new in sentinels' check failing with NumPy arrays). This provides enough information for an engineer to understand the problem and implement a fix in the pytest codebase.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5692": {
        "explanation": "The issue is reasonably specified. The user is requesting the addition of 'hostname' and 'timestamp' properties to the 'testsuite' XML element in the JUnit XML reports generated by pytest. The user provided examples of the current and desired XML output, which clarifies the intended changes. However, the issue lacks details on how these properties should be determined (e.g., how to obtain the hostname and timestamp), which are necessary for implementation. Despite this, the request is clear enough to attempt a solution with reasonable assumptions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-5787": {
        "explanation": "The issue is reasonably specified because it clearly describes the problem with exception chaining when using pytest-xdist. The user provides two test cases and shows the expected output when running without xdist versus the actual output when using xdist. The problem is that chained exceptions are not displayed correctly when using xdist. A solution would involve modifying the exception serialization logic to include the full chain of exceptions. However, there are some details not specified, such as the exact format in which the chained exceptions should be displayed and the specific part of the codebase that needs to be modified. Despite these gaps, a developer with experience in pytest and xdist could reasonably infer what needs to be done based on the provided information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-5809": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific part of the codebase where the issue occurs, the error being raised, and a clear workaround (changing the lexer from 'python3' to 'text'). The issue also provides a minimal example to reproduce the problem and references a related issue. All necessary information is provided for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5840": {
        "explanation": "The issue is about an ImportError that occurs when using pytest 5.1.2 on Windows, specifically related to folder casing issues. The error message indicates that the import is failing because it cannot find the 'python' module. The user notes that this issue does not occur with pytest 5.1.1. The error message shows the full path to the conftest.py file and the missing module. The problem seems to be related to how pytest 5.1.2 is handling the import path casing on Windows, which is different from 5.1.1. The issue is well-specified enough to understand what the problem is and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-5980": {
        "explanation": "The issue is asking for an alternative to the --result-log option in pytest. The goal is to create a new log file format that is line-based and can be parsed using standard tools. The issue mentions using JSON objects per line, similar to a past example provided. It also suggests writing to the file during `pytest_runtest_logreport` and possibly adding an option to replay tests from the log file. However, there are some ambiguities regarding the exact format of the log file, the specific information to be included, and the details of the replay functionality. Despite these ambiguities, there is a clear direction and a starting point (the `resultlog.py` plugin). The issue also invites discussion on the format, indicating that there is room for collaboration and clarification. Therefore, the issue is reasonably specified, but there are some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-6116": {
        "explanation": "The issue is asking for a one-character shortcut command for the `--collect-only` option in pytest. The main task is clear: create a short, single-character CLI option for this feature. However, the issue is missing the specific character to use for this shortcut, leaving that as an open question for the community. While the overall goal is well-understood, the lack of a specific character means there is some ambiguity about the implementation details. Nevertheless, this is a minor gap, and a reasonable choice could be made (e.g., `-c` for 'collect').",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-6186": {
        "explanation": "The issue is reasonably specified. It indicates that a deprecation warning should be shown when the `junit_family` configuration is not set. However, there are some details that would need to be filled in, such as how to implement the warning, where in the codebase this check should be made, and what the exact message of the warning should be. Despite these gaps, there is a clear and sensible interpretation of what is required: adding a check for the presence of `junit_family` and triggering a deprecation warning when it's missing.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-6197": {
        "explanation": "The issue is well-specified because it clearly describes a regression between pytest versions 5.2.2 and 5.2.3 where pytest is collecting random __init__.py files. It provides a minimal reproduction example using tox, which demonstrates the problem on Linux with Python 3.7.3. The issue also includes the exact error output showing the problem occurs with pytest 5.2.3 but not with 5.2.2. The problem description includes enough information to understand what's wrong (collecting unwanted __init__.py files) and what needs to be fixed (preventing this collection behavior). The reporter has also provided context about why this is a problem (Windows-only packages failing on Linux).",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-6202": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a code example showing the issue, and the reporter has done significant investigation into the source of the problem, tracing it back to a specific line of code in the pytest repository. The issue explains what is wrong (the replacement of '.[' with '[' is causing problems), why it's happening (a specific line of code is doing this replacement), and what the proposed solution is (remove this replacement). The issue also notes the impact (problems with test reporting and test discovery in vscode-python). While there are some technical details that would require investigation (like understanding why this replacement was originally added), the core problem and solution are clearly articulated, making this a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-6323": {
        "explanation": "The issue is reasonably specified. The problem is described as a potential security issue where absolute and non-normalized paths could be used with the 'mktemp' function, which could lead to security vulnerabilities. The proposed solution is to only accept normalized relative paths for 'mktemp'. While the issue provides a general direction, there are some details that would need to be filled in during implementation, such as how exactly to implement the normalization and validation of paths, and what specific behaviors or test cases need to be covered. However, these are standard implementation details that can be reasonably inferred based on common practices for path normalization and security validation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-6680": {
        "explanation": "The issue is well-specified with a clear list of requirements for improving the deprecation documentation for Node.from_parent. Each task is clearly defined, and the expected outcomes are specific and actionable. A developer can directly work on these points without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-6926": {
        "explanation": "The issue description is very minimal and does not provide any clear information about what the problem is, what needs to be fixed, or what the expected outcome should be. The only information given is a reference to a GitHub issue, but without any context or details on the specific task related to 'SysCaptureBinary' and 'decode in writeorg'. It is unclear what the actual task entails or what the requirements are for the solution. Therefore, the issue is vague and lacks the necessary details for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "pytest-dev__pytest-7046": {
        "explanation": "The issue is well-specified. The user provides a clear example of the problem they are facing with pytest's -k option, including code and output. The problem is explained in a way that makes it clear what is expected versus what is happening. A solution would involve understanding why the -k option is matching the test names as well as parts of the path, and how to change that behavior. There's enough detail to start investigating and providing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7122": {
        "explanation": "The issue is well-specified because it clearly explains the problem with keyword selection in pytest when using numbers with the `-k` option. It provides a minimal example with test functions, demonstrates the problematic behavior with command-line outputs, and shows the workaround using underscores. The issue also references the relevant documentation and asks if this is a bug, which indicates a clear understanding of the expected behavior. All necessary information is provided to reproduce and understand the issue, making it possible to work on a solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7151": {
        "explanation": "The issue is well-specified. It clearly describes the problem with `unittest.TestCase` cleanup functions not being invoked on test failure in pytest version 5.4.0 and later. The issue provides a detailed example test, the expected behavior in an earlier pytest version (5.3.5), and the observed behavior in the problematic version (5.4.1). It also includes the system information, pip list, and pytest output for both versions. All these details make it clear what the problem is and how to reproduce it, which is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7158": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: when a test file is located in a directory above the invocation directory, the skip report in pytest shows an incorrect relative path. The issue includes a concrete example with the paths involved, the command used, and what the actual versus expected output should be. This provides enough context for an experienced software engineer to understand what needs to be fixed. The goal is to adjust the relative path in the skip report to correctly reflect the path from the invocation directory to the tested file. The necessary information is present to begin investigating the codebase and making the necessary changes.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7186": {
        "explanation": "The issue is well-specified. It provides a detailed description of the problem, a minimal example to reproduce the issue, steps to reproduce it, and the error output. It also includes the environment details such as OS, Python version, and pytest version. All of these components make it clear what the problem is and how to reproduce and verify the solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7205": {
        "explanation": "The issue is well-specified. The problem is described with a clear example of the code that triggers the BytesWarning, the versions of Python and pytest involved, and the exact command that reproduces the error. The stack trace is provided, the expected behavior is implied by the question at the end about using `saferepr`, and the actual behavior is described (the BytesWarning is raised). A solution would involve modifying the relevant part of the pytest code to use `saferepr` instead of implicitly converting bytes to a string. All necessary information to understand and address the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7231": {
        "explanation": "The issue is reasonably specified. The user wants to add a warning when logging fails, specifically in the case where an expectation is thrown but no warning is generated. The example provided shows a function that logs an error incorrectly (passing multiple arguments after the format string), which is likely causing the failure. The goal is to ensure that when such a failure occurs, a warning is issued so that the test can be marked as failed. Some details about how to implement the warning (e.g., using a specific logging level, raising an exception, or using a custom warning mechanism) are not explicitly provided, but there is a clear intent to handle logging failures with a warning mechanism. The example code and explanation provide enough context for a developer to understand the problem and devise a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-7236": {
        "explanation": "The issue is well-specified. It provides a minimal test case that reproduces the problem, describes the expected and actual behavior, and even includes the output from running the test with and without the --pdb flag. The issue also mentions that the behavior changed between pytest versions 5.4.1 and 5.4.2. All the necessary information is provided to understand the problem and work on a solution. The problem is clear: when running pytest with --pdb, the tearDown method is being executed for skipped tests, which is not the expected behavior.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7283": {
        "explanation": "The issue is well-specified. It provides a minimal test case that reproduces the problem, describes the expected and actual behavior, and even includes the output from running the test with and without the --pdb flag. The issue also mentions that the behavior changed between pytest versions 5.4.1 and 5.4.2. All the necessary information is provided to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7314": {
        "explanation": "The issue is well-specified with a clear problem description, error traceback, and a proposed solution. It explains that the 'letter' variable is being referenced before assignment in the 'pytest_report_teststatus' function when running pytest 4.6. The issue also references a PR that fixed the problem in the master branch and explains that the fix should be trivial by adding a fallback variable value. The error is caused when plugins return report objects in an unconventional state, leading to the if-block branches that declare the 'letter' variable being skipped. The solution is to set the initial value of 'letter' before the if-block cascade. The issue also provides a reference to a related PR and issue. All the necessary information is provided to understand the problem and implement the solution without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7324": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7352": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem is described as a FileNotFoundError related to a lock file in a tmp directory when running concurrent pytest processes. It references a previous issue (#4181) which is not provided, so I wouldn't know the context or previous solutions. The problem is described as having some edge cases where the handling is not correct, but the edge cases are not defined. There is a proposed mitigation involving generating a numbered directory with a random suffix, but the code reference is to a specific version of pytest (4.6.3) which may not be relevant to the current codebase. There is no clear instruction on what the expected outcome should be or what specific changes need to be made to resolve the issue. Therefore, there is too much missing information to attempt a solution.",
        "label": "VAGUE"
    },
    "pytest-dev__pytest-7432": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the `--runxfail` option causing incorrect skip location reporting when using `@pytest.mark.skip` or `skipif`. The expected behavior is outlined, the actual incorrect behavior is shown with examples, and the specific location of the bug in the codebase is hinted at. A developer would be able to reproduce the issue, understand what the correct behavior should be, and locate where in the code to start debugging and fixing the problem.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7466": {
        "explanation": "The issue is reasonably well-specified, but there are some areas that require interpretation. The main goal is clear: to support the NO_COLOR environment variable to disable colored output even when attached to a TTY. The behavior of this variable is described, as well as an additional extension called FORCE_COLOR. However, the implementation details are not specified (e.g., how to detect if the application is attached to a TTY, how to handle the interaction between NO_COLOR and FORCE_COLOR). These details would need to be researched or inferred from the codebase. Overall, there is a clear direction for a solution, but some blanks need to be filled in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-7468": {
        "explanation": "The issue is reasonably specified. The problem is that when a user provides a log file path with a subdirectory that does not exist, the application crashes with a FileNotFoundError. The user suggests a potential solution involving checking if the directory exists and creating it if it does not. However, there is some ambiguity around whether it is appropriate to allow passing directory paths to the --log-file option. This requires interpretation on the part of the developer to determine the best approach.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-7481": {
        "explanation": "The issue is reasonably specified, but there are a few areas where more information would be helpful. The problem is a UnicodeEncodeError on Windows when using pytest 6 with pytest-bdd and pytest-instafail. The test scenario involves pasting an emoji into the command line and expecting no crash. However, the error occurs during the printing of the traceback, which might be a symptom of a deeper issue. More information would be useful about how to reproduce the issue consistently, what the expected behavior should be, and whether it's specific to pytest 6 or other versions. Despite these gaps, there is a clear path forward to investigate and address the issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-7490": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: dynamically adding an xfail marker in pytest 6 no longer behaves as it did in 5.x, and instead of treating the failure as an xfail, it raises an error. A minimal reproduction example is provided, along with the expected behavior (as in 5.x) and the actual behavior (in 6.0.0rc0). The versions of pytest and the operating system are also mentioned. This information is sufficient to understand what the issue is and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7499": {
        "explanation": "The issue is reasonably specified. It describes a specific problem with pytest's raises functionality where the match string is not being recognized as a regex pattern, leading to confusing error messages when the pattern and actual message appear to be identical. The issue includes a minimal example and shows the current error output. However, some implementation details about how pytest should handle regex patterns in match strings are implied rather than explicitly stated. A developer would need to understand how pytest's match parameter works with regex by default and why passing a non-regex string would cause this issue. The solution would involve modifying pytest to detect if parentheses need to be escaped in the match string, but the exact implementation approach isn't fully specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-7500": {
        "explanation": "The issue is well-specified and provides a clear explanation of the problem, including the error message, the conditions under which it occurs, and the potential solution. The reporter has also provided detailed context about their environment and the test setup. The proposed solution is to swap the two `for` statements within the `cleanup_numbered_dir` function, which is a clear and actionable task. The reporter has already tested this solution and found it to be effective in their testing. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7521": {
        "explanation": "The issue is well-specified. The user has provided a detailed description of the problem, including test cases that reproduce the issue in both pytest 5 and pytest 6. They've included the exact error messages and a comparison of the package versions. The user also explains the expected behavior versus the actual behavior, specifically that capfd.readouterr() in pytest 6.0.0rc1 converts \\r to \\n. The problem is clearly defined with enough context to understand the impact on the borgbackup package and the change in behavior between pytest versions. The user is indicating that this is a regression and that the change was not documented in the changelog or in the documentation. This level of detail allows for a targeted solution to investigate and fix the change in behavior of the capfd.readouterr() function in pytest 6.0.0rc1.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7571": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It includes a clear description of the problem, a reference to the relevant documentation, and a minimal example that demonstrates the issue. The problem is that the caplog fixture is not restoring log levels after a test as documented, and it provides a way to reproduce the issue. This information is sufficient to understand what needs to be fixed and how to verify the fix.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7637": {
        "explanation": "The issue is reasonably specified.  It explains the context of warnings being postponed in version 6.0 due to the '2 versions minimum with warnings' policy.  It references a specific pull request where the suppression occurred and states the intention to reintroduce the warnings in version 6.1.  However, some details are missing.  The specific warnings that were postponed are not listed.  A developer would need to examine the referenced pull request to identify which warnings were suppressed.  Additionally, the exact implementation details of how to reintroduce the warnings are not provided.  Despite these missing details, the overall goal is clear and a developer with knowledge of the codebase and the referenced pull request could proceed with a meaningful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-7648": {
        "explanation": "The issue is well-specified because it provides the following key information needed for a solution:\n\n1. The specific problem: Pylint is reporting unimplemented abstract methods in a custom pytest collector starting with pytest 6.0.0\n\n2. The context: The collector is based on pytest.File and only implements the collect() method\n\n3. The specific methods that are causing issues: get_closest_marker, gethookproxy, and isinitpath\n\n4. The relevant code: The class definition is shown (though the full implementation isn't visible)\n\n5. The environment details: Python 3.8.0, pytest 6.0.1, and other relevant versions\n\n6. A link to the full source code\n\nThis information provides a clear understanding of the problem and what needs to be fixed. A solution would involve either implementing these methods in the custom collector or finding a way to suppress these specific pylint warnings if the methods don't need to be implemented.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7939": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The current code shows that the --stepwise-skip option is available but lacks a shorthand version like --sw for --stepwise. The expected solution is to add a shorthand --sw-skip option to maintain consistency with the existing --sw shorthand. The problem and desired outcome are clearly described, leaving little ambiguity about what needs to be done.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7982": {
        "explanation": "The issue is well-specified. It clearly states that symlinked directories are not being collected as expected since pytest 6.1.0. The problem is attributed to a specific commit, and the solution involves removing the `follow_symlinks=False` parameter that was incorrectly added. The reporter even mentions that a PR is coming, which implies they have a clear understanding of the fix. The description provides enough information to locate the issue in the codebase and implement the necessary change.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-7985": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The description is very brief and lacks details about what the `--strict` option does, why it should be deprecated, and how it should be deprecated. Without understanding the context of the `--strict` flag and the discussion in the referenced GitHub issue, it would be challenging to implement a solution. The provided description only includes a comment from @The-Compiler expressing an opinion about the deprecation plan, but it doesn't explain what the problem is or what the desired outcome should be. There's no clear action item for a developer to implement.",
        "label": "VAGUE"
    },
    "pytest-dev__pytest-8022": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with specific details including the command that fails, the specific code location in the codebase that is causing the issue, the commit that introduced the problem, and a reference to failing tests that demonstrate the issue. The expected behavior is also clearly outlined - that doctest collection should not only pick up 1 doctest when the module is __init__.py. With this information, an experienced software engineer would have sufficient context to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-8055": {
        "explanation": "The issue is reasonably specified. It mentions that Python 3.8 introduced a new hook called sys.unraisablehook and that pytest should set this hook to associate unraisable exceptions with tests. While the exact implementation details are not provided, a software engineer with experience in Python and pytest would be able to interpret what is required. The main task would be to implement the logic in pytest to set the sys.unraisablehook appropriately so that unraisable exceptions can be associated with tests. There are some blanks to fill in regarding how exactly to implement this, but the overall goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-8250": {
        "explanation": "The issue is well-specified. It clearly explains the problem with faulthandler when used with Twisted Logger and pytest --capture=no. It provides the environment, detailed steps of what is happening, and even includes a patch that mitigates the problem. All necessary information is included to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-8365": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, and the error message. It also provides context about the environment and the specific scenario where the problem occurs. This information is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-8399": {
        "explanation": "The issue is well-specified because it includes a minimal example, a clear description of the expected behavior, and the problem caused by the change in v6.2.0. It also explains the impact on a code-quality CI script. All the necessary information is provided to understand the problem and the desired solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-8428": {
        "explanation": "The issue is reasonably specified because it provides the context of a follow-up from another issue (#1014) and outlines the main task of generating an error when a `@pytest.mark` is applied to a fixture. It also references a documentation file that may need updating. However, there are a few details missing for a complete understanding, such as the expected error message format, how the check for marks on fixtures should be implemented, and whether the error should be raised during fixture registration or test execution. Despite these gaps, the task is clear enough to begin working on a solution with reasonable assumptions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-8447": {
        "explanation": "The issue is reasonably specified as it provides detailed error messages and stack traces, along with steps to reproduce the problem using specific tools and commands. It also mentions the affected plugins and the context of the error. However, it lacks direct instructions on how to resolve the issue, requiring the engineer to interpret the problem and devise a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-8463": {
        "explanation": "The issue is not well-specified and has multiple parts that are confusing. The first part discusses `startpath`/`fspath` parameter regressions and hookspecs, but the context and specific problem aren't clearly defined. The second part about color formatting with FAILED tests is more concrete, but still lacks a clear description of what the problem is (beyond the color being wrong). The two issues seem unrelated, but are presented together. Without clear steps to reproduce the first issue or a detailed explanation of what the expected behavior is for the `startpath`/`fspath` issue, it's hard to determine what needs to be fixed. Additionally, the issue description has some typos and is difficult to parse in places.",
        "label": "VAGUE"
    },
    "pytest-dev__pytest-8641": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the specific log format string that causes the issue, and it points out the exact location in the codebase where the problem occurs. The issue explains that the ColoredLevelFormatter.LEVELNAME_FMT_REGEX fails to match the format string due to the presence of a precision bit. This gives a clear direction for the solution - the regex pattern needs to be updated to account for potential precision specifications in the levelname format. The issue provides enough context and technical details for an experienced developer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-8906": {
        "explanation": "The issue is reasonably specified and provides a clear scenario and problem. It explains the current limitations and the desired outcome, including code examples and a proposed solution. However, some details about the implementation and specific changes to the pytest codebase are not provided, which may require some interpretation and decision-making when implementing the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-8952": {
        "explanation": "The issue is reasonably specified. It describes a need to enhance the `RunResult` class in a testing framework (likely pytest) to add functionality for asserting the number of warnings. The current `assert_outcomes()` method does not provide a way to specifically check for warnings. The example given is clear and suggests a direction for the implementation. However, some implementation details are not specified, such as how the warnings are stored within the `RunResult` object and how to extract them. These are reasonable assumptions one can make based on the context of testing frameworks, but they are not explicitly stated in the issue. Therefore, it's reasonably specified but not perfectly detailed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-9064": {
        "explanation": "The issue is well-specified because it includes a detailed description of the problem, the expected behavior, and the actual behavior. It also provides a clear example to reproduce the issue and the current output versus the expected output. The version information and the test case are also included. All the necessary information to understand the problem and reproduce it is provided. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-9066": {
        "explanation": "The issue is reasonably specified.  The goal is clear: to modify the error message to include the fully qualified name of the class causing the deprecation warning.  However, there is some ambiguity in the implementation details, such as where in the codebase the error message is generated and how to extract the class name.  A developer would need to locate the relevant code in the pytest project to implement the change.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-9249": {
        "explanation": "The issue is reasonably specified. The problem is clear: test IDs with slashes and square brackets cause issues when using the `-k` option in pytest. The user provides an example of a test where the auto-generated ID includes a slash, and it's impractical to manually specify IDs for many parameters. Additionally, there's a suggestion to use a shell-safe format like colons instead of square brackets for better compatibility. While there are some implementation details to consider, the core issue and desired outcome are well-explained, making it possible to proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-9279": {
        "explanation": "The issue is reasonably specified as it provides detailed error messages and stack traces, along with steps to reproduce the problem using specific tools and commands. It also mentions the affected plugins and the context of the error. However, it lacks direct instructions on how to resolve the issue, requiring the engineer to interpret the problem and devise a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-9475": {
        "explanation": "The issue is well-specified and provides clear context on the problem caused by the new `deselected` parameter in `assert_outcomes()`. It explains the incompatibility, gives examples of affected projects, and even raises specific questions about how to handle it for 7.0 and future releases. A software engineer would be able to understand the issue, reproduce it, and implement a solution or at least document the change appropriately.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-9624": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The issue is about a TypeError: __init__() missing 1 required positional argument: 'test_method'. However, the issue description lacks a detailed explanation of the bug or problem being experienced. The provided information includes a traceback from a failed test, some pip list outputs, and information about the pytest and OS versions, but it doesn't explain what the expected behavior should be, or how to reproduce the issue. The user also mentions that the issue happened only once and that they will update if they can reproduce it outside of GitHub Actions CI. Without more information on what the problem is, how to reproduce it, and what the expected outcome should be, it's not clear what a successful solution would look like. Therefore, it is almost impossible to understand what you are being asked to do without further information.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "pytest-dev__pytest-9646": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce, expected behavior, and environment information. The user provided a script to reproduce the problem, relevant output, and a detailed explanation of the issue with Pytest 7 not ignoring certain warnings as configured in the pytest.ini file. All necessary details for a meaningful attempt at a solution are provided.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-9681": {
        "explanation": "The issue is well-specified. The problem is described in detail with a clear explanation of the regression introduced in pytest 7.0.0. The issue provides a complete example project structure, setup.cfg content, and the exact error message. The steps to reproduce the problem are clear, and the expected versus actual behavior is explicitly stated. The user has identified that the presence of conftest.py is causing the issue, and that this was not a problem in previous pytest versions. This level of detail allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-9709": {
        "explanation": "The issue is well-specified and provides a clear example of the problem with `pytest.approx()` when comparing sets. It explains the root cause in the code (the use of `zip()` which relies on order) and proposes potential solutions. The example code demonstrates the failure case and the explanation of why it fails is thorough. This provides enough information to begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-9780": {
        "explanation": "The issue is reasonably specified because it provides context about the problem (pytest not picking up conftest.py with version 7.1.0), a potential cause (registration of the `slow` mark), and a link to the test suite example and pytest.ini file. However, there are a few blanks to fill in, such as the exact error message, specific changes in version 7.1.0, and steps to reproduce the issue locally. Despite these gaps, there is enough information to make a sensible interpretation and attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "pytest-dev__pytest-9798": {
        "explanation": "The issue is well-specified. It clearly describes the problem, provides the environment details, a minimal example to reproduce the bug, and the expected vs actual results. All necessary information to understand and address the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "pytest-dev__pytest-9911": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem (empty tuple passed to pytest.raises() or pytest.warns() always results in an error), and provides concrete examples of the desired error message. It also mentions the bonus points (pytest.raises(None)) and that the same logic should apply to pytest.mark.xfail(). The issue provides a clear direction for what needs to be fixed and what the expected outcome should be.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10198": {
        "explanation": "The issue is reasonably specified. It references a previous discussion and another issue, which provides context. However, it does not give explicit details on the exact implementation of the get_feature_names method for the CategoricalEncoder, such as the parameters it should take, what it should return, or how it should handle different scenarios. The mention of consistency with PolynomialFeature suggests that there are existing patterns to follow, but without specific details, some interpretation is still required.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10297": {
        "explanation": "The issue is well-specified. The problem is clearly described: the 'store_cv_values' parameter is not supported in the 'RidgeClassifierCV' class despite being mentioned in the documentation. The steps to reproduce the error are provided, along with the expected and actual results. There is also information about the versions of the packages involved. All of this information is necessary for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10377": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, steps to reproduce the bug, expected and actual results, and environment information. The problem is about the f1_score function in scikit-learn, which is calculating the macro average incorrectly when the labels parameter includes column index 0 with label indicator inputs. The issue provides a minimal, complete, and verifiable example that demonstrates the discrepancy in the calculation. The expected and actual results are clearly defined, making it possible to test any proposed solution. All the necessary information is provided to understand the problem and verify a solution, so it is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10382": {
        "explanation": "The issue is well-specified and clear. The problem is that the dtype argument in TfidfVectorizer is being ignored, resulting in outputs of np.float64 instead of the specified dtype. The issue provides a clear code example that reproduces the problem, shows the expected and actual results, and gives the relevant versions of the libraries involved. The description is concise and unambiguous. All necessary information to understand and reproduce the issue is provided, making it possible to create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10397": {
        "explanation": "The issue is well-specified. It provides a clear, reproducible example of the problem occurring when using integer values for the 'alphas' parameter in RidgeCV, along with the specific error message. It also explains the workaround (using a float) and the expected behavior (the issue should be handled internally by the library). A developer can use this information to investigate why the integer alpha values cause an error and implement a fix to handle them appropriately within the RidgeCV class.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10427": {
        "explanation": "The issue is well-specified. It clearly states that the `load_sample_images` function is using a deprecated `imread` function from SciPy. The warning message provides the version information (deprecated in 1.0.0, removed in 1.2.0), which helps in understanding the urgency. The solution would involve replacing `imread` with the recommended alternative, which is typically `imageio.imread` or `PIL.Image.open` depending on the SciPy version and project requirements. There is no ambiguity in what needs to be done - replace the deprecated function with a supported one.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10428": {
        "explanation": "The issue is reasonably well-specified, but there are some blanks to fill in. It clearly states the goal of adding a common test to ensure invariance of predictions/transformations across different subsets of data, and provides a code snippet with the expected behavior. However, there are some details that would need to be clarified or interpreted when implementing the solution, such as how to handle different estimator types and methods, what exactly constitutes a valid mask, and how to integrate this test into the existing testing framework. The reference to an existing GitHub issue (#9174) also suggests that there may be additional context or requirements that are not explicitly stated here.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10443": {
        "explanation": "The issue is well-specified. The problem is clearly described: the dtype argument in TfidfVectorizer is being ignored, as the output is always np.float64 instead of the specified dtype. The issue provides a minimal, reproducible example that demonstrates the problem, along with the expected and actual results. This gives a clear understanding of the discrepancy and what needs to be fixed. The versions of the relevant libraries are also provided, which is helpful for context.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10452": {
        "explanation": "The issue is reasonably specified. The problem is that the PolynomialFeatures class does not support sparse data, and the desired outcome is to add support for sparse data. While the implementation details are not specified, the task is clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10483": {
        "explanation": "The issue is about moving imputation out of preprocessing in the scikit-learn library. The issue provides some reasoning for this change (imputation being a learning task of its own, and preprocessing getting cramped) and provides some examples of where different imputers could be placed (e.g., KNNImputer in neighbors, MICE in an unspecified location). The issue also suggests that imputers should be in their own module (sklearn.impute) rather than being grouped by function in preprocessing.\n\nHowever, the issue has some ambiguities. For example, it doesn't clearly specify where MICE should be placed, though it's implied that it should be in its own module. The issue also doesn't provide clear guidance on how to handle the transition from the current implementation to the new structure, or what specific changes need to be made to the codebase.\n\nDespite these ambiguities, the overall goal is reasonably clear: to move imputation out of preprocessing and into its own module, with imputers organized by their algorithm type rather than their function. A software engineer could make a reasonable attempt at implementing this change, though they might need to make some decisions about specific implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10495": {
        "explanation": "The issue is well-specified. The problem is that the function `check_array` with `dtype='numeric'` is not failing when the input contains strings. The user wants the function to raise an error in such cases. There is a clear example provided (`check_array(['a', 'b', 'c'], dtype='numeric')`), and the desired behavior is clearly stated: to raise an error or attempt to coerce if the data doesn't have a numeric dtype. The issue also references another issue (#9342) which provides further context. All necessary information for solving the problem is provided.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10508": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem, including the expected behavior (empty arrays should be returned when transforming empty lists) and the actual behavior (TypeError is raised for string inputs). The issue also includes a reproducible code example that demonstrates the discrepancy in behavior depending on the input data type. The Python and scikit_learn versions are specified, and the problem is clearly defined as a bug in the LabelEncoder's transform method when handling empty lists with string inputs. All the necessary information is provided to understand the issue and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10558": {
        "explanation": "The issue is well-specified. It clearly states the intent to deprecate the `axis` parameter of the `Imputer` class, provides reasoning for the change, and references a specific issue (#9463). The task is clear: remove the `axis` parameter, deprecate it, and ensure the implementation aligns with the stated reasons. The proposed solution (using `FunctionTransformer` for row imputation) and the implementation details (fitting, transforming) are also described. The issue is actionable and the success criteria are well-defined.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10581": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example that demonstrates the unexpected behavior of the ElasticNet fit method. The example shows that when `copy_X=True` is set, the input data X should not be modified during the fit process. However, the current implementation overwrites X even with `copy_X=True` when `check_input=False` is passed to fit(). The expected behavior is that X remains unchanged when `copy_X=True`. This is a clear and specific problem that can be addressed by modifying the ElasticNet implementation to ensure it does not modify the input data when `copy_X=True`, regardless of the `check_input` parameter. The issue is well-documented with a minimal working example that can be used to reproduce and test the fix.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10777": {
        "explanation": "The issue is reasonably specified. The reporter is suggesting that an error should be raised when ngram_range[0] is greater than ngram_range[1], which is a specific and actionable improvement. While there is some ambiguity about the current behavior, a reasonable interpretation is to implement a check and raise a ValueError in that case. The task is clear enough to proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10803": {
        "explanation": "The issue is asking for the ability to pass a weight for each sample in kernel density estimation (KDE) within the scipy.stats.gaussian_kde function. The user has provided a reference to a Stack Overflow post with an adapted version of this functionality. While the request is clear in intent, it lacks specific details on how the weighting should be implemented, what kind of weights are expected (e.g., probabilities, counts, etc.), and how these weights should influence the KDE computation. Additionally, the issue does not specify any particular constraints or requirements for the implementation. Therefore, there are some blanks to fill in, but a sensible interpretation of what is required for a successful solution can be made based on common practices in weighted KDE implementations. Hence, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10844": {
        "explanation": "The issue is well-specified with a clear description of the problem, the line of code causing the issue, the conditions under which it occurs, and a proposed fix. All necessary information is provided to understand and reproduce the issue, as well as to implement the suggested solution. There are no ambiguities or missing details that would prevent a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10870": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The description explains the problem in Gaussian mixtures when n_init > 1, where the lower_bound_ is not the maximum across all initializations. It provides a specific fix by adding a line of code to BaseMixture.fit(). The issue also includes steps to reproduce the problem, expected and actual results, and mentions which test should be updated. All the necessary information is present to implement the fix and update the test.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10881": {
        "explanation": "The issue is well-specified. The problem is clearly described - when LogisticRegressionCV does not converge, no warning is given. The user provides a clear example of the problem with reproducible code, explains what they observed (all but 1 variable having 100 iterations), and what they expect (some kind of warning about non-convergence). The context is also provided with versions of the software. A solution would involve adding a warning when the model doesn't converge within the maximum iterations. This is a clear and specific task for a developer to implement.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10899": {
        "explanation": "The issue is reasonably specified.  The user is trying to persist a TfidfTransformer by saving its parameters and then rebuilding it, which works for CountVectorizer but not for TfidfTransformer because the idf_ attribute cannot be set.  The user provides code examples for both the working CountVectorizer case and the problematic TfidfTransformer case, and explains the limitations they're facing.  However, some details are missing, such as exactly how the TfidfTransformer should be modified to allow setting idf_ and what the expected behavior should be.  The solution would likely involve modifying the TfidfTransformer class to allow setting the idf_ attribute, but the exact implementation details are not provided in the issue description.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10908": {
        "explanation": "The issue is well-specified. The problem is clearly described with code examples showing the current behavior and the expected behavior. The reporter explains that when providing a vocabulary parameter to CountVectorizer, get_feature_names should not raise a NotFittedError even if the vectorizer hasn't been trained. The issue includes specific examples of the current behavior, explains what the expected behavior should be, and provides code demonstrating both scenarios. This provides sufficient information for a developer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10913": {
        "explanation": "The issue is reasonably specified as it provides a clear example of the desired behavior and the current problem. However, there are some blanks to fill in, such as the exact implementation details of the 'ignore_unseen' parameter and how it should handle different scenarios. The example given is helpful and gives a good idea of the intended functionality.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10982": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the current behavior of the `RandomizedSearchCV` class in scikit-learn when `n_iter` is greater than the size of the parameter grid, and the desired change is clearly explained. The issue also provides a specific suggestion for a solution (adding an optional parameter to the constructor with a default value). The motivation for the change is also given, making it clear why this change would be useful. The issue is therefore well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-10986": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the steps to reproduce the bug, expected results, actual results, and even a proposed fix. The issue explains that when using LogisticRegression with multi_class='multinomial' and warm_start=True on binary outcomes, the model produces different predictions after multiple fits, leading to worse performance. The root cause is identified as an issue with broadcasting the coef into w0 in the code. The proposed fix is to modify the code to handle the case when n_classes == 1 differently. With all this information, an experienced software engineer would have sufficient context to create a PR that resolves the bug.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11040": {
        "explanation": "The issue is well-specified. It clearly describes the problem (missing parameter validation for float n_neighbors in Neighbors estimator), provides a code example that reproduces the error, explains the current error message and where it occurs, and suggests what needs to be done (catch the error earlier with a better message or cast to integer, but prefers a better error message). It also specifies that the solution should handle both the case when n_neighbors is passed as a constructor argument and when it's passed as a parameter to kneighbors(). This provides sufficient information for implementing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11042": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of what is expected versus what is actually happening. The steps to reproduce the issue are provided, including the code that demonstrates the problem. The expected and actual results are clearly stated, which allows for verification of a solution. The versions of the relevant packages are also mentioned, which can be important for debugging. All the necessary information to understand and address the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11043": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the default behavior of FunctionTransformer converting DataFrames to arrays is causing confusion for users. The proposed solution is to change the default 'validate' parameter to 'array-or-frame', which would pass DataFrames to the function without conversion. The issue also suggests a deprecation cycle for backwards compatibility. All necessary information to implement the change is provided, making it possible to create a PR that addresses the issue.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11160": {
        "explanation": "The issue is reasonably specified because it clearly expresses the desire to add output options to the classification_report function in scikit-learn, such as pd.DataFrame or xr.DataArray. The user also mentions a helper script and there is a reference to a pull request that addresses part of the issue by adding a Dictionary of Dictionaries output. While there are some details to work out regarding which specific output formats to support and how to implement them, the overall goal is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11206": {
        "explanation": "The issue is a pull request titled 'increment_mean_and_var can now handle NaN values'. However, the description is missing the actual problem statement or feature request. It refers to checking if the 'increment_mean_and_var' function gives a green tick without failing in numerical stability, but it's not clear what specific changes or tests are needed. The reference to #10457 suggests a related issue, but without its context, it's ambiguous what exactly needs to be implemented or fixed. The implementation details and expected outcomes are not provided, making it impossible to understand what the successful solution would look like without further information.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "scikit-learn__scikit-learn-11264": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the `randomized_svd` function being slow for `dok_matrix` and `lil_matrix` types in Scikit-Learn. The problem is demonstrated with concrete steps and code to reproduce the issue, showing significant time differences between different sparse matrix formats. The expected and actual results are clearly outlined, and the versions of the libraries being used are provided. This information is sufficient to understand the issue and begin working on a solution, such as optimizing the handling of these sparse matrix formats or adding a warning when these formats are used. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11281": {
        "explanation": "The issue is reasonably specified. The problem is described, and the current differences between mixture models and clusterers are outlined. However, there are some blanks to fill in, such as the specific steps to align the mixture models with the clusterer interface. The goal is clear, but the implementation details may need further consideration.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11310": {
        "explanation": "The issue is well-specified. The request is to add a new attribute `refit_time_` to the `BaseSearchCV` class in scikit-learn to track the time taken to refit the best model on the full dataset after hyperparameter optimization. The issue provides a clear explanation of the problem, the desired solution, and the use case (OpenML.org). It also includes a code example showing how the current attributes (`mean_fit_time` and `mean_score_time`) are used and explains the limitations when using `n_jobs != 1`. This is sufficient information to implement the requested feature.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11315": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal example that reproduces the error. The error message is included, which indicates that `_BaseCompostion._set_params` is raising a `ValueError` when there are no estimators. The expected behavior seems to be that it should not raise an error in this case. The issue is also related to another issue (#11315), which provides additional context. The task is to fix the error handling in `_BaseCompostion._set_params` so that it can handle the case where there are no estimators without raising an error.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11333": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal example that reproduces the error. The error message is included, which indicates that `_BaseCompostion._set_params` is raising a `ValueError` when there are no estimators. The expected behavior seems to be that it should handle the case of no estimators without raising an error. This is a clear and specific issue to fix.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11346": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example, the conditions under which the error occurs, and the error traceback. The error is raised when using the `SparseCoder` with `n_jobs > 1` and a large `data_dims` value. A minimal example is provided to reproduce the error. This information is sufficient to understand the issue and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11391": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem, including the error message and the code that triggers it. The issue also explains the root cause - a missing check between X and missing_values dtype in the _get_mask function. The description gives enough information to understand the problem and implement a solution by adding appropriate dtype checking in the _get_mask function. However, there are some implementation details that would need to be worked out, such as exactly what check to implement and how to handle different dtype combinations.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11496": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the expected and actual results. The example is reproducible, and the problem is clearly described with a code snippet. The user explains the discrepancy between the current behavior and the expected outcome. This information is sufficient to understand what the bug is and what the desired outcome would be.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11574": {
        "explanation": "The issue is reasonably specified.  It mentions the problem (IsolationForest contamination deprecation in __init__ not in fit), and the general solution (move the deprecation and fix the tests).  However, there are some details that would need to be filled in by the developer, such as how exactly to move the deprecation and what specific tests need to be fixed.  A developer with knowledge of the codebase would be able to interpret these details and provide a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11578": {
        "explanation": "The issue is well-specified because it clearly explains the problem with the `LogisticRegressionCV` using the wrong scoring method for `multi_class='multinomial'`, provides a detailed analysis of the cause (code references and explanation of the default setting), and includes a minimal example to reproduce the issue. It also suggests a potential fix (modifying line 922) and even includes a WIP pull request that attempts to address the problem. The issue has all the necessary information for an experienced software engineer to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11585": {
        "explanation": "The issue is well-specified because it clearly identifies the problem with the `SparsePCA` class's `transform()` method, provides a proposed fix with two possible options, and includes steps/code to reproduce the issue along with expected and actual results. The problem is specific, and the proposed solutions are clear, allowing for a meaningful attempt at a solution without ambiguity.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11596": {
        "explanation": "The issue is reasonably specified. The request is to add a function similar to pandas.show_versions(), which suggests a clear direction. The mention of including numpy blas binding information indicates a specific requirement. However, some details on how exactly to implement this (e.g., which specific system_info invocations to use, the format of the output) are not provided, requiring interpretation and possibly some research into how pandas implements its show_versions() function. Despite these minor gaps, the overall goal is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-11635": {
        "explanation": "The issue is reasonably specified. The problem is clear: the SelectFromModel.transform method uses check_array with force_all_finite=True, which causes a ValueError if the input contains infinite or NaN values. However, the issue notes that these values may not be used in the transform method and that some models (like tree-based models) can handle such values. The solution would involve changing the parameter for check_array in the transform method of SelectFromModel. While there might be some details about the exact implementation and potential side effects that need to be considered, the core issue and proposed change are clear enough to form a meaningful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12421": {
        "explanation": "The issue is well-specified. The problem is clearly described: the 'core_distances_' attribute in the OPTICS implementation does not match the documentation, which states that points which will never be core have a distance of infinity. The issue also provides a clear example with code from both scikit-learn and R showing the discrepancy. The goal is to fix the inconsistency so that non-core points have a core distance of infinity as the documentation claims. This is a concrete problem with a clear expected outcome.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12462": {
        "explanation": "The issue is reasonably specified as it provides a clear problem description, a minimal working example (MWE), error trace, versions, and a proposed workaround. The main issue is that the Scikit-learn `.score()` method is generating an error when used with Dask DataFrames, and the error trace shows that the error is occurring in the `numpy.asanyarray()` function. The issue also includes a proposed solution involving a `try-except` block to handle the case where shape doesn't return a tuple. While there are some implementation details to work out (like exactly how to implement the `try-except` fix and where to apply it), the general problem and desired solution are clear enough to make a meaningful attempt at a solution. The issue also references a related Dask issue for additional context.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12486": {
        "explanation": "The issue is reasonably well-specified as it provides a clear description of the problem, a code example to reproduce the error, and the specific error message. However, it does have some missing information that would need to be interpreted to create a complete solution. For example, the exact changes needed to handle the case where the model produces predictions with only one column when the ROC AUC scoring requires two classes. A solution would need to properly validate the model type and data before attempting to access the second column of predictions. The problem is clear enough to guide development, but some interpretation is still needed to implement the fix correctly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12583": {
        "explanation": "The issue is reasonably specified.  It clearly identifies the goal of adding an `add_indicator` parameter to imputers, particularly the SimpleImputer, which would stack a MissingIndicator transform onto the output of the imputer's `transform` method.  While the issue doesn't provide all the implementation details (like exactly how the MissingIndicator should be configured or how the stacking should be performed), the core functionality and the expected integration with existing components are clear enough to begin a meaningful solution attempt.  The scikit-learn documentation links offer helpful context for understanding the involved classes and their expected behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12585": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, steps to reproduce the issue, expected vs. actual results, and even a proposed fix. The user explains the context (wrapping sklearn estimators) and provides a specific error traceback. This provides all the information needed to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12625": {
        "explanation": "The issue is well-specified. It includes a clear description of the problem, steps to reproduce the error, expected vs. actual results, and relevant version information. The error occurs when using scikit-learn's preprocessing.scale on a pandas.Series object, which should be an acceptable array-like input according to the documentation. The issue provides a minimal code example that reproduces the error, and explains that version 0.19.1 works correctly while 0.20.0 does not. This provides all the necessary information to understand and address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12656": {
        "explanation": "The issue description is not fully provided, and the content seems to be a mix of a pull request description and a template for a new issue. There is no actual problem description or use case provided. The text mentions 'Fix Issue #10580' but does not explain what the issue is or what needs to be fixed. There are also other references to #10582 but no context is given for these references. The content that is here is about removing a 'labels' parameter from a 'hamming_loss' function, but without knowing why this parameter needs to be removed or what problem it was causing, it's difficult to determine if this is the correct solution. The description also includes a lot of template text that has not been filled in, such as 'What does this implement/fix? Explain your changes.' which has been left blank in the second section. Overall, there is not enough information to understand the problem that needs to be solved or how to verify that a solution is correct. This is not enough information to make a meaningful attempt at a solution.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "scikit-learn__scikit-learn-12682": {
        "explanation": "The issue is reasonably specified because it describes a problem with the `SparseCoder` class not exposing the `max_iter` parameter for the `Lasso` algorithm when using `lasso_cd`. The issue explains that this leads to a warning about the estimator not converging in a specific example. It also suggests a general direction for the solution, which is to allow users to specify additional parameters for the estimator used in `SparseCoder`. While some details about the implementation or specific behavior are not mentioned, the core problem and desired outcome are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12704": {
        "explanation": "The issue is well-specified enough to understand the problem and the error being encountered. The user provided a code example that reproduces the error, the stack trace that shows where the error is occurring, and a description of the context in which the error is encountered. This provides enough information for a software engineer to investigate the source code of the ColumnTransformer in scikit-learn and find a solution to the regression issue. The request for a fix in version 0.20.2 is also clear.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12827": {
        "explanation": "The issue is reasonably specified. The request is to add more details to the QuantileTransformer documentation, specifically about its implementation. The issue provides a reference to a StackExchange question which can be used to understand what information should be included. However, it does not provide exact details on what specific implementation aspects need to be documented or how the current documentation is lacking. A developer would need to interpret what information is missing and determine what should be added to the documentation to better explain the implementation. The mention that the implementation does not seem to compute the empirical cdf of the columns suggests that the documentation should clarify the actual method used, but the exact method is not specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12860": {
        "explanation": "The issue is reasonably specified. The request is to add support for unpenalized logistic regression. The issue explains the current situation where `LinearRegression` supports unpenalized OLS and `SGDClassifier` can be used for unpenalized logistic regression, but it's not straightforward. It's clear that the goal is to provide a direct method for unpenalized logistic regression, similar to how `LinearRegression` provides unpenalized OLS. However, there are some details that would need to be worked out, such as the specific implementation approach and how it integrates with the existing codebase. But the overall objective is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12908": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The request is to add an option to the OneHotEncoder to perform 1 of k-1 encoding, which is also known as dropping the first category to avoid multicollinearity in regression models. The issue provides several examples of similar features that have been added to scikit-learn in the past (like the drop_first option to OneHotEncoder and the similar implementation in DictVectorizer), which would guide the implementation. It also provides a specific example of the desired output format, which clarifies the expected behavior. The issue explains the motivation (avoiding multicollinearity) and provides a clear description of what the new option should do. The request includes specific parameters that should be added (independent=True and baseline=24 in the example), which would allow for specifying the encoding method and the baseline category. The issue also mentions potential compatibility issues (with handle_missing='ignore'), which is an important consideration for implementation. All of these details make it clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12961": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The user is describing an error that occurs when using `RandomizedSearchCV` with `lightgbm` in scikit-learn, but the problem is not clearly defined. The error message indicates a ValueError in `_format_results` function, but the user is not specifying what the expected outcome should be or how to resolve the issue. The user is asking for insight into the potential cause of the error but is not providing a clear request for a solution. The issue is vague and it is unclear what a successful solution would look like.",
        "label": "VAGUE"
    },
    "scikit-learn__scikit-learn-12973": {
        "explanation": "The issue is well-specified and clear. The user is reporting a bug in the LassoLarsIC class where the `copy_X` parameter is defined both in the class initialization and in the `fit` method, leading to potential conflicts. The user explains how the current implementation can silently overwrite the `copy_X` parameter set during initialization when calling `fit`, which can lead to unexpected behavior. The user also proposes a specific solution: changing the default value of `copy_X` in the `fit` method to `None` so that it only overwrites the initialization value if explicitly passed as an argument. This is a clear problem with a clear solution, making it well-specified for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12983": {
        "explanation": "The issue is reasonably specified. It provides the problem description (Gradient Boosting fails when init is a sklearn estimator), the cause (predict output has unexpected shape), and a note about adding tests for the init parameter. The fix involves modifying the code to handle the shape correctly and ensuring compatibility with different types of estimators. While there are some implementation details to work out, the general direction is clear enough for a meaningful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-12989": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: there is an inconsistency in the default 'init' parameter between 'NMF' and 'non_negative_factorization'. The issue suggests a solution (changing the default in 'non_negative_factorization' with a deprecation process) and references a related issue. This provides sufficient information for an experienced developer to implement the necessary changes. The problem is straightforward and does not require additional clarification to start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13010": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: using StandardScaler on a large float16 numpy array causes overflow in the mean and std calculations. The issue provides a detailed reproduction script, expected results, actual results including error messages, and even version information. All these elements make it clear what the problem is and what the expected outcome should be. The developer would need to investigate how StandardScaler handles dtype in its calculations and potentially modify it to handle float16 data without overflow.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13013": {
        "explanation": "The issue is well-specified. The problem is clearly described: manual checks for whether an estimator has been fitted are being used instead of the `check_is_fitted` method, leading to inconsistent error messages. The expected result is clear - the code should use the `check_is_fitted` method from the `utils.validation` submodule. The issue also provides examples of where the problem occurs. As a software engineer, I would have enough information to search for similar manual checks across the codebase and replace them with calls to `check_is_fitted`. The task is straightforward and the success criteria are clearly defined.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13017": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described as the unclear behavior of ColumnTransformer when negative integers are passed as column indexes. The issue provides a code example to reproduce the problem, showing that the output differs when using a negative index versus a positive index. It also clearly states the expected results (the first transformer should either raise an error or give the same result as the second transformer) and the actual results. This allows a clear understanding of what the problem is and what the desired outcome should be.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13087": {
        "explanation": "The issue is well-specified. The request is to add support for arbitrary bin spacing in the calibration_curve function, similar to how numpy's histogram function allows specifying bin edges. The issue provides a clear description of the current functionality (evenly partitioned bins), the problem with it (noisy results due to uneven distribution of predictions), and a proposed solution (allowing users to specify custom bin edges). The issue also includes a working workaround implementation, example bins, and a comparison of results showing the motivation for the change. The request is specific, actionable, and would be a clear addition to the scikit-learn library. There's no ambiguity about what needs to be done - the function should be modified to accept custom bin edges in addition to the current n_bins parameter.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13124": {
        "explanation": "The issue is well-specified and clear. The reporter provides a detailed description of the problem, including a code example that demonstrates the issue, expected vs. actual results, and the versions of the dependencies. The problem is about the `shuffle` parameter in `StratifiedKFold`, where the current implementation either shuffles the batches or the data in a way that doesn't align with the documentation. The reporter explains that when `shuffle=True`, the batches are shuffled but not the data within each stratum, and this behavior doesn't change with different `random_state` values. This is a clear and specific issue that can be addressed with a solution. The steps to reproduce the issue are provided, making it easy to verify the problem and test any proposed fix.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13135": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, expected and actual results, and the error message. The problem is that the 'kmeans' strategy in 'KBinsDiscretizer' is failing due to unsorted bin edges. The user provided a code snippet to reproduce the issue, and the error trace indicates that the 'np.digitize' function requires sorted bins. A solution would involve ensuring the bin edges are sorted before passing them to 'np.digitize'. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13142": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific discrepancy between GaussianMixture's predict and fit_predict methods when n_init is greater than 1. The issue provides steps to reproduce the problem with actual code, shows what the expected results should be, and what the actual results are. It also includes the versions of the relevant libraries, which could be important for debugging. The issue is clearly defined, and the solution would involve investigating why fit_predict and predict give different results when n_init>1 and fixing this discrepancy.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13143": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the problem, steps to reproduce it with code, expected and actual results, and environment information. The problem is about the precision_score function in scikit-learn producing an unexpected result when comparing two identical matrices. A developer would be able to reproduce the issue using the provided code snippet, understand what the expected behavior should be, and work on a solution to fix the function's implementation or investigate why it's not working as expected.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13157": {
        "explanation": "The issue is about a discrepancy between the default multioutput parameter in the r2_score function and the base.RegressorMixin class. The issue description explains that r2_score was changed to use 'uniform_average' in version 0.19, but RegressorMixin still uses 'variance_weighted'. The issue also points to specific lines of code where this discrepancy is observed. This is a well-specified issue because it clearly states the problem (a discrepancy in default behavior), provides context (the version where the change was made), and points to specific code locations. A developer would understand what needs to be fixed: align the default multioutput parameter in RegressorMixin with that of r2_score. The solution would involve changing the default parameter in RegressorMixin to 'uniform_average', or adjusting r2_score to match RegressorMixin, depending on which is correct. The issue is well-documented and provides enough information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13165": {
        "explanation": "The issue is well-specified. The goal is to ensure monotonic bin edges for the KBinsDiscretizer strategy quantile. The solution involves applying a simple maximum on subsequent values to enforce monotonicity, which is explained in the What does this implement/fix section. The reference to fixing #13194 provides context to the specific problem being addressed. The additional line of code is described as a no-op in almost all cases, which gives information on the expected impact of the change. All necessary information for a successful solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13174": {
        "explanation": "The issue is reasonably specified. It indicates that AdaBoost (and potentially other ensemble methods) currently enforce unnecessary constraints on the input data `X` (requiring it to be an array or sparse matrix of numerics). The issue suggests that these constraints should be relaxed because the actual processing is done by the base estimator, not the ensemble itself. While the issue does not provide explicit details on how to implement this change (e.g., how to handle validation for non-numeric input types, what specific ensemble methods need to be updated, or what tests should be added), the general direction is clear: remove the requirement that `X` must be numeric and let the base estimator handle the data instead. A reasonable interpretation is that the validation logic in the ensemble code should be modified to not assume the data is numeric, passing it directly to the base estimator without prior conversion or checks. This is sufficient for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13253": {
        "explanation": "The issue is reasonably specified. It explains the goal of supporting DataFrames in OneHot/OrdinalEncoder without converting to a contiguous array. It mentions that the conversion is unnecessary because the transformers already work column by column. There are some details about preserving data types per column and avoiding conversion of mixed-dtype DataFrames to full object arrays. However, there are still some blanks to fill in, such as exactly how to implement this change and how to handle edge cases related to data types. The mention of a potential change in behavior with `categories_` and the note about not handling pandas categorical dtypes specifically also indicate areas that need clarification.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13283": {
        "explanation": "The issue is reasonably specified, as it provides a clear description of the problem, steps to reproduce, and a proposed solution. However, some details may require interpretation or further clarification, such as the exact implementation of the proposed solution and how it would integrate with the existing codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13302": {
        "explanation": "The issue is not well-specified for someone unfamiliar with the codebase. It references a GitHub issue (#11642) and a pull request (#11155) that provide context, but without access to those, the problem is not clearly defined. Additionally, the task is to ensure casting rules are clear between different classes and functions, but it's not clear what specific changes are needed or what the desired behavior is. The mention of 'WIP' (Work In Progress) also suggests that the issue is not fully fleshed out yet.",
        "label": "VAGUE"
    },
    "scikit-learn__scikit-learn-13313": {
        "explanation": "The issue is reporting that two test functions are defined but not being executed. However, the issue lacks details on how to reproduce the problem, what the expected behavior should be, and what the actual problem is. It is unclear if these functions are supposed to be called by other tests or if they should be standalone tests. Without more context on how these functions are supposed to be used or what their purpose is, it is difficult to determine what the correct solution would be. The reporter has provided a git grep output showing where the functions are defined, but no information on where they should be called or what the consequences of them not being run are. Therefore, there is not enough information to make a meaningful attempt at a solution.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "scikit-learn__scikit-learn-13328": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, expected and actual results, and even the error message. The problem is about a TypeError when using a boolean array with HuberRegressor's fit method. The error is clearly described and the user provides a code snippet that reproduces the error. The user also explains that the boolean array should be converted to float, as is done by LinearRegression. The error message points to the problem in the code. All the necessary information is provided to understand the issue and work on a solution. Therefore, this issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13333": {
        "explanation": "The issue is well-specified. The problem is to improve the documentation of the `n_quantiles` parameter in the `QuantileTransformer` class. The issue provides a detailed description of the current documentation and what is wrong with it. The issue also provides examples of what is happening when different values of `n_quantiles` are used, including code that demonstrates the problem and what is desired. The issue also provides suggestions for what the improved documentation should include, such as the impact of `n_quantiles` and that setting `n_quantiles` greater than `n_samples` is not beneficial. The issue is clear on what needs to be done: improve the documentation to better explain the `n_quantiles` parameter and its impact on the transformation. There is no ambiguity in what is being asked for.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13363": {
        "explanation": "The issue is well-specified. It includes a clear description of the problem, steps to reproduce the error, the expected and actual results, and the environment details. The provided code snippet shows how to trigger the exception, and the traceback indicates where the problem occurs. This information is sufficient to understand the bug and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13368": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, expected and actual results, and even the scikit version. All the necessary information is provided for a developer to understand and attempt to solve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13392": {
        "explanation": "The issue is reasonably specified. It asks to add a common test for multi-output support in classifiers and regressors, and provides an example of what the test should do. However, there are some missing details like which specific classifiers and regressors should be tested, how the test should be structured within the existing test framework, and whether there are any specific edge cases to consider. Despite these gaps, a developer with knowledge of the codebase could reasonably infer what is needed and implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13436": {
        "explanation": "The issue is reasonably specified. It provides a concrete example of the problem with the pretty print representation of a nested pipeline in scikit-learn, along with code to reproduce it. The user explains what the current output looks like and what they would expect instead. While there are some implementation details that would need to be worked out (how to trim the repr while maintaining structure visibility), the problem and desired outcome are clear enough to begin working on a solution. The issue also references related discussions and includes a code example that demonstrates the problem, making it reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13439": {
        "explanation": "The issue is well-specified. The problem is described clearly: the Pipeline class should implement the __len__ method to avoid errors when using len(pipe). A code example is provided to reproduce the error, and the desired behavior is implied by the context (implementing __len__). The solution involves adding the __len__ method to the Pipeline class in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13447": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the discrepancy in sample weighting for items with zero true labels. The steps to reproduce the issue are provided, including a sample code snippet and a link to a Colab notebook. Additionally, the expected and actual results are clearly stated, which allows for verification of a correct solution. The specific lines in the code where the issue occurs are referenced, providing a clear direction for implementing the fix. All necessary information for a meaningful attempt at a solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13454": {
        "explanation": "The issue is well-specified. It includes a small example that reproduces the problem, a description of the confusing error message, and even a note about a possible improvement. The example is clear and the expected result is implied by the note that the error message is confusing and should be updated. This is sufficient information to make a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13472": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimal, reproducible example. The user has identified the source of the issue (incompatible method signatures when using a pipeline as the initial estimator in GradientBoostingRegressor) and even proposed a specific fix (changing line 1421 in gradient_boosting.py). The error message is included, showing exactly where the problem occurs. The user has also provided their environment details. This level of detail allows for a direct and focused solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13485": {
        "explanation": "The issue is reasonably specified. The problem is that the `CalibratedClassifierCV` function is using `check_array` with default parameters that do not allow 3D inputs, while the user's package requires this functionality. The user provides a concrete example of the 3D input format and mentions that other meta-estimators like `GridSearchCV` do not have this restriction. The request is to be more tolerant in `check_array` for `CalibratedClassifierCV` to allow 3D inputs. While the exact implementation details of how to modify `check_array` are not provided, the goal is clear and there is a sensible interpretation of what needs to be done. The user is also willing to provide a PR, indicating that they have a direction in mind.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13496": {
        "explanation": "The issue is well-specified with clear steps for the solution. The request is to expose the 'warm_start' parameter in the IsolationForest class, document it, add a test, and possibly update an example. All of these steps are clearly outlined and actionable for a developer to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13497": {
        "explanation": "The issue is reasonably specified. The problem is comparing a string to an array in the _estimate_mi function, which can cause errors in future numpy versions. It also mentions that the function isn't tested properly. A solution would involve fixing the comparison to handle the different possible types of discrete_features (string, array, boolean mask) and ensuring proper testing. Some interpretation is needed for how exactly to implement the fix and what specific tests to add, but the general approach is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13536": {
        "explanation": "The issue is well-specified. The problem is clearly described: the error message when passing sample_weight to a Pipeline is not user-friendly. A reproducible example is provided along with the current error message. The desired improvement is also clearly stated: the error message should explicitly describe the correct format for passing sample_weight to a step in a Pipeline. All necessary information is present to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13549": {
        "explanation": "The issue is reasonably specified. It describes a specific problem with the current `train_test_split` function when trying to subsample data in a stratified way when the desired number of samples is close to the total number of samples. It also proposes a potential solution by adding a `stratify` option to `utils.resample`. While there are some implementation details that would need to be worked out (like exactly how the stratification should be implemented in resample), the overall goal and the problem being solved is clear enough for a meaningful attempt at a solution. The issue also provides code examples and error messages that help clarify the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13554": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a specific example and code snippet to reproduce the issue. The expected and actual results are provided, making it clear what the problem is. The reference to a previous PR and issue (#9354) also provides context. A solution approach is outlined, which is to implement a block-wise casting to float64 for computing the euclidean distance matrix. This approach is detailed with several optimizations. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13584": {
        "explanation": "The issue is well-specified because it includes a minimal, reproducible example that clearly demonstrates the bug. The example shows that when using the `print_changed_only=True` configuration with `LogisticRegressionCV` and providing a NumPy array for the `Cs` parameter, a ValueError is raised due to the truth value ambiguity of an array with more than one element. This provides enough information for a developer to reproduce the issue, understand what is going wrong, and work on a fix. The error message also gives a hint about the cause of the problem, which is related to how the array is being evaluated in a boolean context. Therefore, the issue is well-specified and a successful solution can be attempted based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13620": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with a clear explanation of the bug: feature importances in ensemble tree methods (Gradient Boosting Trees or AdaBoost Trees) do not sum to 1 when the ensemble reaches a large number of estimators. The issue provides sample code that reproduces the bug, and shows the unexpected output. The issue also describes when the bug appears (with large number of estimators, small training samples, or large tree depth) and what the consequences are (feature importance sum decreases with more estimators). This is sufficient information for a software engineer to investigate the issue and create a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13628": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The reporter clearly describes the problem with the brier_score_loss function, provides specific examples that demonstrate the issue, and even points out the suspected cause in the code (_check_binary_probabilistic_predictions converting target to 0). The reporter also shows the current behavior and expected behavior in their examples, making it clear what needs to be fixed. The issue has enough detail that a developer could understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13641": {
        "explanation": "The issue is reasonably specified. It describes a problem where the CountVectorizer with a custom analyzer ignores the input argument. It provides a code example that demonstrates the problem, which helps in understanding the context and expected behavior. While there is a mention of uncertainty about whether to fix it or just document it, the core issue is clear enough for a meaningful attempt at a solution. The provided code example allows for reproducing the issue and verifying the fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13704": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, reproducible code examples, expected and actual results, and relevant version information. The code examples clearly demonstrate the discrepancy in VarianceThreshold's behavior between the 'works_correctly' and 'broken' cases. A developer would be able to run the provided code, observe the issue, and understand what the expected behavior should be. All the necessary information is present to diagnose and fix the problem with VarianceThreshold not removing features with zero variance as intended.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13779": {
        "explanation": "The issue is well-specified because it clearly describes the problem (VotingClassifier fails when an estimator is set to None and sample_weights are provided), provides a reproducible example, and explains the error. The goal is to modify the fit method to handle the case where an estimator is None when sample_weights are used.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13780": {
        "explanation": "The issue is reasonably well-specified, but there are some details that need to be filled in. The main goal is clear: modify the VotingClassifier and VotingRegressor to accept 'drop' as a way to remove an estimator from the ensemble, just like None currently does. However, there are some aspects that aren't explicitly stated, such as how to implement this change, what the expected behavior is in all cases, and how to handle backward compatibility. Despite these gaps, the core requirement is clear enough to start working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13828": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the AffinityPropagation class in scikit-learn does not support sparse affinity matrices. The steps to reproduce the error are provided with a minimal code example that demonstrates the issue. The expected and actual results are also clearly stated, showing that an error is raised when a sparse matrix is used instead of a dense matrix. The error traceback is included, which helps identify where the problem occurs in the code. The versions of the relevant packages are also provided. All these details make it clear what the problem is and what a successful solution would involve (i.e., modifying the AffinityPropagation implementation to properly handle sparse matrices).",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13910": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a detailed description of the problem, steps to reproduce the issue, expected and actual results, and information about the versions of the software involved. The issue seems to be related to a change in behavior of the euclidean_distances function in sklearn 21.1 when working with float32 data, resulting in incorrect calculations. The provided code snippet allows for reproduction of the issue, and the provided data files and plots help to illustrate the problem. The issue is specific enough to allow for a targeted solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13915": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the error message, the steps to reproduce it, and the expected versus actual results. The context is given that this issue is related to a specific pull request and test failure. A developer would be able to reproduce the issue using the provided code, identify the source of the TypeError, and implement a fix that allows the function to handle int64 indptr on 32-bit Windows systems safely. The version information is also provided, which can help in debugging.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13933": {
        "explanation": "The issue is discussing the binning process in Gradient Boosted Decision Trees (GBDTs) and whether the training and validation data should be binned separately. The issue highlights a potential data leakage concern where the bin thresholds are determined using data that includes the validation set. The issue is well-defined in that it clearly presents the problem (potential data leakage) and the proposed solution (binning data separately for training and validation sets). The problem is specific to the GBDT implementation, and the goal is clear - to correctly bin the data to avoid data leakage. The discussion is technical but clear, and there's a clear understanding of what the expected outcome should be. Therefore, this issue is well-specified and a meaningful attempt at a solution can be made.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13960": {
        "explanation": "The issue is well-specified. The problem is clearly described: `IncrementalPCA` is not accepting sparse input even though it is designed for it. There are steps to reproduce the error, expected vs actual results, and even a suggested fix. All necessary information is provided for a software engineer to understand the problem and implement a solution. The issue is clear, concise, and provides all relevant context for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-13983": {
        "explanation": "The issue is to add matplotlib to the show_versions() function. This is a specific task with clear requirements - to include matplotlib in the list of packages whose versions are displayed by this function. There is no ambiguity in what needs to be done. The solution would likely involve modifying the show_versions() function to include a check for and display of the matplotlib package version. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14053": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described as an IndexError in the export_text function when the tree only has one feature. The steps to reproduce the issue are provided in code form, which demonstrates how to create a DecisionTreeClassifier with a single feature and use export_text, which causes the error. The actual results are stated, and the versions of the dependencies are included. This information is sufficient for a developer to reproduce the issue and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14067": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with a clear explanation of the issue: the ARD Regressor's accuracy degrades when upgrading from Scipy 1.2.1 to 1.3.0. The issue provides specific examples of the problem, code to reproduce it, and detailed results showing the degradation in performance. The steps to reproduce are clearly outlined, including code snippets for a single seed and for testing across 1000 different seeds. The issue also provides summary statistics and a plot comparing the results between the two versions of Scipy. All of these details make it possible to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14087": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, steps to reproduce the error, the expected and actual results, and the versions of the relevant libraries. The error is an IndexError when using LogisticRegressionCV with refit=False. The provided code snippet is sufficient to reproduce the issue, and the expected result is that no error should be thrown. Therefore, a meaningful attempt at a solution is possible.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14114": {
        "explanation": "The issue is reporting a problem with the AdaBoostClassifier in scikit-learn when using the 'SAMME' algorithm with a base_estimator that does not support predict_proba. The issue provides a clear example of the error that occurs and explains the inconsistency in the algorithm's usage of methods. It is clear what the problem is and what the expected behavior should be. The problem is to fix the inconsistency and ensure that the algorithm works correctly with any base_estimator.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14141": {
        "explanation": "The issue is reasonably specified. It asks to add joblib to the dependencies listed in show_versions, or to the issue template when the sklearn version is greater than 0.20. While there are some details that would need to be filled in (such as exactly how to implement this check for sklearn version and where the show_versions function is located), there is a clear goal and a sensible interpretation of what needs to be done. A software engineer with experience in the codebase could make an educated guess about where to make these changes and how to implement the version check.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14237": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with a clear explanation of the problem (ColumnTransformer passes wrong columns to remainder when using DataFrames with different column ordering between fit and transform). The issue includes a minimal, reproducible example, expected results, actual results, and even points to the specific line of code where the issue occurs. This provides all the information needed to understand the problem and implement a fix. The issue is specific, actionable, and well-documented.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14450": {
        "explanation": "The issue is well-specified. It includes a clear error message, a minimal reproducible example, and a description of the problem. The error is triggered by a column with only zeros, which can be considered a constant feature. The expected solution is to handle this case gracefully instead of raising an unhelpful error message. All necessary information for reproducing the issue and understanding the desired fix is provided.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14464": {
        "explanation": "The issue is well-specified. It clearly describes a problem with cloning a custom transform in scikit-learn where values in an __init__ dictionary are being replaced with None. The issue includes a detailed problem description, steps to reproduce the issue with code, expected results, actual results, and environment information. The example demonstrates two different implementations of transforms - one that exhibits the problem and one that works correctly. The problem is clearly defined as the cloned transform having None values in the dictionary instead of the original values. The solution would need to address why the cloning process is replacing these values and how to fix it while maintaining the expected behavior. All necessary information is provided to understand and solve the problem.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14496": {
        "explanation": "The issue is well-specified with a clear explanation of the problem, including code examples, error messages, and a proposed fix. The problem occurs when a float is passed as min_samples to the OPTICS class, which is not converted to an integer before being used to instantiate the NearestNeighbours class. The error message and the suggested fix provide a clear path for resolving the issue. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14544": {
        "explanation": "The issue is discussing the input validation and requirements for the ColumnTransformer in a machine learning library (likely scikit-learn given the reference to GitHub issues and the naming conventions). It raises several questions about how ColumnTransformer should handle different scenarios:\n\n1. Whether ColumnTransformer should have the same input requirements as other estimators\n2. How to handle column reordering\n3. What to do when additional columns are added to X\n4. How to define n_features_in_ for ColumnTransformer\n\nThese are all design questions about how the ColumnTransformer should behave in different situations. The issue provides context by referencing specific GitHub issues that have previously encountered problems with ColumnTransformer's input handling.\n\nThe issue is not asking for a specific implementation or fix, but rather seeking a discussion about what requirements and validation should be implemented for ColumnTransformer. It's asking for a design decision rather than a specific coding task.\n\nWhile the issue raises important questions, it doesn't provide clear guidance on what the desired outcome should be. It presents multiple options and asks for a discussion about what makes sense. Without clear requirements or a specific task to implement, it's difficult to determine what would constitute a successful solution to this issue.\n\nThe issue is more of a Request for Comments (RFC) than a specific problem to solve. It's asking for input on how to design the ColumnTransformer's input validation, rather than providing a specific implementation task.\n\nTherefore, I would label this issue as VAGUE because the requirements are not clearly defined and it's not clear what the expected outcome should be. It's asking for a design discussion rather than a specific implementation task.",
        "label": "VAGUE"
    },
    "scikit-learn__scikit-learn-14591": {
        "explanation": "The issue is well-specified and clear. It explains the problem (LassoCV sets precompute to False for the final fit), provides the context (using a large dataset, significant performance impact), and even identifies the specific line of code in the source file (coordinate_descent.py line 1223 in Python2.7/sklearn0.19.0) where the issue occurs. The reporter has also done some investigation, explaining that changing this line makes the fit much faster. The issue is asking about the rationale behind this design decision and whether it's intentional or if it can be fixed. This is sufficient information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14629": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce, expected vs actual results, and even a hypothesis about where the problem may be in the code. The user has provided a code example that reliably reproduces the error, and clearly states what the expected behavior should be. This provides enough information for a developer to understand the problem, verify it exists, and work on a solution. The reference to specific lines of code also helps in understanding where to focus the debugging effort.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14710": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is clearly described, with a detailed error traceback and steps to reproduce. The issue is about the HistGradientBoostingClassifier not working with string target when early stopping is enabled. The error is a TypeError because the scorer is provided with y_true as integer while y_pred are original classes (strings). The potential solution is also provided in the issue description, with a code diff that shows how to fix the problem. The expected and actual results are clearly stated. All necessary information is provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14732": {
        "explanation": "The issue is asking about the lack of multioutput support in the `median_absolute_error` function and whether it's a design choice or an omission. The issue is reasonably clear about what the problem is - that multioutput support is missing. However, it lacks specific details about how this support should be implemented, such as the expected behavior, interface changes, and any specific requirements for the implementation. There is a clear intent to contribute a PR, but the specifics of what is expected from the PR are not provided. The issue is asking for clarification on why the feature is missing rather than directly requesting the implementation. A successful solution would require some interpretation of what multioutput support means in this context and how it should be implemented. Therefore, the issue is reasonably specified but has some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14764": {
        "explanation": "The issue is well-specified and clear. It provides a detailed description of the problem with the `weights` parameter in `make_classification()`, including a test case to reproduce the error, expected and actual results, and proposed corrections to the code. The error message and the suggested changes to the code are specific. The issue also explains that if the `weights` parameter must be a list for a specific reason, it should be documented, otherwise, it should be updated to accept any sequence as in `make_blobs`. This is sufficient information for an experienced software engineer to understand the problem and implement a solution. The issue is well-documented and provides all necessary details to address the problem.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14806": {
        "explanation": "The issue is about the behavior of the IterativeImputer in scikit-learn when dealing with missing values in the transform data that were not present in the fit data. The user is confused about why the imputer forces the use of the initial imputation method (mean imputation by default) for features with missing values during transform that didn't have any missing values during fit. The user would prefer to fit one iteration of the chosen estimator and use that to impute missing values instead of using the mean. The issue provides two examples showing the current behavior and the desired behavior. The user suggests modifying the code in impute.py to make this behavior optional with a parameter. The issue is reasonably specified because the problem is clearly described, there are examples showing the current and desired behavior, and the user has a specific suggestion for how to fix the issue. However, there are some blanks to fill in about the implementation details. For example, it's not clear how to implement the suggested parameter or how it would interact with the existing parameters. Despite these blanks, there is a sensible interpretation of what is required for a successful solution. The user wants to change the behavior of the IterativeImputer to allow for the use of the chosen estimator for imputing missing values in the transform data that weren't present in the fit data. This is a specific and achievable goal, even though the exact implementation details may need to be worked out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14869": {
        "explanation": "The issue is well-specified because it provides a minimal, reproducible example that clearly demonstrates the problem. The example shows that using 'categorical_crossentropy' with the HistGradientBoostingClassifier on a binary classification task results in unexpected predictions, while 'binary_crossentropy' works correctly. The expected behavior is also described: 'categorical_crossentropy' should either work as a generalization or raise an error. This gives a clear target for fixing the issue. The mention of specific users provides context but is not necessary for understanding or solving the problem.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14878": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly shows the problem with a code example that triggers an error when using SimpleImputer on a DataFrame with string data. The error message is provided, which indicates that there's an AttributeError: 'DataFrame' object has no attribute 'dtype'. This is a specific issue that can be addressed by modifying the SimpleImputer code to correctly validate DataFrame inputs. The example is clear, the error is well-defined, and the expected behavior (proper validation) is implied. The problem is reproducible with the given code and the error traceback is provided, making it possible to understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14890": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the user is unable to fit a TransformedTargetRegressor using sample_weight in a Pipeline. There is a reproducible example provided which demonstrates the issue, along with the actual error that occurs and the expected behavior. The error message points to a specific line in the pipeline.py code where the problem occurs. The versions of the libraries are also provided for context. All the necessary information is present to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14894": {
        "explanation": "The issue is well-specified. It clearly describes the problem of a ZeroDivisionError occurring in the _sparse_fit method of an SVM model when the support_vectors_ attribute is empty. The issue provides a clear and reproducible code example that demonstrates the problem. It also explains the expected and actual results, along with the versions of the software involved. This allows a software engineer to understand the problem and implement a solution that prevents the ZeroDivisionError in the specified scenario.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14908": {
        "explanation": "The issue is well-specified and clear. It describes a specific problem with the DummyClassifier in scikit-learn when using the constant strategy with a value not present in the training data. The issue provides a clear example of the problem, shows the current error message, and suggests an improved error message. The problem is reproducible with the provided code snippet, and the desired solution is clearly stated. There is no ambiguity in what needs to be done - the error message should be modified to include the constant value provided and the possible values from the training data.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-14983": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the __repr__ strings for RepeatedKFold and RepeatedStratifiedKFold are not showing the expected format. The issue provides steps to reproduce the problem, shows what the actual output is versus what the expected output should be. This gives all the information needed to understand what needs to be fixed - the __repr__ method needs to be implemented for these classes to return the formatted string with the parameters. The versions information also helps to ensure any solution is compatible. There are no ambiguities about what needs to be accomplished.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15028": {
        "explanation": "The issue is well-specified with clear instructions on what needs to be done. It explains the problem with the `classes_` attribute in the DecisionTreeRegressor and outlines the solution of deprecating it by renaming it to `_classes` and adding a test. The reference to the contributions guide and collaboration with another developer also provides context for the implementation. There is a clear goal to deprecate the attribute and steps have already been outlined for how to achieve it.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15084": {
        "explanation": "The issue is reasonably specified because it provides the error message, steps to reproduce the error, and the environment information. However, there are some blanks to fill in, such as the missing import for 'np' and the function 'val_error' which is called in the code but not defined in the provided steps. Despite these omissions, the error is clear and the problem is understandable. A solution would likely involve ensuring that the data types used in the VotingClassifier are compatible, possibly by adjusting the model or the data preprocessing steps.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15086": {
        "explanation": "The issue is well-specified. It clearly describes a problem with the `MultiTaskLassoCV` and `MultiTaskElasticNet` models in scikit-learn when using binary features and `fit_intercept=True`. The issue provides a detailed explanation of the problem, including expected vs. actual behavior, and the conditions under which the problem occurs. It also provides minimal, reproducible code examples for both the problematic case and the working case (with normal features or fit_intercept=False). The issue includes the environment information (Python version, scikit-learn version, etc.) which is helpful for debugging. All the necessary information is provided to understand the issue and reproduce it, making it well-specified for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15094": {
        "explanation": "The issue is well-specified as it provides a clear description of the problem, steps to reproduce, expected and actual results, and relevant versions. It also includes a minimal example that demonstrates the issue.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15096": {
        "explanation": "The issue is reasonably specified. It provides a clear problem description, including a code example and the observed issue. The reporter explains why they believe it's a bug and provides version information. However, it would still require some investigation into the GridSearchCV implementation to determine the exact cause and solution. The reporter also provides some potential explanation for the issue, which helps guide the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15100": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, with a detailed explanation of the unexpected behavior of the `strip_accents_unicode` function when handling strings in NFKD form. The issue includes code to reproduce the problem, expected and actual results, and even the system and dependency versions. This level of detail allows for a targeted solution to address the specific issue described.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15138": {
        "explanation": "The issue is reasonably specified. It asks to add an option to use the original dataset when training the final_estimator in a stacking setup. The reference to mlxtend's implementation provides a clear example of how this option can be implemented. The parameter name, type, and default value are provided, and the expected behavior when the parameter is True or False is described. This is sufficient information to implement the requested feature with a reasonable understanding of what is required.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15393": {
        "explanation": "The issue is pointing out that the 'ascending' and 'descending' imputation orders in the IterativeImputer are inverted. It references a specific line in the code and explains that the _ImputerTriplets are appended according to the imputation_order, but the order is inverted. While the issue is somewhat technical and specific to the scikit-learn library, it provides enough context and a clear problem statement. A developer familiar with the codebase would be able to understand the issue and work on a solution. There might be some details that need to be clarified, such as what exactly is considered 'inverted' and how to fix it, but the general direction is clear. Therefore, this issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15495": {
        "explanation": "The issue is well-specified. The task is to replace custom validation of sample_weight with a new utility function _check_sample_weight in a list of specified estimators/functions. The issue provides a clear list of classes where the change is needed and suggests how to locate their definitions. The goal is to use this new validation method consistently across the codebase where appropriate, replacing previous ad hoc methods. This gives a clear path for implementation.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15512": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user is reporting a discrepancy between the documentation and the actual behavior of the AffinityPropagation algorithm in scikit-learn. They provide a clear example that demonstrates the problem, a description of the expected vs. actual outcomes, and explain the impact on their use case. The issue also includes system and package versions for reproducibility. While there might be some discussion about the intended behavior, the problem is clearly defined and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15524": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of the error encountered when using nested cross-validation with a KNN classifier that has a precomputed metric. The user provided code to reproduce the issue, expected results (which work without the precomputed metric), and actual results (the error trace). This information is sufficient for a developer to understand the problem and work on a solution. The task is to fix the error raised when using a precomputed metric in a nested cross-validation setup with KNN.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-15625": {
        "explanation": "The issue is reasonably well-specified as it clearly describes the desired enhancement: adding a 'normalize' parameter to the 'confusion_matrix' function. The purpose and motivation for this enhancement are provided, including the user's frequent use of the function and the desire to avoid manual normalization. The issue also acknowledges the existence of similar functionality in other functions, indicating that the enhancement is intentional. However, there are some details that would need to be filled in, such as the specific implementation requirements for the 'normalize' parameter and any potential backward compatibility concerns. Despite these gaps, the issue provides a clear direction for the solution, making it reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-24145": {
        "explanation": "The issue is well-specified. The request is to add a sparse matrix output option to the SplineTransformer class in scikit-learn. The workflow and example code are clearly described, showing how the 'sparse' parameter would be used. The proposed solution references a specific SciPy feature (design_matrix from scipy pull request 14344) that would enable this functionality. The example demonstrates the expected usage pattern, making it clear what the desired behavior is. The code example shows that when 'sparse=True' is passed to SplineTransformer, it should return a sparse matrix instead of a dense ndarray. This is a clear and specific feature request with a proposed implementation path.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-24677": {
        "explanation": "The issue is about fixing a function in scikit-learn for sparse matrices. The PR description explains the problem in detail, referencing a specific issue (#18524) and explaining the two main points of failure. The changes proposed are to update the reduce function for computing distances, fix the pre-computed check for sparse matrices, and address an indexing issue when passing weights to np.bincount. With this information and access to the codebase, an experienced software engineer could understand what needs to be fixed and how to approach the solution. The problem is well-defined and the necessary changes are clearly described.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25102": {
        "explanation": "The issue is reasonably specified. The problem is described with a clear example and the desired outcome is outlined. The proposed solution includes specific implementation details like adding an argument to a function and using the original input dtypes. However, there are some implementation details that would need to be worked out, such as how to handle the `dtypes` argument and how to pass the original dtypes to the `_wrap_in_pandas_container` function. The code example provides a good starting point, but the exact implementation would require some additional design decisions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25232": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user clearly explains the problem: the IterativeImputer class lacks a fill_value parameter when using the 'constant' initial strategy, unlike the SimpleImputer class. They provide relevant documentation references and explain the desired behavior. The proposed solution is clearly stated - adding the fill_value parameter to IterativeImputer and allowing np.nan as a value. This is a specific, actionable request with clear requirements. The issue is directly related to a specific feature implementation in the codebase and would involve modifying the IterativeImputer class to include this parameter.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25363": {
        "explanation": "The issue is not clearly described without context. The description refers to a pull request that is an alternative to another pull request (#25242), but without understanding the specific problem being addressed in that PR or the referenced issues (#25239), it's difficult to determine what the actual problem is and what the expected solution should look like. The description mentions passing explicit configuration to 'delayed', but doesn't clearly explain what 'delayed' is, what configuration needs to be passed, or why the current implementation is problematic. The issue lacks sufficient context and specific requirements for a successful solution. It would require significant prior knowledge of the codebase and the specific problems being addressed in the referenced pull requests and issues to understand what needs to be done.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "scikit-learn__scikit-learn-25500": {
        "explanation": "The issue is well-specified because it includes a clear description of the bug, steps to reproduce the problem, the expected and actual results, and the environment details. The user explains that the `CalibratedClassifierCV` with isotonic regression is not functioning correctly when `set_config(transform_output=\"pandas\")` is used. The specific error and traceback are provided, which helps to pinpoint the problem. Additionally, the problem is described in terms of a dataframe being returned where a numpy array is expected, which is a concrete issue to resolve. The code to reproduce the issue is also given, making it easy to test the solution. All these elements make the issue well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25570": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific bug in the ColumnTransformer when used with pandas output and transformers that apply to 0 features. The steps to reproduce are provided with code that clearly demonstrates the issue. The expected and actual results are explicitly stated, along with the exact error message. The versions of the libraries involved are also provided, which helps in reproducing the issue. All necessary information for a meaningful attempt at a solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25601": {
        "explanation": "The issue is well-specified. It describes a bug in the interaction between the 'class_weight' and 'max_samples' parameters in the 'RandomForestClassifier' class from scikit-learn. The issue includes a clear description of the problem, steps to reproduce it with sample code, expected results, actual results including the error traceback, and version information. The reporter suggests potential solutions (either no error or a more descriptive error). The problem is clearly defined and there is enough information to understand what the issue is and how to reproduce it, making it well-specified for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25694": {
        "explanation": "The issue is well-specified because it clearly describes the bug, provides a minimal code example to reproduce the problem, includes the expected and actual results, and references the relevant pull request. All necessary information is provided for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25697": {
        "explanation": "The issue is reasonably specified. The task is to deprecate the `n_iter` parameter in favor of `max_iter` for the `BayesianRidge` and `ARDRegression` models to ensure consistency with other models. While the general direction is clear, there may be some details to consider, such as how to implement the deprecation (e.g., adding warnings, maintaining backward compatibility, updating documentation and tests), which require some interpretation and judgment.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25744": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific parameter validation issue in the DecisionTreeClassifier when min_samples_split is set to 1. The expected vs actual behavior is clearly defined, and steps to reproduce are provided. The relevant code reference is provided, and the problem seems to be about parameter validation constraints not being enforced properly. This gives enough information to understand what needs to be fixed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25747": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The reporter has provided a clear description of the bug, including the specific error message, a minimal working example that reproduces the problem, and the expected versus actual results. The problem involves the interaction between FeatureUnion, pandas transform output, and a custom transformer. The error message shows that there is a length mismatch when trying to set the index. The code example is complete and should allow a developer to reproduce the issue and work on a solution. All necessary information is provided to understand the problem and start working on a fix.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25752": {
        "explanation": "The issue is well-specified. The problem is clearly described with a bug report format, including a description of the bug, steps to reproduce the issue with provided code, expected results, and actual results. The user also provided version information for the system and dependencies, which is helpful for debugging. The core issue is that KMeans clustering does not take sample weights into account during initialization, leading to unexpected clustering results. The code example clearly shows the discrepancy between the expected and actual results when using sample weights. All necessary information is provided to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25805": {
        "explanation": "The issue is well-specified because it includes a clear description of the problem, the error message, the code that triggers the error, and the shapes of the input data. It also explains the context and the requirements from the LGBMClassifier documentation. This information allows for a meaningful attempt to identify and resolve the issue.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25931": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the unexpected warning that occurs when fitting an IsolationForest with a DataFrame and a non-default contamination value. The steps to reproduce the issue are provided, along with the expected and actual results. The underlying cause is also explained, pointing to the predict call during the fitting process when contamination is not \"auto\". This information is sufficient for an experienced software engineer to understand the issue and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-25969": {
        "explanation": "The issue is not very well-specified for a meaningful attempt at a solution. While it provides some context about the purpose of the PR and what it intends to do, there are significant gaps in the information needed to understand and implement the solution. The issue references other GitHub issues and pull requests (#18212, #18589, #18589) that may contain additional context but are not provided here. The main task appears to be refactoring the scorer API to use `_get_response` already defined in plotting functions, but there are no clear requirements or specifications about what the `_get_response` function does, how it should be integrated with the scorer API, or what specific problems it is solving. There is also no clear description of what the expected output or outcome should be. The issue also mentions several other tasks like removing a file and modifying several classes and functions, but again, without specific requirements or specifications, it is difficult to determine what exactly needs to be done. Therefore, the issue is VAGUE and lacks sufficient information for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "scikit-learn__scikit-learn-25973": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimal code example that reproduces the bug, the expected and actual results, and the error traceback. The issue involves passing splits to SequentialFeatureSelector, which works with a simple cv value like 5 but fails with an explicit iterable of splits. The code shows that using LeaveOneGroupOut splits causes an IndexError. The reporter also mentions they've used similar functionality in other scikit-learn classes before, suggesting this might be a bug in SequentialFeatureSelector. With this information, a developer could investigate the SequentialFeatureSelector's handling of custom splits and debug the IndexError to find and fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26194": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem of thresholds exceeding 1 in the `roc_curve` function when using probability estimates. It provides a test case that demonstrates the issue and identifies the location in the code where the issue occurs. The issue also suggests a potential workaround. While there is some ambiguity about what the exact fix should be, the problem and a way to reproduce it are clearly defined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26242": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with a clear explanation of the bug (deprecation of 'base_estimator' not handling 'base_estimator=None' properly). There is a code example to reproduce the issue, expected results, and actual results. The issue also suggests a solution (adding a possible None to a list of allowed values in '_parameter_constraints'). All necessary information is provided for a developer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26289": {
        "explanation": "The issue is reasonably specified. It provides a clear error message and code examples showing the problem with export_text when feature_names is supplied. The error is a ValueError about the truth value of an array. A software engineer could use this information to debug and fix the issue. However, there are some implementation details that would require looking at the codebase to fully understand and resolve.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26318": {
        "explanation": "The issue is well-specified because it clearly describes the discrepancy between the documentation and the source code for the `warm_start` behavior in BaseForest-derived classes. It provides the exact documentation text and source code location, and offers two clear potential fixes. This allows for a straightforward solution attempt by either updating the documentation or modifying the behavior as suggested.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26323": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a specific bug report. The steps to reproduce the issue are provided with code, and both expected and actual results are given. The problem is identified as the `set_output` method of `ColumnTransformer` not applying the output settings to the `remainder` transformer. This information is sufficient to understand what the problem is and what needs to be fixed. The GitHub repository and line number where the issue occurs are also provided, making it easier to locate the code that needs to be modified. All the necessary information is included to create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26400": {
        "explanation": "The issue is well-specified. The problem is clearly described with a bug report format, including a description of the bug, steps to reproduce it, expected results, actual results (with a detailed stack trace), and system information. The reporter has provided a minimal working example that demonstrates the issue with PowerTransformer when using the 'box-cox' method on data with all-NaN columns. The issue clearly states what the problem is (unhelpful error) and what the desired outcome would be (either no error or a descriptive error). This provides sufficient information for a developer to understand the problem and implement a solution, such as adding error checking for NaN columns before applying the Box-Cox transformation.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-26644": {
        "explanation": "The issue is reasonably well-specified as it clearly identifies the problem with the current implementation of the partial_dependence function, and provides a proposed solution by adding a new argument for sample weights and changing the calculation from arithmetic averages to weighted averages. However, there are some blanks that need to be filled in, such as the specific implementation details and how to handle the sample weights vector. The user also mentions that this change should not affect ICE curves, which provides a clear constraint for the solution. Overall, while there are some details that need to be worked out, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-7760": {
        "explanation": "The issue is about improving the common tests in a machine learning library (likely scikit-learn) to catch incorrect implementations of estimators. The issue references a previous pull request (#7477) where an implementation was proposed that uses a property to modify an init parameter, which could cause problems with get_params and set_params methods. The issue suggests that the current common tests should fail this implementation, implying that the tests need to be strengthened to catch such cases.\n\nThis is reasonably specified because it gives enough context to understand the problem (properties on init parameters causing issues with parameter management) and the goal (strengthen tests to catch this). A software engineer with knowledge of the codebase could implement tests that check for these kinds of property-based parameter wrappers. However, there are some details that would need to be worked out, such as exactly how to implement the tests and what specific scenarios to check for.",
        "label": "REASONABLY_SPECIFIED"
    },
    "scikit-learn__scikit-learn-8554": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: the LocallyLinearEmbedding and Isomap classes in scikit-learn's manifold module are not accepting sparse matrices as input, despite the documentation stating they should. The issue provides specific details about the error (TypeError when passing a sparse matrix), where in the code the problem occurs (check_array calls in the manifold module), and even suggests the fix (calling check_array with accept_sparse=True). The issue also shows that the user has already done significant investigation into the problem, including code references and a backtrace. All the necessary information to implement a solution is provided.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-9274": {
        "explanation": "The issue is well-specified. The problem is clearly described as a limitation in the MLP training with the lbfgs solver where the max_iter parameter is incorrectly passed to maxfun instead of maxiter, leading to an artificial cap of 15000 iterations. The steps to reproduce are given, including example code and expected vs actual results. The suggested fix is to pass max_iter to maxiter rather than maxfun. This provides a clear path for implementation and verification. The information provided is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-9288": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem, steps to reproduce it, expected results, actual results, and environment details. The problem is about the KMeans algorithm in scikit-learn giving different results when using different numbers of jobs for parallel processing. The code example is complete and demonstrates the issue clearly. All the necessary information is provided to understand the issue and reproduce it, making it possible to work on a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "scikit-learn__scikit-learn-9775": {
        "explanation": "The issue is reasonably specified. The request is to change a parameter from a boolean `precomputed` to a more standard `metric='precomputed'` in the `trustworthiness` function of `sklearn.manifold.t_sne`. The goal is clear: make the parameter more consistent with standard scikit-learn conventions for specifying metrics. However, there are some implementation details that need to be filled in, such as how to handle other possible metric values and ensure backward compatibility, if needed. But the main task is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10021": {
        "explanation": "The issue is about a specific problem with the Sphinx documentation tool when using the autodoc extension. The user is reporting that when two configuration options are set (autodoc_unqualified_typehints = True and autodoc_typehints = \"description\"), the expected behavior is not being achieved. The expected behavior is clearly stated, and there is a minimal example provided to reproduce the issue. The issue is specific enough that someone with knowledge of Sphinx and its autodoc extension could investigate the problem and work on a solution. However, without access to the codebase and the specific implementation details of these configuration options, there are some assumptions that would need to be made about how these options interact. The issue could be a bug in the code that handles these options, or it could be a missing feature where the unqualified typehints option is not being applied when the typehints are in description mode. This requires understanding the codebase to determine the root cause and implement a fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10067": {
        "explanation": "The issue is well-specified because it clearly explains the problem with the default Sphinx documentation not including the language attribute, which causes accessibility issues. It provides specific details about the desired change: automatically setting the 'language' value in the generated 'conf.py' file during the sphinx-quickstart process using the input provided by the user. Additionally, it mentions the possibility of adding a prompt for existing installations upon an update or documentation build. The issue also references an alternative solution and a related issue, giving further context. All these details provide a clear understanding of what needs to be done for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10097": {
        "explanation": "The issue is about a problem with the display of long option names in the index of a LaTeX document generated by Sphinx. The issue is described with an example, a screenshot of the problem, and the steps to reproduce it. The problem is specific to the use of `xelatex` and the affected Sphinx version is 4.3.0. The problem is about the long option name overflowing in the index. The expected behavior is not explicitly mentioned, but it can be inferred that the long option name should be properly formatted and not overflow in the index. The problem is well-defined and the necessary information to reproduce and understand the problem is provided. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10137": {
        "explanation": "The issue is discussing a feature related to replacing hardcoded links with extlinks in a documentation system (likely Sphinx). It provides code examples and references a pull request. The main question is whether the system should allow bailing out of the replacement suggestion for certain cases. While the context and the problem are clear, the specific solution or implementation details are not fully provided. The issue requires interpreting the intended behavior and implementing the necessary changes, which involves some assumptions. Therefore, it is reasonably specified but has some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10191": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The bug is clearly described, with a detailed reproduction scenario that includes the exact content of a test file and the command to generate the PDF output. The expected behavior is stated, and there is even a screenshot provided for visual reference. The environment details (OS, Python version, Sphinx version) are also given, which is helpful for reproducing the issue. The problem appears to be related to how Sphinx handles alternating references to multiple footnotes when generating PDFs, and the goal is to ensure that footnotes are rendered correctly without being replaced by question marks and without losing hyperlinks.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10207": {
        "explanation": "The issue is about two different bugs in the Sphinx documentation tool. The first bug is that the keyboard shortcut '/' is not working to focus on the search box in the Sphinx templates, similar to how it works in GMail and GitHub. The second issue is that instance attributes are being incorrectly prefixed with the class name when using the sphinx-napoleon extension, and the third issue is about the autodoc extension not abbreviating long dictionaries. All of these bugs are clearly described with examples and steps to reproduce. The first issue is a feature request, the second is a clear bug with a specific example of the problem, and the third is a feature request for improving the display of long dictionaries. The issue is therefore reasonably specified because it provides enough information to understand what the problem is and what the desired outcome is, but there might be some interpretation needed regarding the exact implementation of the solution for each issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10323": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the bug, how to reproduce it, and what the expected behavior should be. The user provided code examples, including the file structure and content, which helps to understand the context. The problem is about the incorrect handling of indentation when using the `literalinclude` directive with `prepend` or `append` in Sphinx documentation. The user also mentioned the current workaround and why it's not ideal. All these details make it clear what the issue is and what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10325": {
        "explanation": "The issue is reasonably specified. It describes a problem where the :inherited-members: option needs to support multiple classes, and it provides two specific situations where this is needed. It also describes the desired solution (accepting a list of classes) and alternatives that have been considered. However, there are some implementation details that need to be filled in, such as how to handle nested inheritance or conflicting documentation from multiple base classes. Overall, it gives enough information to start working on a solution but leaves some room for interpretation on the exact implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10435": {
        "explanation": "The issue is reasonably specified.  The problem is clearly described: inline code highlighting in LaTeX output is adding unwanted whitespace at the beginning and end.  The issue includes a detailed example showing the erroneous output and the desired output.  A minimal example to reproduce the problem is provided, along with a comparison of the current output and the desired output via screenshots.  The issue also references a specific pull request that introduced the change.  However, the issue does not explicitly state what the correct solution is.  The reporter suggests that the space characters should be removed from the .tex file, but doesn't provide implementation details on how to achieve this.  The reporter also states they have no strong opinion on whether the current behavior is good or bad, indicating some ambiguity in the desired outcome.  A successful solution would involve identifying where in the codebase the space characters are being added and modifying the code to prevent this.  While the problem is clear, the exact implementation of the solution requires some investigation and interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10449": {
        "explanation": "The issue is well-specified. The problem is clearly described, with a detailed explanation of the bug, how to reproduce it, and what the expected behavior is. The steps to reproduce include code examples and a description of the environment. The issue is about a specific behavior when using 'autodoc_typehints = \"description\"' with Sphinx's 'autoclass' directive that is not as expected. All relevant information is provided to understand the issue and reproduce it, which is essential for creating a PR that resolves the issue. There is no ambiguity in what the problem is or what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10457": {
        "explanation": "The issue is well-specified with a clear description of the bug, steps to reproduce, expected behavior, and even a reference to the relevant function and commit. This provides sufficient information for a meaningful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10466": {
        "explanation": "The issue is reasonably specified as it provides clear examples of the problem, the location in the code where the issue is suspected, and a proposed solution. It also includes steps to reproduce the bug and expected behavior. However, there may be some blanks to fill in regarding the exact implementation and other areas of the code where the issue may also need to be addressed, as noted in the proposed solution. Overall, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-10481": {
        "explanation": "The issue is well-specified. The problem is clearly described, including the error message, the context in which it occurs, and the proposed solution. The background information provides enough detail to understand the cause and the impact of the issue. The suggested solution is specific and actionable, making it possible to create a PR that addresses the problem effectively.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10492": {
        "explanation": "The issue is well-specified. It clearly points out the bug (typos in the code), provides the exact location in the codebase (with line numbers), explains how to reproduce the issue (via a link to Read the Docs), states the expected behavior (correct spelling of 'language'), and even provides a project link for context. All necessary information is present for an experienced software engineer to understand and fix the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10504": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem is an IndexError in the Sphinx documentation build process, but the root cause is unclear. The error occurs at `node[-1].astext()` in the HTML transforms, but without knowing which specific node is causing the issue or what content is triggering it, it's difficult to determine a fix. The issue lacks crucial information about which document or content is causing the problem, what changes were made to the documentation, and where exactly in the codebase the issue is occurring. The error log shows it's happening during documentation generation but doesn't provide enough context to reproduce or fix the issue definitively.",
        "label": "VAGUE"
    },
    "sphinx-doc__sphinx-10551": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with examples of where it occurs (SciPy, NumPy, Pandas, Matplotlib) and what the issue is (a spurious space between the minus sign and the first digit in default parameter values that are negative numbers in HTML output). The issue mentions that it was originally raised with SciPy and provides specific links to examples. While it notes some uncertainty about whether the issue is in Sphinx or the PyData Sphinx theme, the problem itself is clearly defined. A successful solution would involve fixing the rendering issue to remove the space between the minus sign and the first digit in these cases. The issue does not require clarification to make an attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10614": {
        "explanation": "The issue is well-specified. The description includes a detailed explanation of the bug, steps to reproduce it, and examples of the incorrect behavior versus expected behavior. The issue is clearly about SVG inheritance diagrams generating incorrect relative links when not in the root directory, leading to 404 errors. There's even a zip file provided with a minimal reproduction case, which is very helpful. All necessary information is present to understand the problem and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10673": {
        "explanation": "The issue is well-specified. It clearly describes the problem (users trying to add genindex, modindex, and search to the toctree in Sphinx, but getting warnings about nonexisting documents), provides examples of the current approach that causes errors, and specifies the desired solution (making the directive work without errors). The issue also includes relevant background information and references to related discussions on StackOverflow. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-10807": {
        "explanation": "The issue is reasonably well-specified, but there are some blanks to fill in. The user is requesting two things: (1) a way for Sphinx to automatically create a table of contents (ToC) entry for every function, method, and class, and (2) a fix to the behavior of the automodule directive which currently places members under the bottommost docstring header. The issue provides a clear bug report with steps to reproduce, expected vs actual behavior, and even a proposed patch. However, there are a few areas that need interpretation or additional information to implement a complete solution. For example, the user suggests that the module directive should allow content, but this would require understanding the implications of changing this behavior in Sphinx. Additionally, while the user provides a potential code change, it's unclear if this is the optimal or correct solution from a design perspective. The issue also references an extension the user is working on, but details about this extension are not fully provided. Overall, there is a clear problem statement and a direction for a solution, but there are some blanks to fill in about the best way to implement the desired behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-11109": {
        "explanation": "The issue is well-specified.  It clearly describes the problem (noisy type annotations), the desired solution (PEP 604 syntax and improved Literal formatting), and even provides an example implementation from another project to reference.  The scope is also reasonably defined, focusing on a specific function and suggesting a configuration option for the new behavior.  All necessary information for a successful solution is present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11192": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, steps to reproduce the problem, environment information, and even a reference to the code repository for additional context. The user explains that using the '-j auto' option with sphinx-build results in a smaller search index, leading to ineffective search functionality. They also mention that the issue started occurring from Sphinx 6.1.0 onwards, which helps in narrowing down the problem to a specific version. The 'How to Reproduce' section gives two commands, one that causes the issue and one that works as expected, making it easy to test and validate any potential fixes. All these details make it clear what the problem is and what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11266": {
        "explanation": "The issue is about a missing space before a colon after the French phrase 'Voir aussi' in the LaTeX output of a Sphinx document. The problem was introduced in version 6.1.0 of Sphinx and the user explains that a space was present before this release. The issue also includes a screenshot and steps to reproduce the problem. The cause of the issue is linked to a previous fix (#11080) that was intended to address another issue (#6744). The problem seems to be well-defined and specific. It is clear what the issue is, how to reproduce it, and the context in which it occurred. Therefore, this issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11311": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description provides a clear problem statement (losing information in the fallback transform), explains the current implementation and its drawbacks, and proposes specific features to address the issues. The proposed solutions include technical details (like using __init_subclass__ with a meta-keyword and specific conditions for custom translator classes) that would guide the implementation. While it may require some understanding of the codebase, the goals and requirements are clearly outlined.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11312": {
        "explanation": "The issue is about the ordering of elements in a set within a tuple being unreliable when using Sphinx to generate documentation, which leads to non-reproducible output. The problem is described in detail with examples of how the output varies and a reference to a specific line of code where the issue occurs. However, there is no clear explanation of what the expected behavior should be or how to reproduce the issue consistently. The user also mentions that it's not yet clear what circumstances cause the ordering to vary. Without a clear understanding of the expected behavior and a consistent way to reproduce the issue, it is difficult to determine what a successful solution would look like. Therefore, the issue is considered vague.",
        "label": "VAGUE"
    },
    "sphinx-doc__sphinx-11316": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the specific warning that occurs when using the `ext.napoleon` extension in Sphinx. The issue is clearly demonstrated with a code example that reproduces the problem and another that shows the correct behavior. The environment information is provided, and it's clear what the expected outcome should be - to fix the warning when a reference is placed on the first line of a docstring in a dataclass attribute. There are no ambiguities in the problem description, and a software engineer with knowledge of the relevant codebase would be able to work on a solution based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11445": {
        "explanation": "The issue is well-specified. It provides a clear description of the bug, steps to reproduce it, example code, and environment information. The problem is that when using rst_prolog, top level headings containing a domain directive like :mod: are not rendered correctly or included in the toctree. The issue also includes a minimal example that demonstrates the problem. This is sufficient information for an experienced software engineer to understand the problem and create a PR to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11489": {
        "explanation": "The issue is reasonably well-specified as it provides a clear problem statement, a proposed solution with an example configuration, and some context. However, there are some areas that require interpretation, such as exactly how the regex matching should be implemented and what parts of the linkcheck functionality need to be modified. The feature request is specific enough to guide implementation, but there are some implementation details that would need to be decided during development.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-11510": {
        "explanation": "The issue is well-specified. The problem is described clearly, with a detailed explanation of the bug and how it occurs with included files. There's a clear reproduction scenario provided (with code examples for conf.py, index.rst, and the custom extension). The expected vs actual behavior is clearly defined. This provides all the necessary information for implementing a solution that would fix the issue with the source-read event not properly handling included files in Sphinx.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-11550": {
        "explanation": "The issue is well-specified because it provides a detailed description of the bug, a clear reproduction scenario with code examples, and the environment information. The problem occurs when using `autodoc_preserve_defaults = True` with a `property(lambda)` where the lambda is on a different line. It also includes the exact error message and shows that there is a workaround by removing the newline or changing the lambda to a function. This gives a clear understanding of the problem and how to reproduce it, making it possible to work on a solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7234": {
        "explanation": "The issue is reasonably specified. The request is to add support for documenting and linking to overloads of a `@singledispatch` function. The example provided shows what the desired output would look like in documentation, with a description of the master function and links to available overloads. While there are some implementation details that would need to be worked out (such as how to detect these functions, how to extract the overloads, and how to format the output), the general goal is clear and there is a sensible way to interpret and implement the solution. The example gives a good indication of the expected result.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7268": {
        "explanation": "The issue is somewhat vague because it doesn't provide a clear description of what needs to be done. It mentions loading 'sphinx.ext.autodoc.typehints' automatically after 'typehints' has matured, but it's not clear what 'matured' means, how to determine when it's mature, or what exactly needs to be done to load it automatically. There are many blanks to fill in about the requirements, the scope of the change, and the expected outcome. However, there is a general idea of integrating type hints with autodoc, so a reasonable interpretation could be made about what is required.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7305": {
        "explanation": "The issue is reasonably specified as it provides the exact code that causes the error, the error messages, and the environment details. However, there is a lack of information regarding the expected behavior, which is mentioned but not described. Despite this, one can infer the expected behavior from the context. It is clear that the problem is related to the parsing of the argument list involving the pow operator in specific versions of Sphinx.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7350": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The bug is described in detail, including the expected and actual behavior. There is a clear test case provided with code examples showing the problem. The environment information is also provided to help reproduce the issue. All the necessary information to reproduce and fix the problem is present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7351": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of the unexpected behavior, steps to reproduce, and what the expected behavior should be. The user is encountering a situation where Sphinx is not parsing the correct file when multiple files with the same name but different extensions are present. The example given demonstrates the issue with specific files (index.rst, a.md, a.rst) and shows how the current behavior is not as expected. The expected behavior is clearly stated, including the suggestion of a configuration option for file extension preference or at least a warning. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7356": {
        "explanation": "The issue is well-specified as it provides a clear description of the bug, steps to reproduce, expected vs actual behavior, and impact. The breaking change in Python domain IDs from underscores to dashes is clearly explained with code examples.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7374": {
        "explanation": "The issue is well-specified. The problem is clearly described with a concrete example of how the change broke existing functionality. It explains what the old behavior was (underscores in fragment identifiers) and what the new behavior is (dashes in fragment identifiers). The issue also provides context about why this is a problem (breaking links with nbsphinx and external links to Sphinx-generated Python API docs). The expected behavior is clearly stated as reverting to the previous behavior of using underscores in the fragment identifiers for Python functions. This provides all the information needed to implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7380": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the bug, steps to reproduce, expected behavior, and even a sample project to reproduce the issue. The user explains that parentheses in template parameter packs are not handled correctly in the C++ domain of Sphinx. The issue includes specific examples of the problematic code, such as using both static_cast and C-style casts within the template parameters. The environment information is also provided, including OS, Python version, Sphinx version, and a link to a repository with the example. All of these details make it clear what the issue is and how to reproduce it, allowing for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7395": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the index entries generated by the 'index' and 'function' directives in Sphinx documentation. It provides concrete examples of the current outputs and explicitly lists the differences between them. The desired outcome is clearly stated as unifying and merging these index entries. A software engineer would understand what needs to be changed in the codebase to achieve this unification.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7440": {
        "explanation": "The issue is reasonably specified because it provides the error message, steps to reproduce the bug, and a link to the relevant code in the project. It also includes the environment information and the expected behavior. However, it might need some investigation to find the exact cause of the duplicate term 'mysql' and to understand if it's a case sensitivity issue with the documentation tool. The necessary information is provided to begin the debugging process, but some interpretation may be needed to implement the correct fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7454": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the bug, steps to reproduce it, and the expected behavior. The user provides a complete script to reproduce the issue and shows the actual output versus the expected output. The environment information and additional context are also provided. This gives enough information to understand the issue and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7462": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, steps to reproduce it, expected behavior, and relevant environment information. The problem occurs when using a specific type annotation for an empty tuple in a function definition, which leads to an IndexError when building documentation with Sphinx. The issue includes a code snippet that reproduces the error, dependencies required to reproduce it, and a link to a project demonstrating the problem. This information is sufficient for a software engineer to understand the issue and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7578": {
        "explanation": "The issue is reasonably specified.  The problem is described as broken autosummary links in the master branch, with a specific commit identified as the source of the regression.  A test case and reproduction steps are provided, along with a warning message and a git bisect reference.  While the precise solution is not outlined, the information allows for a focused investigation into the impact of the identified commit on the autosummary functionality within the context of sphinx-gallery.  The issue lacks a detailed description of the expected behavior and a clear, step-by-step solution, but the provided information is sufficient for a meaningful attempt at solving the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7590": {
        "explanation": "The issue is reasonably specified. The user is reporting that C++ user-defined literals (UDLs) are not supported in Sphinx, leading to an error when documenting code that uses them. The issue includes a code example demonstrating the problem, an error message, and a reference to where the lack of support might be in the codebase. However, it does not provide a detailed implementation plan for adding support for UDLs, which is a non-trivial task requiring understanding of the C++ standard and Sphinx's domain parsing logic. There are some blanks to fill in, but a sensible interpretation of what is required is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7593": {
        "explanation": "The issue is well-specified with a clear description of the problem, the current behavior, the desired solution, and alternatives considered. It also includes examples and references to related issues. This information provides enough detail for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7615": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The bug is clearly described, with steps to reproduce, expected behavior, and a comparison to Docutils behavior. The input and output expectations are clearly defined for various numbers of backslashes. The environment information is provided, making it possible to reproduce the issue. All necessary information to understand the problem and what needs to be fixed is present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7670": {
        "explanation": "The issue is asking for support for C++20 requires clauses in a library. The issue provides context about the library (mp-units) and its target audience (C++23 with implementation in C++20). It also includes a link to documentation for feedback. However, the issue lacks specific details about what exactly needs to be implemented regarding requires clauses. While it's clear that support is needed, it's not clear what specific features or aspects of requires clauses need to be added. The issue would benefit from more specific requirements or examples of how the requires clauses should be used within the library. Given this lack of specificity but with some context provided, this issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7738": {
        "explanation": "The issue is well-specified. The problem is described in detail with a clear explanation of the bug, steps to reproduce it, and expected behavior. The reporter has also provided a comparison with the desired output and mentioned that older versions did not have this issue. This provides enough information to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7748": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: when using SWIG to wrap C++ classes with overloaded methods, the docstrings include multiple signatures, but the `autodoc_docstring_signature` function currently only captures the first one. The desired outcome is to modify this function to capture all signatures. While the exact implementation details are not provided, the overall goal is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7757": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear description of the bug, steps to reproduce it, the expected behavior, and environment information. The problem is related to the display of default values for positional only arguments in a Python function documentation using Sphinx. The steps to reproduce include a code snippet and a screenshot showing the problem. The expected behavior is clearly stated, and there is enough context to understand the problem. A software engineer could use this information to investigate the issue in the Sphinx codebase and create a fix for it.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7760": {
        "explanation": "The issue is reasonably specified. The user wants to configure the coverage extension to print missing coverage as a warning, similar to how the linkcheck builder reports broken links. The desired solution is to add a new configuration variable `coverage_print_missing_as_warning`. The user has also described an alternative approach using a script, but the preferred solution is clear. There are some details that need to be filled in, such as the exact behavior of the warning and where it should be printed (stdout or stderr), but the overall goal is well-defined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7762": {
        "explanation": "The issue is well-specified. The problem is clearly described: the linkcheck builder in Sphinx has a hardcoded Accept header that causes problems when checking links that require different headers. The solution is to make HTTP headers configurable. The issue provides detailed examples of the problem, including curl commands showing the difference between a working and non-working request, and clearly explains the context (a GitHub Actions badge in Sphinx docs that is now broken). The request is specific and actionable - adding configuration options for HTTP headers in the linkcheck builder. There is no ambiguity about what needs to be done - the code needs to be modified to allow users to configure HTTP headers rather than hardcoding them.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7814": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, steps to reproduce it, expected behavior, and even a proposed solution. The issue explains that Sphinx is not correctly resolving type annotations like Optional[str] when generating documentation with autodoc and intersphinx. It includes a minimal reproduction example, environment information, and a detailed diff showing a potential fix. The issue also acknowledges that the proposed solution might not handle custom classes correctly. This level of detail allows a developer to understand the problem, reproduce it, and work on a solution. The problem is specific to how Sphinx processes type annotations, and the expected outcome is clear: to have Sphinx resolve and possibly link these type annotations correctly. The issue is not vague or impossible to solve, as it provides a clear path to reproduce, understand, and potentially fix the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7859": {
        "explanation": "The issue is well-specified. The bug is clearly described with steps to reproduce, environment information, and a detailed error message. The problem is related to a KeyError when using a specific configuration option. This information is sufficient for a software engineer to identify the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7889": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7906": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example, expected output, and actual output. The behavior of the :noindex: flag is explained, and the expected result is clearly outlined. The environment details are also provided which helps in reproducing the issue. All necessary information is present for an experienced software engineer to understand the problem and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7910": {
        "explanation": "The issue is well-specified with a clear problem description, environment details, and a specific commit identified as the root cause. The user also provided relevant code snippets and an explanation of the underlying issue.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7930": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue provides a detailed description of the bug, steps to reproduce, expected behavior, and environment information. Additionally, a zip file with an example project is provided which allows for testing and verification of any solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-7961": {
        "explanation": "The issue is reasonably specified. The goal is to upgrade the Sphinx MathJax extension to support MathJax 3.0. The issue provides context on why the upgrade is beneficial (performance improvements) and a reference to the MathJax upgrading documentation, which can guide the implementation. However, the exact steps and changes needed in the codebase are not detailed, which means some investigation and interpretation will be needed. The task is clear, but the implementation details require additional work to determine.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7975": {
        "explanation": "The issue is reasonably specified.  The user explains the problem clearly (two sections named 'Symbols' in the HTML index, with the same anchor), and the conditions under which it occurs (@, \u00a3, and \u2190 characters in index entries).  However, a few details are missing for a complete solution.  For example, the specific software (presumably a documentation generator) is not identified, and the exact mechanism by which index entries are created is not explained.  These details would be helpful for a complete solution, but the core issue is clear enough to warrant a reasonable attempt at a fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-7985": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described, along with a procedure to reproduce the issue, error logs, expected results, and environment information. All the necessary information is provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8007": {
        "explanation": "The issue is reasonably specified. It describes a feature request to add an option to prevent autodoc from expanding user-defined type aliases. The request includes an example with 'Position = int' and the desire to display 'pos: Position' instead of 'pos: int' in documentation. While the specific implementation details are not given, the goal is clear enough to guide the development of a solution. The feature involves recognizing type aliases and providing a configuration option to preserve them in the output documentation. The request is coherent and the expected outcome is understandable, even if the technical approach requires some interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8035": {
        "explanation": "The issue is reasonably specified. The problem is described as the current behavior of the `:private-members:` option in autodoc documenting all private members, but the user wants to document only specific ones. The solution is for `:private-members:` to take arguments like `:members:`. While the general idea is clear, there are some implementation details that are not specified, such as how to parse and handle the arguments, how to integrate this with existing autodoc directives, and how to handle edge cases. These details would need to be worked out during implementation, but the overall goal is clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8037": {
        "explanation": "The issue is reasonably well-specified. The reporter has provided a clear description of the bug, including the error message, a stack trace, and steps to reproduce the problem. The error appears to be related to how Sphinx's C++ parser handles a specific C++14 template parameter list. The reporter also notes that the syntax is valid C++14, so the expected behavior is that the build should succeed. However, the issue lacks the actual code that is causing the problem, as it is only referenced in the error message. A developer would need to look at the code in the provided repository to understand the specific template syntax that is causing the issue. Despite this, the steps to reproduce are clear and the expected outcome is defined, which makes the issue reasonably specified and actionable for a developer.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8056": {
        "explanation": "The issue is well-specified with a clear problem description, steps to reproduce, expected behavior, and environment information. The user wants to correctly render multiple input parameters in a docstring when using numpydoc with Sphinx. The problem is that the current format is not rendering as expected, especially with the optional keyword. The issue also includes code examples and a screenshot to illustrate the problem, making it clear what the actual and expected behaviors are. This is sufficient information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8075": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, a test document that reproduces the problem, and a detailed explanation of the expected behavior. The issue also describes the environment in which the bug was found and includes specific examples of the errors encountered in both HTML and LaTeX outputs. This level of detail provides a clear understanding of the problem and what the expected outcome should be, making it possible to develop a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8117": {
        "explanation": "The issue is reasonably specified. It provides a clear description of the bug, steps to reproduce it, and the expected behavior. However, there might be some blanks regarding the specific implementation details of the macro handling in the C parser used by Sphinx.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8120": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It includes a clear description of the problem, steps to reproduce the behavior, expected behavior, and a test project. The problem is about a translation not being used even though it is generated correctly. The issue provides a GitHub repository that can be cloned to reproduce the problem, making it actionable for a developer to investigate and resolve the issue. The configuration settings and environment information are also provided, which is helpful for debugging.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8125": {
        "explanation": "The issue is reasonably specified because it describes the problem clearly and provides a desired solution. However, there are some implementation details that are not explicitly provided, such as the exact mechanism for how to modify the autodoc-skip-member function to achieve the desired behavior. A developer would need to interpret how to implement the proposed solution based on the information given. Therefore, the issue is reasonably specified, but not perfectly detailed for an immediate solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8202": {
        "explanation": "The issue is reasonably specified because it provides a clear description of the problem, steps to reproduce, code examples, and environment details. However, there are some gaps in the information, such as not explicitly stating the expected outcome in code terms and the exact cause of the warning. A solution would require understanding the interaction between Sphinx documentation generation, type hints, and Generic classes, which involves some interpretation. Therefore, the issue is not perfectly specified but has enough detail for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8264": {
        "explanation": "The issue is about a 'TypeError: 'type' object is not iterable' error when using Sphinx to generate documentation. The error traceback is provided, which points to a problem in the sphinx/util/typing.py file when trying to process type annotations. This is a specific error that occurs in a known location of the codebase, and the stack trace gives enough information to identify the root cause. The user has provided the versions of Sphinx, Python, and other dependencies, which helps in understanding the context. While the exact code causing the issue isn't provided, the error message and traceback are specific enough to guide the implementation of a solution. Therefore, the issue is reasonably well-specified for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8265": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, expected behavior, and relevant environment information. The provided Dockerfile makes it easy to reproduce the issue. The problem is about how a Python function's default arguments are being rendered in HTML documentation, and the expected correct rendering is clearly stated. All necessary details to understand and reproduce the issue are provided, making it possible to create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8269": {
        "explanation": "The issue is well-specified because it includes a clear description of the bug, steps to reproduce it, expected vs. actual behavior, and environment information. The reporter explains that the 'linkcheck' command is incorrectly reporting 'Anchor not found' instead of the actual HTTP error status codes (like 404 or 500) when the 'linkcheck_anchors' configuration is set to True. The issue also provides a test case with commands to reproduce the problem. All necessary information is provided for a developer to understand and address the problem effectively.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8273": {
        "explanation": "The issue is reasonably specified. It describes the problem (man pages in a single directory not conforming to MANPATH), the desired solution (automatic creation of section directories like man/man1), and even mentions possible alternatives. However, there are some blanks to fill in, such as how exactly Sphinx should determine the appropriate section for each man page, and how to handle backward compatibility for users who expect the old behavior. Despite these details to work out, the core problem and desired outcome are clear enough to guide a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8278": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is clearly described with a code example, expected behavior, and screenshots. The environment information is also provided, which helps in reproducing the issue. All necessary details to understand and resolve the issue are present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8282": {
        "explanation": "The issue is well-specified. The problem is described clearly, with a detailed explanation of the bug, steps to reproduce it, expected behavior, and environment information. The code examples provided give a clear picture of the setup and what is expected versus what is happening. There is no ambiguity about what the issue is or what needs to be solved.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8284": {
        "explanation": "The issue is reasonably specified. It describes the problem (man pages in a single directory not conforming to MANPATH), the desired solution (automatic creation of section directories like man/man1), and even mentions possible alternatives. However, there are some blanks to fill in, such as how exactly Sphinx should determine the appropriate section for each man page, and how to handle backward compatibility for users who expect the old behavior. Despite these details to work out, the core problem and desired outcome are clear enough to guide a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8435": {
        "explanation": "The issue is about the autodoc_type_aliases configuration in Sphinx not being applied to variables and attributes as expected. The description includes a clear bug report with steps to reproduce, expected behavior, and environment information. All necessary code examples are provided. The problem is well-defined and reproducible, making it possible to create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8459": {
        "explanation": "The issue is well-specified. The user provides a clear description of the bug, steps to reproduce it with code examples, the observed behavior, and the expected behavior. All necessary information to understand and reproduce the issue is included.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8474": {
        "explanation": "The issue is reasonably specified. It describes the problem (a warning message after upgrading to Sphinx 3.3), the context (building with `singlehtml` or `latex`), and what the reporter has already tried (checking the changelog and looking for changes related to `numref`). However, some details about the exact cause of the warning are not provided, and the reporter is seeking guidance on where to look for the cause of the warning. While the reporter is asking for help identifying the source of the warning, the issue itself is clear and actionable for someone with knowledge of Sphinx's internal logic.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8475": {
        "explanation": "The issue is well-specified. It clearly explains the problem (infinite redirect loops with HEAD requests causing the linkchecker to report valid links as broken), provides context (this is a regression introduced in Sphinx 3.2.0), and describes the proposed solution (extending the except clause to handle TooManyRedirects exceptions and retry with GET requests). The issue also includes a specific example URL that demonstrates the problem. All necessary information is provided to implement the fix without needing additional clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8506": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example and the error message from Sphinx 3.2. It explains the context of the QEMU documentation and the change in behavior in Sphinx 3.2. The desired outcome is also clearly stated - to make Sphinx accept any string for option descriptions. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8509": {
        "explanation": "The issue is reasonably well-specified because it provides the background and reasoning for the change, references to relevant pull requests and issues, and describes the benefits of using uplatex. However, there are some assumptions that would need to be made when implementing the solution. For example, it doesn't explicitly state where in the codebase this change should be made or what specific files or functions need to be modified. A developer would need to look through the Sphinx codebase to find where the latex_engine is currently set for Japanese docs and change it to use uplatex by default. While the overall goal is clear, some implementation details would need to be inferred.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8539": {
        "explanation": "The issue is well-specified and provides clear steps to reproduce the problem, expected behavior, and environment information. It includes code examples, a sample project, and explains the problem in detail. This gives enough information for a software engineer to understand what the issue is and how to approach a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8548": {
        "explanation": "The issue is about a specific bug in the autodoc functionality of Sphinx where inherited attributes (data members) are not being properly documented when using the inherited-members option. The issue description provides some technical details about how the current implementation uses (namespace, attrname) as a search key but doesn't account for base class namespaces. It also references a Bitbucket issue for more context. While the technical background is provided, it may require some understanding of the Sphinx codebase and autodoc functionality to implement a solution. However, the core problem is clearly stated, and there is enough information to begin investigating and resolving the issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8551": {
        "explanation": "The issue is reasonably specified because it provides a clear description of the bug, steps to reproduce it, and the expected behavior. However, some technical details about the codebase and the specific logic for cross-reference resolution in Sphinx may need to be understood or inferred to implement a fix. The example provided gives a reproducible scenario, which is helpful, but the actual code implementation details would need to be explored to create a PR. Therefore, it is not completely well-specified without some additional investigation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8552": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly states the requirement to support the \"Receives\" section of NumpyDoc guidelines, which is related to the already supported \"Yields\" section. The issue also provides a link to the NumpyDoc documentation for context and explains what the \"Receives\" section is for. Additionally, it specifies the relationship between \"Receives\" and \"Yields\" sections in docstrings. This information is sufficient to understand the task and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8579": {
        "explanation": "The issue is well-specified with a clear description of the bug, steps to reproduce, and the expected behavior. The error messages and environment information provided are also helpful for diagnosing the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8593": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example showing how to reproduce the issue, what the expected behavior is, and environment information. The reporter explains that the ':meta public:' directive is not making the private variable '_foo' visible in the documentation as expected. All necessary information to reproduce and understand the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8595": {
        "explanation": "The issue is well-specified. The problem is clearly described with a bug report format, including a code example to reproduce the issue, the expected behavior, and the actual behavior. The reporter explains that when `__all__` is set to an empty list in a module, Sphinx's autodoc extension is still documenting all functions in the module, whereas it should not be documenting any functions. The issue has enough detail for a software engineer to understand the problem and work on a fix for the autodoc extension in Sphinx. The code examples and the explanation of the discrepancy between expected and actual behavior make this issue well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8599": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The reporter provides a clear description of the desired functionality, explains the current limitations, and even proposes a solution with specific configuration options. They also give concrete examples of the HTML they want generated and show how they would use these new configuration options in their conf.py file. The issue connects to a specific use case (FontAwesome icons) but presents a general solution that would apply to any custom HTML content. The reporter acknowledges they're new to the Sphinx codebase but has already made a working patch, showing the problem is well-understood. This provides all the necessary information for implementing the requested feature.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8611": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description clearly explains the problem (Sphinx complaining about an undocumented inherited attribute), provides steps to reproduce the issue, and specifies the expected behavior. The issue also provides the relevant code snippet and environment information.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8621": {
        "explanation": "The issue is well-specified. The problem is clearly described with examples of incorrect and expected output. The reporter explains the current simplistic algorithm's flaw and what the correct behavior should be. There are repro steps, environment info, and a screenshot. A solution would need to modify the algorithm for parsing keystrokes to properly handle these characters in different contexts.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8633": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed error message, steps to reproduce the bug, and an explanation of the environment in which it occurs. The issue includes code snippets that demonstrate the error, an explanation of when the issue started (with a specific version of Sphinx), and a note that it does not occur with an earlier version. The error is related to an AttributeError with a 'LookupDict' object missing the '__name__' attribute. All the necessary information is provided to understand the problem and reproduce it, making it clear what needs to be fixed. The issue is specific and actionable for a developer to investigate and resolve.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8638": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: instance variables are incorrectly linking to other variables with the same name in the project when using autodoc via apidoc. There is a reproducible test case provided (the GitHub repo and steps to reproduce), and the expected behavior is clearly defined. The issue also provides environment details and even a screenshot. All of this information allows for a clear understanding of what the problem is and what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8674": {
        "explanation": "The issue is reasonably specified.  It describes a need to pass options to pygments for syntax highlighting, with a specific example of the :startsinline: option for PHP snippets.  It suggests a possible implementation approach (default options in conf.py, with sourcecode block options). However, the issue lacks details on the exact syntax to use for specifying options in the sourcecode blocks, and how to handle conflicts between default options and block-specific options.  These are important details that would need to be decided during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8679": {
        "explanation": "The issue is well-specified. The problem is described in detail with a clear example of the bug, steps to reproduce, and a link to a project that demonstrates the issue. The expected behavior is also outlined. A software engineer with experience in Sphinx could use this information to investigate the cause of the bug and implement a fix.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8684": {
        "explanation": "The issue is reasonably specified. The user wants to extend the functionality of the 'dedent' feature to work with code-blocks and literalincludes, similar to Python's textwrap.dedent. While there are some details that are not explicitly provided (such as the exact behavior when a dedent value is provided, or the specific implementation context), the general goal is clear. A software engineer with experience in the codebase could make reasonable assumptions to fill in the blanks and implement the desired functionality.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8707": {
        "explanation": "The issue is reasonably specified. The problem is that the viewcode extension is not working as expected when running the `make clean singlehtml html` command. The expected behavior is that viewcode should be enabled for HTML builds except for singlehtml and epub. The environment and steps to reproduce are provided, which gives a clear direction for investigation. However, there are some details that need to be filled in, such as the exact behavior when it doesn't work and how the fix should be implemented.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-8721": {
        "explanation": "The issue is well-specified enough to understand the problem and what is expected. The problem is that viewcode is creating pages for epub when it shouldn't be. The expected behavior is clearly stated (module pages should not be created for epub by default), and there is a step to reproduce the issue. A software engineer would be able to understand the issue and create a PR to resolve it without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8729": {
        "explanation": "The issue is well-specified with a clear description of the problem, steps to reproduce, expected vs actual behavior, and even a sample project. This allows for a meaningful solution attempt.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8771": {
        "explanation": "The issue is about keeping the original constant names in function signatures when using Sphinx's autodoc feature. The reporter provides a clear example of the problem: instead of showing 'option=DEFAULT_OPTION' in the documentation, Sphinx resolves the default value to its string representation 'option='default''. The issue includes a specific desired outcome (showing the constant name instead of its value) and a reference to an existing report. The problem is well-defined and actionable for a developer familiar with Sphinx's autodoc implementation.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8801": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example, expected behavior, and environment information. A software engineer would understand what the issue is and how to reproduce it in order to attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-8969": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with a detailed explanation of the current behavior versus the expected behavior. The reporter also provides steps to reproduce the issue, along with examples of relative and absolute imports and their outcomes. However, there are some blanks to fill in regarding the exact implementation of a solution. For instance, the specific technical approach to align the `csv-table` directive's path resolution with that of the `figure` directive is not fully detailed. Despite this, there is a sensible interpretation of what is required for a successful solution, which is to modify the `csv-table` directive to support source-relative paths similar to the `figure` directive. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9015": {
        "explanation": "The issue is well-specified with a clear description of the problem, including code examples, screenshots, and expected behavior. The problem is related to how a type annotation is rendered in documentation when using Sphinx and autodoc. It explains what is happening (the `TracebackType` is being rendered as `traceback` and linked incorrectly), and what should happen instead (it should be `TracebackType` and linked to the correct documentation). The issue also includes information about the project and environment, which is helpful for context. There is no ambiguity about what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9104": {
        "explanation": "The issue is well-specified enough to understand the problem and reproduce it. The warning is about a missing reference to '..' in the documentation. The steps to reproduce are provided in detail, the code snippet is included, and the environment information is given. The expected behavior is also described. The main task is to fix the reference in the documentation which is clear from the context. The issue is not vague and a solution can be attempted.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9128": {
        "explanation": "The issue is well-specified because it includes a clear description of the bug, steps to reproduce the problem with code examples, the expected behavior, and the actual behavior (with a warning message). The environment information and the output log are also provided, which is helpful for debugging. All necessary information is given for a developer to understand and reproduce the issue before attempting to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9155": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal reproduction example, the expected behavior, and the environment information. The warning message is provided, and there's a clear understanding of what the expected outcome should be. All necessary information is given to understand the problem and work on a solution without requiring further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9171": {
        "explanation": "The issue is reasonably specified. The user is asking how to suppress the automatic addition of the constructor signature when using the autoclass directive in Python. They explain the problem (the constructor signature is included in the heading) and their desired outcome (to document the constructor separately and avoid confusion). While the exact implementation details may not be clear, the goal is understandable, and a solution can be attempted by modifying the Sphinx documentation configuration or directive usage.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9207": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The reporter has provided a clear description of the problem, including steps to reproduce the bug with a minimal reproduction repository. They also provided the expected behavior, actual behavior, environment information, and even identified a specific commit that introduced the issue. This level of detail allows a software engineer to understand the problem, reproduce it, and work on a solution. All necessary information is provided to investigate and fix the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9229": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The user provided a detailed description of the problem, steps to reproduce, and what the expected behavior should be. Additionally, they provided a code snippet and a link to a project, as well as screenshots and environment information. All of these make it possible to understand and address the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9230": {
        "explanation": "The issue is well-specified. The user is describing a specific problem with the rendering of a parameter in the generated documentation when using a particular data type in the docstring. The issue includes a clear description of the problem, steps to reproduce it, expected vs actual behavior, and even provides a project example to reproduce the issue. The screenshots help to visually demonstrate the problem. All necessary information is provided to understand and potentially fix the issue with the documentation rendering in Sphinx.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9231": {
        "explanation": "The issue is well-specified. It clearly states the problem: the `man_make_section_directory` option is enabled by default, which is causing breakage in projects and Linux distributions. It provides specific examples of the breakage and explains why the current implementation is problematic (incorrect directory structure). The issue also suggests the desired change (keeping it disabled by default). With this information, an experienced software engineer could understand what needs to be changed in the codebase to revert or modify the default setting and fix the directory structure issue.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9233": {
        "explanation": "The issue is reasonably specified. It explains the need for a new hook/event to customize the base list formatting for classes, particularly for parameterized types. It proposes a specific signature for the new hook and describes two possible ways it could work (modifying a list or returning a string). While there are some details that would need to be worked out in implementation, the overall goal and approach are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9234": {
        "explanation": "The issue is reasonably specified. It explains the problem with redirects, the desired solution (prohibiting unknown redirects by listing allowed URL pairs), and provides an example. However, there are some details that would need to be filled in, such as how exactly to implement the URL pair checking, how to handle different redirect types, and how to integrate this with the existing linkchecker logic.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9246": {
        "explanation": "The issue is well-specified. It provides detailed steps to reproduce the error, including code snippets for setup and configuration. The error message and environment information are included, which helps in understanding the context. Additionally, the user has already done some investigation and points to a specific part of the code that might be causing the problem. All these details make it clear what is needed to address the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9258": {
        "explanation": "The issue is reasonably specified as it provides a clear use case and example of the desired functionality. The request is to add support for union types using the | syntax in a specific context, likely related to type hinting in docstrings. While there is some implicit context (such as the specific tool or system this is for), the example given is clear enough to understand what is being asked for and how it should be implemented. Some additional clarification might be helpful, but the core requirement is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9281": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem (ugly rendering of Python Enum values in function signatures), provides a minimal example to reproduce the issue, explains the expected vs actual behavior, and includes environment information. This provides sufficient context and requirements for an experienced developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9289": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, steps to reproduce it, and the expected behavior. The reporter includes a minimal project setup, code examples, and a visual representation of the problem. This information allows an experienced software engineer to understand the issue and work on a solution effectively.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9320": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with the following elements: the command being run, the specific error behavior when pressing Enter, and the expected behavior. The issue includes steps to reproduce, environment details, and a screenshot for additional clarity. All necessary information for diagnosing and addressing the problem is present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9367": {
        "explanation": "The issue is well-specified. It clearly states the problem: a 1-element tuple is being rendered without the trailing comma. It provides a specific example of the expected output (\"(1,)\") and the actual output (\"(1)\"). The issue also provides an exact location to add a test case to reproduce and verify the fix. All necessary information is present for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9386": {
        "explanation": "The issue is reporting a specific bug in the Sphinx documentation tool where type hints are still being rendered in the output for properties even when the `autodoc_typehints` configuration is set to `none`. The issue provides a minimal reproducible example (a zip file), describes the expected behavior, and includes a screenshot to demonstrate the problem. The environment and configuration are also clearly specified. All of this makes the issue very well-specified, as it gives enough information to reproduce the problem and understand what the correct behavior should be. A software engineer would be able to download the zip file, reproduce the issue, and work on a solution to fix the rendering of type hints for properties when `autodoc_typehints` is set to `none`.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9461": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: Sphinx is not documenting methods decorated with both @classmethod and @property. There's a clear explanation of the issue, steps to reproduce, an expected behavior, and a specific project/repository to test against. The issue also includes specific examples of methods that are not being documented properly. The relevant Python version (3.9) and Sphinx version (4.0.3) are provided, along with the extensions being used. All these details make it possible to reproduce the issue and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9464": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed explanation of the bug, how to reproduce it, expected vs actual behavior, and even a suggested fix. The reporter has also provided a minimal test project and screenshots for clarification. All the necessary information to understand and fix the problem is present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9467": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, steps to reproduce it, expected behavior, and relevant context such as the specific commit that introduced the change and the failing test logs. This information allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9547": {
        "explanation": "The issue is reasonably specified. The reporter provides clear examples of the problem with the parsing errors, and they even suggest potential solutions by referencing specific parts of the codebase and relevant documentation. However, there are still some blanks that need to be filled in regarding the exact implementation details and how to handle the various GNU extension types. A reasonable interpretation of what is required is to add support for these GNU extensions within the C domain parser in Sphinx.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9591": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal reproducible example, steps to reproduce, expected behavior, and additional context including versions of software involved. The reporter has shown that cross-references are not working for property's type annotations in Sphinx documentation. The example code shows two classes 'Square' and 'Rectangle' with similar structures but different documentation styles, and the issue is specifically about the lack of cross-referencing in the type annotations for the 'end' property. The reporter has provided a GitHub repository and Read the Docs link to see the actual generated documentation, which helps in understanding and verifying the issue. The reporter has also specified the OS, Python versions, and Sphinx version where the issue occurs. All of these details make the issue well-defined and actionable for a software engineer to investigate and potentially fix the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9602": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear explanation of the bug, steps to reproduce it, an example project, and an expected behavior. This gives enough information to understand the issue and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9654": {
        "explanation": "The issue is well-specified. It describes a specific bug in base class detection when documenting a class hierarchy. The steps to reproduce are clear, the expected behavior is defined, and the project context is provided. This provides enough information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9658": {
        "explanation": "The issue is well-specified because it includes a detailed description of the problem, steps to reproduce it, expected behavior, and additional context. The problem is related to incorrect documentation of inherited classes when mocked, and it provides examples and specific versions of Sphinx where the issue occurs. The user also provides a GitHub repository and a ReadTheDocs build for reference, making it easy to reproduce and understand the issue. The information given allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9665": {
        "explanation": "The issue is related to a feature request in the Sphinx documentation tool, specifically regarding how base classes are documented in Python packages. It references a previous issue (#4944) and a pull request (#9233) that partially addressed the problem. The problem is that while it's now possible to return a different base class using `autodoc-process-signature`, there is still no control over the hyperlink text for that class. The proposed solution is to allow `autodoc-process-signature` to return a list of strings that would be appended to 'Bases: ', which would allow for formatting the hyperlink as something like ':class:`telegram.TelegramObject`'.\n\nThe issue is reasonably well-specified because it clearly describes the problem, the desired solution, and the context from previous discussions. It explains what is not working as expected and what the expected behavior should be. The solution is specific and actionable - allowing the return of formatted strings from `autodoc-process-signature` to control the hyperlink text. The connection to previous issues and pull requests provides necessary background for understanding the problem.\n\nHowever, there are some implementation details that would need to be worked out. For example, the exact format of the strings being returned, how they should be parsed, and how they should be integrated into the documentation output. These are reasonable blanks to fill in based on the context provided and standard practices in Sphinx documentation.\n\nThe issue is not vague or impossible to solve. It's a clear documentation formatting issue with a specific proposed solution that builds on existing functionality.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9673": {
        "explanation": "The issue is well-specified because it provides a clear description of the bug, steps to reproduce it, expected behavior, and the actual outcome. The reporter has included a code example, configuration settings, and even a screenshot to demonstrate the problem. This information allows a developer to understand what the issue is, how to replicate it, and what the expected behavior should be. All the necessary details to attempt a solution are present.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9698": {
        "explanation": "The issue is reasonably specified as it provides a clear description of the problem, steps to reproduce, expected behavior, and additional context such as screenshots. However, some details are missing, such as the expected output or the exact code changes required to fix the issue. Despite this, a reasonable interpretation can be made to address the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9711": {
        "explanation": "The issue is well-specified. The problem is clearly described: the 'needs_extensions' check is comparing version strings lexicographically instead of semantically. A reproduction case is provided, along with the expected behavior (semantic version comparison). The actual error message shows the incorrect comparison (0.6 > 0.10), which is a clear indication of the problem. A specific example project is provided to demonstrate the issue. The necessary information for diagnosis is all present - what the current behavior is, what the expected behavior should be, and how to reproduce it. The problem is clearly defined and actionable for a developer to fix.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9799": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem (hexadecimal default arguments are converted to decimal in the documentation), steps to reproduce the issue with a concrete code example, expected behavior, and environment details. The problem is specific and actionable for a software engineer working on the Sphinx project or extension responsible for handling documentation of default parameter values. All necessary information is provided to understand what is wrong and what the desired outcome is.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9828": {
        "explanation": "The issue is reasonably specified. It describes the problem with fuzzy translations not being used, proposes a solution with a new configuration parameter, and provides specific code changes needed. However, some implementation details might need to be filled in, like how the configuration parameter is handled elsewhere in the codebase. But there's a clear understanding of what needs to be done.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9829": {
        "explanation": "The issue is reasonably specified. It clearly describes the problem with MathJax configuration in Sphinx, particularly with MathJax 3, and presents three possible solutions. However, the solution requires deciding which of the three options to implement (or if a combination is needed), which introduces some ambiguity. The context and desired outcome are clear enough to make an informed decision.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9902": {
        "explanation": "The issue is reasonably specified as it provides a clear description of the problem, steps to reproduce, expected behavior, and even a sample project. However, it may require some interpretation of the context and the specific implementation details of Sphinx to create a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sphinx-doc__sphinx-9931": {
        "explanation": "The issue is well-specified and clear. It explains the current behavior of the `add_module_names` configuration in Sphinx's autodoc, how it affects the rendering of class/function/attribute headers but not type annotations. It provides a concrete example of the code and configuration, and clearly describes the expected vs. actual output. The desired solution is also outlined with possible configuration options. This information is sufficient to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sphinx-doc__sphinx-9997": {
        "explanation": "The issue is well-specified. The problem is described with a clear bug report, steps to reproduce, expected behavior, and environment information. The reporter explains that autodoc typehints are not generating links for parametrized types like `Literal`, and provides a specific example. The issue includes a code snippet to reproduce the issue and a screenshot for visual reference. The reporter also mentions the expected outcome (that `Literal` should link to typing.Literal in the Python documentation). This level of detail makes it clear what the problem is and what a successful solution would look like.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-11384": {
        "explanation": "The issue is asking for a change in how the `fps` function prints its output to more clearly indicate that it is representing a formal power series. The problem is clearly described with examples of current behavior versus desired behavior. The user also provides a specific example of what the string representation looks like now and what it should ideally represent. There is a clear goal of changing the print output to reflect the actual formal power series structure. The second part about handling cases where `fps` can't compute a result is a side question, but the main issue is well specified enough for a meaningful solution attempt. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-11400": {
        "explanation": "The issue is reasonably specified. It reports that the `ccode` function in SymPy does not handle the `sinc` function correctly, outputting a comment that it is not supported in C instead of generating valid C code. The user suggests that since `math.h` does not have a `sinc` function, SymPy should instead generate a piecewise expression similar to what is shown in the example with `Piecewise`. While the issue provides a clear example of the problem and a suggested approach, some implementation details would need to be filled in, such as how exactly to translate `sinc` into a piecewise expression in C code. However, the overall goal is clear enough to proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-11438": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is to fix the misclassification in the diophantine function. The example provided shows the current incorrect behavior and the expected fix is to check that all powers are the same, not just that they are even. The code change needed is clear from the description. The issue is specific with a test case and a clear explanation of the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-11618": {
        "explanation": "The issue is well-specified. The problem is described as a distance calculation error between two points with different dimensions. The example given shows that when calculating the distance between a 2D point (2,0) and a 3D point (1,0,2), the current implementation only considers the first two dimensions and ignores the third. The correct calculation should include all dimensions. The code example provides a clear illustration of the incorrect behavior. A solution would involve modifying the distance calculation to account for all dimensions of the points, ensuring that it correctly computes the Euclidean distance across all axes. There is no ambiguity in what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-11788": {
        "explanation": "The issue is not completely clear without more context. It describes a problem with how singularity function powers are printed in the qtconsole, but doesn't explicitly explain what the expected behavior should be, only showing an image of the output. While someone with domain knowledge of SymPy's printing system and Beam functionality could interpret and fix this, the issue is somewhat vague for someone unfamiliar with the codebase. The image might help, but it's not included here, so the actual problem is not fully described. Additionally, there's no clear description of what constitutes a successful solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-11794": {
        "explanation": "The issue is asking for the implementation of ASCII printing for Singularity Functions, but it lacks important details. It doesn't specify what Singularity Functions are, how they should be represented in ASCII, what the expected output should look like, or any requirements for the implementation. Without these details, there's too much ambiguity about what exactly needs to be done. A developer would need to make many assumptions about the requirements.",
        "label": "VAGUE"
    },
    "sympy__sympy-11822": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes an exception that occurs when printing a Symbol with an empty string in the context of IPython. The error traceback is provided, which shows where the problem is happening in the code. It also gives a hint that the issue is related to the Unicode pretty printer and that it works when using Unicode is disabled. This information is sufficient for a developer to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-11862": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem with code snippets and expected vs. actual behavior. It explains the context and the discrepancy between the results when using lambdify with the mpmath module. The steps to reproduce the issue are outlined, and the problem statement is clearly defined. Therefore, the correct label is WELL_SPECIFIED.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-11870": {
        "explanation": "The issue is asking to simplify an expression involving exponential functions into trigonometric identities, specifically to simplify expressions involving complex exponentials to sine and sinc functions. The first example shows an expression that should simplify to sin(k), and the second example should simplify to sinc(k). This is a well-defined problem in symbolic mathematics with a clear goal. The examples provided show what the expected output should be, making it possible to implement a solution (e.g., using Euler's formula to convert exponentials to trigonometric functions).",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-11897": {
        "explanation": "The issue is reasonably specified because it provides concrete examples of the inconsistency between the LaTeX printer and the pretty printer. The examples show specific cases where the outputs differ, and the user explains that the LaTeX printer should give the same output as the pretty printer unless a better LaTeX output is possible. This gives enough information to understand the problem and work on a solution, though there may be some interpretation needed for what constitutes 'better output' from LaTeX.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-11989": {
        "explanation": "The issue is reasonably specified. The user is reporting that the Diophantine function is not finding all solutions for two specific equations, and provides examples of missing solutions. While the exact cause is suspected to be related to the elliptic case solving, the problem and expected outcome are clear enough to guide an investigation and potential fix in the Diophantine solver.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-12088": {
        "explanation": "The issue is reasonably specified as it provides clear examples of the problem and some context about the potential cause. The user is explaining that when creating a Poly with a high-precision number (pi.evalf(1000)), the resulting Poly does not use the correct precision unless mpmath.mp.dps is set to the same high value. They also mention that the default precision is 53, which corresponds to 15 base-10 digits, and there might be confusion between base-10 and base-2 precision in the code. The examples provided show the different behaviors when changing the mpmath.mp.dps value and attempting to use a custom domain. However, the issue does not provide detailed information about the expected behavior, the specific code files or functions that need to be modified, or the exact steps to implement the solution. The reporter is asking for a solution that would allow the Poly to correctly use the specified precision without having to set mpmath.mp.dps globally. The problem is clear, but there are some blanks to fill in about the implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-12096": {
        "explanation": "The issue is well-specified. The problem is described with a clear example, and the cause is identified as the lack of recursive evalf calls in Function._eval_evalf. A solution would involve modifying the _eval_evalf method to ensure it recursively calls evalf on the result of _imp_.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12108": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the current behavior (printing And(Not(x), Or(y, z))), the desired behavior (~x & (y | z)), and the specific task of modifying the str printer (and non-Unicode pretty printer) to use the operators ~, &, and |. The issue also mentions a potential challenge (parenthesization) but indicates that the fix should be relatively straightforward. All necessary information is provided for an experienced software engineer to implement the requested change.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12171": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with examples of incorrect behavior and proposed solutions. The issue mentions specific functions that need to be added to the MCodePrinter class. The examples show what the current incorrect output is versus what the desired output should be. This provides clear guidance on what needs to be implemented. The proposed code fixes are even provided in the issue description, making it straightforward to implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12194": {
        "explanation": "The issue is reasonably specified. The user is asking for a feature to return a list of prime factors including multiplicity, either through an option to `factorint` or a new function. While the exact implementation (new function vs. option to existing function) is not specified, the desired functionality is clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-12214": {
        "explanation": "The issue is about B-splines of degree greater than 1 not working as expected in the spline_basis function. The user provides examples of code that breaks and works, and describes their approach to generating knots. It is clear what the problem is and what the expected outcome is, but there might be some details about the implementation that are not clear. Therefore, the issue is reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-12227": {
        "explanation": "The issue is reasonably specified, but there are some blanks to fill in. The problem is clear: the Float constructor in SymPy currently allows setting decimal precision (via 'prec') which is then converted to binary precision. However, the user wants to be able to directly specify binary precision. The proposed solution includes changing the keyword argument names to differentiate between decimal ('dps') and binary ('prec') precision. There are also notes about backward compatibility concerns and the need for a deprecation cycle, but it's not clear how exactly to implement the deprecation or handle existing code that uses the 'prec' argument. The overall direction is clear, but some implementation details and backward compatibility strategies are not fully specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-12236": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem description is presented as a code example with input and output, but it's unclear what the expected or correct output should be. The issue is essentially reporting a discrepancy between different usages of the 'apart()' function in SymPy, but without clearly explaining what the expected behavior should be, what the actual behavior is, or why it's considered wrong. The problem is also not clearly stated in the issue description. It's not clear if the issue is about the function 'apart()' not handling certain expressions correctly, or about inconsistent behavior between different usages of the function. The issue also lacks context about what the function 'apart()' is supposed to do and how it should behave in this specific case. The code example shows that different results are obtained when using 'apart()' with and without substitution, but without knowing what the expected result should be, it's difficult to determine what the correct solution would be.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "sympy__sympy-12270": {
        "explanation": "The issue is well-specified enough to understand the problem and attempt a solution. The user has provided multiple examples showing the expected and actual behavior of the `extract_multiplicatively` method. They've also analyzed the root cause by pointing to the relevant code in `core/expr.py` and provided specific test cases that demonstrate the bug. The issue is about a specific method's behavior with negative factors, and it's clear what the expected outcome should be based on the examples. The question of whether it's a bug and how to fix it is clear enough for a developer to investigate and propose a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12307": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the Fortran code generation for the sign function in Sympy, provides a code example showing the current incorrect output, and suggests a fix by generating valid Fortran syntax like 'sign(1, x)' or 'sign(1d0, x)'. The issue also includes a reference to the Fortran sign function syntax documentation. A developer would have sufficient information to identify where in the codebase the sign function is handled during code generation and implement the suggested fix.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12419": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a code example that demonstrates the unexpected behavior. The reporter explains that the sum of the elements of an identity matrix should be 'n' but is returning 0. They also provide a minimal working example that shows the problem and what they expect to happen. The issue is about the incorrect evaluation of the sum of elements in an identity matrix within the SymPy library, which is reproducible with the provided code. The reporter has tested several properties of the matrix and has identified that the issue is specifically with the total sum of the elements.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12454": {
        "explanation": "The issue is well-specified. The problem is described in detail, including the error message, the function code, and the specific matrix dimensions that cause the error. The error appears to be due to an out-of-bounds index (3,2) in a 4x2 matrix, which is clearly explained. A solution would involve fixing the index ranges in the is_upper() function to avoid accessing invalid indices for matrices where columns < rows.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12472": {
        "explanation": "The issue is somewhat ambiguous because it doesn't provide a clear explanation of the expected behavior or the problem that needs to be solved. It shows an example where the sqrt function is splitting out a factor, but it's not clear whether this is the desired behavior or not. The reference to a pull request #12472 suggests that there's already a fix, but the issue is being used as a reminder to add a test. The description lacks a clear problem statement and expected outcome, making it difficult to determine what exactly needs to be tested and what the correct behavior should be. The example shows an output, but it doesn't state what the correct or expected output should be. Therefore, the issue is not well-specified enough for a meaningful attempt at a solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-12481": {
        "explanation": "The issue is well-specified because it clearly states the problem: the `Permutation` constructor raises an error when given non-disjoint cycles, but it should instead apply them in left-to-right order and return the resulting permutation. The expected behavior is described with an example (`Permutation([[0,1],[0,1]])` should return the identity permutation instead of raising an error). The issue also explains that handling non-disjoint cycles should be possible. This provides enough information for a software engineer to understand what needs to be fixed in the code. The goal is clear: modify the `Permutation` constructor to handle non-disjoint cycles by applying them in left-to-right order instead of raising an error.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12489": {
        "explanation": "The issue is well-specified and clearly describes the problem with subclassing `Permutation` in the `combinatorics` module. It explains that the `__new__` method is used for object creation and that the `_af_new` method ultimately creates the object using `Basic.__new__(Perm, perm)`. This makes subclassing `Permutation` impossible unless `Permutation._af_new` is overridden, which is not ideal. The issue also suggests an elegant solution by using Python's instance creation mechanisms and classmethods. The user has tested a monkeypatch locally and all tests succeeded, indicating that the solution is feasible. The issue also asks for an explanation if there are any reasons why the current implementation should not be changed. Therefore, the issue is well-specified and it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12798": {
        "explanation": "The issue is not well-specified because it lacks details about what exactly needs to be reverted, why the change should be reverted, and what the expected outcome is. It references a pull request but does not provide the specific changes or context needed to understand the problem and how to fix it. Without this information, it is unclear what a successful solution would look like.",
        "label": "VAGUE"
    },
    "sympy__sympy-12881": {
        "explanation": "The issue is reasonably specified. It indicates that the `free_symbols` method for a polynomial should return only the symbols that are actually present in the polynomial's expression. The current implementation seems to include all symbols from the generators, even if they are not present in the monomials. The example `Poly(x,x,y).free_symbols` should return `{x, y}` but instead, it is returning `{x}`. The code snippet provides a starting point for the implementation, and while there is some uncertainty about the `free_symbols_in_domain` part, the overall goal is clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-12906": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem. The example shows that applying the canonical method twice to an expression does not yield the same result as applying it once, which is unexpected. This indicates a bug in the canonical method's implementation. A developer can use this example to reproduce the issue and investigate why the canonical form is not idempotent as expected. The goal is to fix the implementation so that applying the canonical method multiple times yields the same result as applying it once.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-12977": {
        "explanation": "The issue is reasonably specified because it clearly states that nullary functions should be allowed, and provides a traceback error related to calling an empty sequence in max(). This gives a clear direction to investigate the function __new__ in function.py and the handling of nullary functions. However, it lacks specific details on the desired outcome for subclasses of Function and how exactly nullary functions should be implemented or modified within the existing codebase. A developer would need to interpret and fill in some blanks regarding the exact requirements and expected behavior for these functions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13001": {
        "explanation": "The issue is well-specified. The problem is described with a clear example of the code and the unexpected result. It explains why the result is unexpected (due to the structure of the expression as a Mul with evaluate=False). The goal is to fix the CSE function so that it correctly handles this case and returns an equivalent expression. There is enough information to understand what the current behavior is, what the expected behavior should be, and why the current behavior is incorrect.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13031": {
        "explanation": "The issue is well-specified because it provides a clear description of the problem, including code examples that demonstrate the change in behavior between SymPy 1.0 and 1.1. The issue shows that when horizontally stacking zero-row matrices with different column dimensions, the resulting matrix shape is now (0, 3) instead of (0, 6) in the newer version. Additionally, it includes a contrasting example with one-row matrices that still works as expected, returning (1, 6). This contrast helps identify what is different about the behavior in these two cases. The problem is well-defined, and a solution would need to investigate the change in SymPy's Matrix.hstack implementation and potentially revert or adjust it to restore the previous behavior for zero-row matrices.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13043": {
        "explanation": "The issue is reasonably specified. The problem is clearly described: the decompose() function returns a list of arbitrary order, causing test failures. The suggestion is to sort the output or use a dictionary instead. While some details about the desired sorting order or exact expected behavior are not provided, the general direction is clear enough to attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13091": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear explanation of the problem with comparison methods in the sympy library returning False instead of NotImplemented when encountering unknown types. The issue includes a specific example of how this causes asymmetric equivalence relations between sympy objects and custom classes. The issue also provides a concrete solution suggestion - changing line 316 in basic.py from returning False to NotImplemented. The explanation includes references to Python documentation and an article in the sympy docs that explain the proper behavior for rich comparison methods. The problem is clearly defined with a specific code example and a suggested fix. The only uncertainty is how many other places in the codebase would need similar changes, but the main issue and solution are clear enough to make a meaningful attempt at a fix.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13146": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem with code and expected output. However, there might be some ambiguity in how to approach the simplification within the SymPy framework. The user wants to simplify an expression that should be zero but isn't being simplified correctly. While the example is concrete, the exact method or function to use for simplification might require some exploration within the SymPy library.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13173": {
        "explanation": "The issue is reasonably specified. The problem is clear: the degree function for multivariate expressions returns the degree of the first generator arbitrarily, which can lead to inconsistent results. However, the solution is not fully clear. The issue suggests that the generator should be specified explicitly, but it does not provide details on how to modify the function to require the generator or what the default behavior should be if no generator is specified. There are also no examples of the expected output after the fix. Therefore, some interpretation is needed to implement a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13185": {
        "explanation": "The issue is reasonably specified but has some ambiguities. The problem is described with a code example and the unexpected output from the cse() function when working with MatrixSymbol indexing. The example shows how the current behavior produces intermediate variables that seem unnecessary (like full matrix copies). However, it doesn't explicitly state what the expected behavior should be or how it should be fixed. A developer would need to understand what the intended behavior of cse() is with MatrixSymbols and how it should optimize expressions differently. There are enough clues to form a reasonable interpretation of the problem, but some assumptions would need to be made about the desired outcome.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13236": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The description is vague about what exactly is being asked. It mentions that factorial(n) should \"know\" it is divisible by n and k between 1 and n, but it's unclear what specific functionality or behavior is expected. The current examples show that (factorial(n) % n).equals(0) returns False, but it's not clear what changes would make this return True or how the factorial function should be modified to achieve this. The issue also references a fix in #8687 without providing details, making it harder to understand the context. There are too many ambiguities and missing details to create a meaningful solution attempt.",
        "label": "VAGUE"
    },
    "sympy__sympy-13259": {
        "explanation": "The issue is well-specified as it provides a concrete example of a problem with the simplify function in SymPy when dealing with trigonometric functions and complex arguments. It includes the exact code to reproduce the issue, the expected versus actual behavior, and even notes a related but different case where the issue does not occur. This gives enough information to understand the problem and develop a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13264": {
        "explanation": "The issue is reasonably specified. It describes a specific problem with the simplify function in SymPy where a second call to simplify is needed to achieve full simplification. The reporter provides code, example expressions before and after simplification, and even proposes a potential solution with code changes. However, there are some details that would need to be filled in, such as understanding the full context of the codebase, testing the proposed solution thoroughly, and ensuring it works correctly with other cases. The reporter has done significant work to isolate and understand the issue, making it reasonably specified for a solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13265": {
        "explanation": "The issue is well-specified. The problem is clearly described with code examples showing the input and output of various operations. It explains that the simplification functions are not recognizing the expression for sin(1) when it is expressed in terms of exponentials, unlike cos(1) which is correctly recognized. This provides enough information for a software engineer to understand what the expected behavior should be and where the current implementation is failing. The issue is about the simplification not recognizing sin expressed as exponentials, and the examples demonstrate the current and expected outputs, making it clear what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13286": {
        "explanation": "The issue is about the periodicity of the absolute value of the sine function. The problem is that periodicity(Abs(sin(x)),x) returns 2*pi instead of pi. This is a specific problem that can be solved by adjusting how the periodicity function handles absolute values of trigonometric functions. The issue is well-specified because it clearly describes the problem, provides an example, and indicates that the solution should fix this incorrect behavior.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13301": {
        "explanation": "The issue is reasonably specified.  It provides clear examples of the desired output for the `str` and `srepr` functions when applied to an `AccumBounds` object.  The examples show that both functions should return the string `<-1, 1>` for an `AccumBounds` instance with lower bound -1 and upper bound 1.  The issue also specifies that the pretty printer should be responsible for the pretty-printed output, indicating that the `str` and `srepr` functions should return a string that is suitable for recreating the object, not for pretty printing.  This provides a clear direction for implementing the `__str__` and `__repr__` methods (assuming `srepr` is a typo and refers to `__repr__`) of the `AccumBounds` class. However, the issue doesn't specify the exact format of the string for other possible values of the bounds, but the given example provides a clear pattern that can be extended. The issue also assumes some knowledge of the existing codebase, particularly the `AccumBounds` class and the pretty printer.  A developer would need to look at the code for `AccumBounds` to understand how to modify its `__str__` and `__repr__` methods to achieve the desired output.  Additionally, the developer would need to understand how the pretty printer works to ensure it is the only component responsible for pretty-printing.  While these are assumptions, they are reasonable and common in software development.  The core requirement is clear: the `str` and `srepr` functions should return a string that can be used to recreate the `AccumBounds` object, and the pretty printer should handle the pretty-printed output.  The examples provide a clear target for the implementation.  Therefore, the issue is reasonably specified, allowing for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13361": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of incorrect behavior, and the expected behavior is outlined. The cause of the problem is identified (incorrect precision handling), and a suggested fix is provided (changing the order of operations). This provides a clear path for implementing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13364": {
        "explanation": "The issue is reasonably specified. It explains that the __pow__ method needs to be updated to support a third, optional argument for ternary pow() functionality. The example shows the current error when attempting to use three arguments with pow() on SymPy objects. It also references related issues and suggests that this should be done for at least Integer objects, with the note that supporting arbitrary expressions would require additional work from another issue. The error message and the expected behavior (as per the Python documentation) are clearly described, giving enough information to understand what needs to be implemented.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13369": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimal reproducible example, and the expected behavior is explained. The user provides a comparison between two methods (eigenvals and solve) and explains why the current behavior is incorrect. This allows for a focused investigation into why the .eigenvals method is failing to compute eigenvalues for this specific 3x3 symbolic matrix.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13372": {
        "explanation": "The issue is well-specified with a clear description of the problem, including the error message and the steps to reproduce it. It also provides an insight into the possible solution. While there are some blanks to fill in regarding the deeper understanding of why the argument order is causing the issue, the main problem and its reproduction method are clearly defined. Therefore, it's possible to make a meaningful attempt at a solution based on the information provided.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13429": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the specific versions of the software involved (sympy 1.1.1 and Python 3.6.0), and a reproducible code snippet that illustrates the incorrect behavior. The user explains their understanding of why the issue might be occurring (using evalf() with default precision), and even provides test cases showing the inconsistency. The problem statement is clear: comparisons between a specific rational number and pi are not yielding the expected logical results. The desired outcome is also clear: to fix the comparison logic so that it correctly evaluates whether a rational number is less than, equal to, or greater than an irrational number like pi. The issue is reproducible and the problem is well-explained, making it a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13441": {
        "explanation": "The issue is about the 'count_ops' function in SymPy being slow for large expressions. The provided code snippet shows a case where the script was hanging inside 'count_ops'. The problem is described as a performance issue, where the function is taking too long to execute for large inputs. The issue is well-specified because it clearly describes the performance problem with 'count_ops', provides a specific example of the problem occurring (with code and timing information), and indicates that the function is causing the script to hang. The objective is clear: to improve the performance of 'count_ops' for large expressions. However, there are some blanks to fill in, such as what constitutes an acceptable performance improvement and any constraints on the solution. Despite these minor gaps, the core issue and the goal are clearly defined, making it reasonably specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13471": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimum working example that reproduces the error. The error message is provided, and the versions of Python (2.7 and 3.6) and SymPy (commit 3546ac7) are specified. The root cause seems to be related to how floats are handled in pickle when moving from Python 2 to Python 3, particularly in the context of SymPy expressions. This provides enough information for a software engineer to investigate the issue and potentially fix the code in the SymPy library to handle the float-containing expressions correctly during the pickle loading process.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13480": {
        "explanation": "The issue is reasonably specified as it provides a clear example of the error, the specific function and input that triggers it, and a list of values that cause the error. This information is sufficient to understand the problem and start working on a solution. However, there might be some additional details about the expected behavior or the correct way to handle these values that are not explicitly stated, which would require some investigation and understanding of the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13551": {
        "explanation": "The issue is well-specified because it provides a clear example of the incorrect output, the expected correct value for n=2, and a reference to the q-Pochhammer symbol for context. The problem is to fix the Product expression in SymPy so that it evaluates correctly. There is enough information to understand what the bug is and what the correct behavior should be.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13581": {
        "explanation": "The issue is reasonably specified. The main task is to simplify expressions involving the Mod function in SymPy, specifically Mod(Mod(x + 1, 2) + 1, 2) to Mod(x, 2). This is a clear example of the desired simplification. Additionally, the issue mentions that similar patterns should be simplified recursively, such as `Mod(foo*Mod(x + 1, 2) + non_mod_terms + 1, 2)`. While the exact scope and edge cases are not fully specified, a sensible interpretation would involve implementing simplification rules in SymPy's simplification system that can recognize and apply these transformations. The reference to Stack Overflow provides context and motivation for the change, which helps in understanding the problem. However, without more details on how the current simplification system works and what specific functions or methods need to be modified, some assumptions would need to be made.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13615": {
        "explanation": "The issue is reasonably specified. The problem is that the Complement function is not returning the expected output when the input is a mixture of Symbols and numbers. The example shows the current output is {x, y} and the expected output is {x, y} \n[-10,10]. The issue is clear enough to understand what needs to be fixed, but some implementation details may need to be figured out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13647": {
        "explanation": "The issue is well-specified because it provides a clear example of the problem, including the expected and actual behavior. The code snippet shows how to reproduce the issue, and the output highlights the discrepancy. The mention of a specific function (Matrix.col_insert()) and a version number (1.1.1) also provides important context for debugging and fixing the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13678": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with clear examples of failing assertions, which show exactly what functions and conditions are expected to return None for the is_real property. The issue also provides concrete test cases that can be used to verify the correctness of the solution. There is no ambiguity in the requirements as the expected behavior is clearly stated and the current incorrect behavior is demonstrated through the failing assertions.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13682": {
        "explanation": "The issue is about adding support for ordinal arithmetic in SymPy, which is a symbolic mathematics library. The issue provides a detailed description of the desired functionality, including:\n\n1. Creating a new object (OrdinalNumber) or using assumptions\n2. Defining relationships between ordinal properties (natural, limit ordinal, successor ordinal)\n3. Implementing arithmetic operations (addition, multiplication, exponentiation)\n4. Additional methods like relationals, cantor normal form, prime ordinals, etc.\n5. Reference to an existing Python implementation of non-symbolic ordinal arithmetic\n\nWhile the issue provides a clear vision of what needs to be implemented, there are some areas that would require further clarification:\n\n1. How exactly to integrate this with SymPy's existing architecture (should OrdinalNumber inherit from Symbol or Basic?)\n2. The exact implementation details of the arithmetic operations and special methods\n3. How to handle the interaction with existing SymPy features and other mathematical objects\n\nHowever, these are implementation details that a experienced software engineer working with SymPy could reasonably figure out through studying the codebase and existing implementations. The overall requirements are clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13744": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem is described as a doctest failure with a stack overflow error in the coset_table.py file of the sympy library. However, the issue description doesn't provide the actual test code that's failing, the inputs that cause the failure, or a clear explanation of what the expected vs actual behavior is. The stack trace shows a recursive loop in the eliminate_word method of the free_groups.py file, but without knowing what input causes this recursion, it's difficult to reproduce the issue and determine the correct fix. Additionally, there's no information about when this started happening, what changes might have caused it, or what the expected behavior should be. The issue would need more context and specific information about the failing test to be solvable.",
        "label": "VAGUE"
    },
    "sympy__sympy-13757": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with examples of expected vs actual behavior when multiplying an expression by a Poly object in different orders. The user has provided specific test cases (some working as expected, others not) that demonstrate the issue. This provides enough information for an experienced developer to understand what needs to be fixed in the multiplication operator implementation for the Poly class. However, some details about the overall architecture of the codebase and how the multiplication operators are currently implemented would need to be discovered through code exploration.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13761": {
        "explanation": "The issue is about a KeyError being raised when trying to simplify an expression involving the sinc function in SymPy. The user provides a clear example of the problem, including the code that causes the error, the error message, and the traceback location. The problem is described as a KeyError: sinc in the simplification process. The user also notes that they do not expect any actual simplification to occur but rather that the simplification function should not crash. This is reasonably specified because the problem is clearly defined (a KeyError when processing sinc), and the expected outcome is clear (no crash, even if no simplification occurs). There is no major ambiguity about what needs to be fixed - the KeyError when handling the sinc function during simplification.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13773": {
        "explanation": "The issue is well-specified. The problem is described as the `@` operator currently copying `__mul__` behavior, but should only work for matrix multiplication. The issue provides an example of how it should behave, with a Python doctest showing the expected output of a correct implementation. The problem is well-defined: the `@` operator should fail when one argument is not a matrix. The NumPy example also clearly shows the expected behavior. The solution would involve modifying the `__matmul__` method in the Matrix class to check that both operands are matrices and raise an appropriate error otherwise. There is no ambiguity in what is being asked.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13798": {
        "explanation": "The issue is reasonably specified. It clearly explains the current limitation of the `latex()` function's `mul_symbol` parameter and provides a specific use case (thin space) along with code examples showing the desired output and current behavior. The user is asking if they can contribute a PR to make `mul_symbol` more flexible. While there are some implementation details to figure out, the goal is clear enough to make a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13806": {
        "explanation": "The issue is asking to add support for the LaTeX expression \\\\[{90^^\\circ }\\], which represents an angle of 90 degrees. The reporter wants this expression to be recognized, likely in a math parsing or typesetting context. However, the issue lacks details about the specific system, library, or tool where this should be implemented. It does not clarify how the expression should be processed or what the expected output should be (e.g., rendering as a degree symbol, evaluating trigonometric functions, etc.). The request is reasonable but lacks sufficient context for a developer to implement a solution without making assumptions. Therefore, it is reasonably specified but with some blanks to fill in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13840": {
        "explanation": "The issue is vague and lacks clear information about the problem. It mentions that Max & Min cannot be converted in languages like JavaScript and R, but it does not provide any specific details about what conversion is being referred to, what the expected behavior should be, or any code examples that demonstrate the issue. The image link also appears to be broken or not accessible, making it difficult to understand the context of the problem. There is no clear task or set of requirements for a solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-13852": {
        "explanation": "The issue is about adding an evaluation for the polylog function in SymPy and addressing an issue with the expansion of the polylog function involving exp_polar. The issue includes specific examples of expected results, such as the expansion of polylog(2, 1/2) to a specific expression involving log and pi. It also details why the current expansion of polylog(1, z) includes exp_polar(-I*pi), and argues that this is not meaningful and should be changed. The issue provides concrete examples of the problem, expected outcomes, and reasoning for the change. The issue is well-specified with clear goals and examples, making it possible to understand what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13877": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a reproducible example, expected vs actual behavior, and even a possible cause is suggested. A developer can understand that the determinant function in SymPy is raising an error when computing the determinant of a 6x6 matrix with symbolic entries. The traceback provides the exact location of the error, and the user even questions if the Bareiss algorithm (which is used in the traceback) is appropriate for symbolic matrices. This gives a clear direction for debugging and fixing the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13878": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly defined: precompute the CDF for several distributions where integration is problematic. The issue provides a list of distributions with specific examples and test cases, showing what the current behavior is and what the expected behavior should be. The approach to solving the issue is outlined: implementing internal _cdf methods for these distributions, and there's even a suggestion on how to test the correctness of these implementations (differentiating the CDF to compare with the PDF). The issue also references where to find the formulas for the CDFs (Wikipedia). All necessary information for implementing a solution is provided, making it a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13895": {
        "explanation": "The issue is reporting a specific problem with the SymPy library where an expression simplifies to an inequivalent form. The issue includes a clear example with code that reproduces the problem, showing the input expression, the simplified form, and the discrepancy when substituting a specific value. The example also shows that the numerical evaluation of the original and simplified expressions differ, which clearly demonstrates the issue. This is sufficient for a developer to understand what the problem is and to attempt a solution. However, there are some blanks to fill in, such as the exact expected behavior and how to fix the simplification logic in SymPy to avoid this issue. But these are reasonable assumptions that a developer with knowledge of SymPy could make.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13915": {
        "explanation": "The issue is well-specified. The problem is described with a clear example and the expected behavior is explained. The current behavior is that when b is substituted by a in the expression r, it returns 1, but the user argues that it should be undefined because substituting b with a makes some subexpressions undefined (like 1/(a-b)). The issue also provides the code to reproduce the problem and the version of sympy being used. All the necessary information to understand and potentially fix the issue is present.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13962": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The issue explains that the current implementation prints the full name of quantities (e.g., 'meter') instead of the abbreviation (e.g., 'm'). It provides code examples of the current behavior and the desired behavior. The issue also identifies the specific location in the codebase where the change should be made (sympy/printing/str.py#L713) and mentions the need to modify an existing test that expects the non-abbreviated name. The goal is clear: modify the printing functionality to use the abbreviation if one was provided, with the example showing that 'meter' should be printed as 'm'. The issue even references the specific GitHub issue it is fixing (#13269). All these details make it a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13971": {
        "explanation": "The issue is reasonably specified. The problem is clear: the current Jupyter rendering of the sequence formula is backslash-escaping the brackets, which causes problems when copying the output to a markdown cell. The expected solution is also clear: the sequence output should either not backslash-escape the square brackets or use a different rendering to fix the issue. There might be implementation details to figure out, but the problem and the desired outcome are well-defined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-13974": {
        "explanation": "The issue is well-specified with a clear example of the problem and expected outcome. The user demonstrates the current behavior versus the expected behavior with concrete examples. The expected results are shown in the session with [5] and [9], providing a clear target for the solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-13978": {
        "explanation": "The issue is reasonably specified. It indicates that the current code generation for imaginary numbers in SymPy is causing errors in Octave 4.0, and suggests a potential fix by substituting 'sqrt(3)i' with 'sqrt(3)*i'. While there are some implementation details that would need to be worked out, the problem and proposed solution are clear enough to make a meaningful attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14024": {
        "explanation": "The issue is reporting an inconsistency when simplifying the expression (-a)**x * a**(-x) with a being a positive integer. It provides two code examples that show different results when substituting a specific value for x and evaluating the numerical result. The first example uses a symbolic variable 'a' with assumptions, and the second example uses a concrete value for a (a=2). The results for N(n1) differ between the two examples, which is the inconsistency being reported. The issue is well-specified because it clearly shows the problem with code examples and expected behavior (consistency in results). A developer can understand what the problem is and what needs to be fixed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14031": {
        "explanation": "The issue is reasonably specified. The problem is described with a code example that reproduces the error, and the error message is included. The reference to a similar issue (#13970) gives context but does not fully specify the solution. There are some blanks to fill in about the exact requirements for fixing the coercion issue, but the example and error message provide a sensible interpretation of what is needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14038": {
        "explanation": "The issue is reasonably well-specified as it provides a clear example of the current incorrect behavior and mentions what the correct result should be (sinc(a)). However, there may be some blanks to fill in regarding the exact implementation details needed to achieve the correct evaluation of the product. The expected behavior is clear, but the specific approach to modify the product evaluation in SymPy to handle this case may require additional interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14070": {
        "explanation": "The issue is well-specified. The problem is described as the logcombine function not working as expected for the input log(3) - log(2), where it should return log(3/2). The issue also mentions it used to work in version 0.6.7, which helps in understanding the expected behavior. The issue is clear enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14082": {
        "explanation": "The issue is well-specified. It clearly states the problem with an example and shows the expected result. The code snippet demonstrates how to reproduce the issue and what the current incorrect output is. The user also mentions a similar issue (#8246) which provides additional context. All necessary information is provided to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14085": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of the error being encountered, and there is an explanation of what the expected behavior should be. The issue is that 'sympify(u\"\\u03b1\")' is not working, but it should be able to parse Greek letters since they are used in pretty printing. The error trace shows that the parsing is failing, and the expected outcome is that it should work like the example with 'Symbol('alpha')' which correctly displays as \u03b1. This provides enough information to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14180": {
        "explanation": "The issue is reasonably specified. The problem is clear: the current code converts 'ln(10)' to 'log{\\left(10\\right)}', but it should be converted to '\\ln(10)' instead. However, there may be some ambiguity in how the conversion is implemented in the codebase and where the relevant code is located. The issue does not specify which part of the codebase needs to be modified, nor does it provide any context about the existing implementation. Despite these gaps, the desired outcome is clear, and a reasonable solution can be inferred.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14207": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example, the expected output, and the actual output. It also mentions the context (code-generation) and the consequence of the issue (promotion to double precision). This provides all the necessary information to understand the problem and how to solve it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14248": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described: when subtracting MatrixSymbols in SymPy, the output is displayed as a sum with a (-1) coefficient instead of the expected difference format (e.g., A - B instead of (-1)*B + ...). The issue provides a reproducible example with the outputs for str, pretty, and latex printers, showing the discrepancy between the expected and actual behavior. It also references a Stack Overflow post for further context. The goal is to fix the printing behavior of MatrixSymbol differences in SymPy so that they display as expected (e.g., A - B instead of (-1)*B). This is a concrete and specific issue that can be addressed through code changes in the relevant printing functions or the MatrixSymbol class.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14308": {
        "explanation": "The issue is reasonably specified. The problem is about the pretty printing of vector expressions in SymPy. The issue provides a clear example of the current output and describes that the output is incorrect. It also mentions an additional issue with the baseline alignment. While there might be some details about the expected correct output that are not explicitly provided, the general problem is clear and can be interpreted by someone familiar with SymPy's pretty printing functionality.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14317": {
        "explanation": "The issue is well-specified because it provides a clear problem statement, a code example, and the expected behavior. It explains that the LaTeX printer does not order the monomials in the same way as the str and pretty printers, which is to go from highest to lowest degree. The example shows that the LaTeX output has an incorrect order of the monomials. This gives a clear task: to modify the LaTeX printer to order the monomials by degree, like the other printers do. There is no ambiguity about what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14333": {
        "explanation": "The issue is about the current behavior of the `mod_inverse` function in SymPy, which assigns the same sign as `a` to the result. It describes how different programming languages handle modulo operations and provides examples from Wolfram Alpha. The issue also shows that SymPy does not find modular inverses for negative modulo due to the `m>1` check. The examples provided from Wolfram Alpha further clarify the expected behavior. There are clear examples and references to how different systems handle this, and the problem is well-defined. The issue also provides specific examples of the current behavior in SymPy and the expected behavior, which makes it possible to understand what changes are needed. The issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14396": {
        "explanation": "The issue is reasonably specified. It clearly states that using 'RR[y,z]' as a domain in the Poly function results in an error. It also provides a code example showing the error and an expected working case. However, there's a need to understand the correct domain specification format for the Poly function in SymPy to resolve the issue, which is not explicitly provided in the description. Despite this, a developer with knowledge of the SymPy library can infer the necessary action. Additionally, the issue suggests improving the error message wording, which is a clear task but requires understanding of the current implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14531": {
        "explanation": "The issue is reasonably specified. It provides examples of incorrect behavior when using the sstr function with the sympy_integers=True setting. It shows that the setting is not being respected by certain subexpressions (like Eq and Limit). The examples show what the current output is and what the expected output should be. This gives enough information for a developer to understand what needs to be fixed. However, there are some blanks that would need to be filled in, such as exactly how the sympy_integers setting should be passed through to all subexpressions and how the code generation should work in all cases. The mention of a fix being forthcoming also suggests that the reporter has a solution in mind but hasn't provided the implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14564": {
        "explanation": "The issue is discussing the ambiguous behavior of the ConditionSet class in the sympy library. It provides several examples that demonstrate unexpected behavior and proposes questions about what the correct behavior should be. The issue is not a request for a feature or a clear bug report, but rather a discussion about the correct interpretation of the ConditionSet's behavior.\n\nThe issue asks questions like: What should ConditionSet(x,x>5,Interval(1,3)) evaluate to? Should an error be raised if the condition is not a function of the given variable? Should there be a doit method or autoevaluation? These are all questions about the desired behavior, not clear instructions for implementing a solution.\n\nThe examples provided show what the current behavior is, and what the expected behavior might be in some cases. However, the issue does not clearly state what the correct behavior should be in all these cases. It's not clear whether the ConditionSet should evaluate to the base set when the condition is always true, to the empty set when it's always false, or to some other value.\n\nThe issue also mentions some \"other fixes\" but doesn't clearly specify what the correct behavior should be in those cases either. For example, it says that ConditionSet(x,x>5,Interval(1,7)).subs(x, 8) should be S.EmptySet, but doesn't explain why that should be the case or how to implement it.\n\nOverall, the issue raises important questions about the behavior of ConditionSet, but it's not well-specified enough to provide clear guidance on what changes should be made to the code. A well-specified issue would clearly state what the desired behavior is in all the example cases and provide a clear path for implementing those changes.",
        "label": "VAGUE"
    },
    "sympy__sympy-14627": {
        "explanation": "The issue is reasonably specified.  It is clear that the goal is to have `binomial(n, n)` simplify to 1.  The example demonstrates the current behavior and shows that `simplify` is required to achieve the desired result.  The code reference and question to @sidhantnagpal provide context, but they don't affect the core problem statement.  The solution would likely involve modifying the simplification logic for the binomial function to handle the case where both arguments are equal.  There are some details to consider, such as how to handle edge cases and whether to apply the simplification automatically or only when `simplify` is explicitly called.  However, the core issue is clear enough to begin working on a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14699": {
        "explanation": "The issue is reasonably specified. It clearly states the problem (orientnew method doesn't support indices), provides an example of how indices are currently set using the ReferenceFrame constructor, and shows the desired usage pattern with orientnew. The issue also mentions that a global setting would be nice if all indices in a section will use the same style. This gives enough information to understand what the enhancement should accomplish - adding support for specifying indices when creating a new frame with orientnew. There are a few implementation details that would need to be worked out (how to integrate this with the existing method signature, whether to allow overriding global settings, etc.), but the core requirement is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14711": {
        "explanation": "The issue is reasonably specified. It shows a specific error when trying to add a vector and a zero scalar multiplication, and provides the traceback. A developer can understand what the problem is and how to reproduce it. However, there are some blanks to fill in about the exact requirements for a solution - what behavior should be implemented to fix the error and handle the 0 * N.x case.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14774": {
        "explanation": "The issue is well-specified because it provides a clear problem description, a specific example of the current behavior versus the expected behavior, and even a proposed fix with the exact line of code that needs to be modified. The reporter has identified the source of the problem in the `inv_trig_table` list in the `latex.py` file and has provided the necessary context for understanding why this change is needed. A developer can directly apply the suggested fix and test it to see if it resolves the issue with minimal guesswork.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-14817": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem is described as an error in pretty printing a MatAdd (matrix addition) involving MatrixSymbols. The error trace indicates a SympifyError when trying to parse 'y*', which suggests there is an issue with the syntax of the MatrixSymbol name 'y*'. The core problem appears to be that the code is attempting to use sympify on string arguments from MatrixSymbol, which is causing a syntax error due to the '*' character. However, the issue description is somewhat vague about what the actual desired behavior is and how to fix the underlying problem. The description also includes a critique of the code's logic for handling negative arguments in MatAdd, but it is unclear what specific changes or improvements are expected. Without more detailed information on the expected behavior, the correct approach to fix the SympifyError, and the desired handling of negative arguments, it is difficult to determine a clear path forward for a solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-14821": {
        "explanation": "The issue is reasonably specified. The problem is described as a bug where the code generation for the zeta function with two arguments is incorrect in Octave/Matlab. It provides the expected output format `zeta(n, x)`, and a reference to the Matlab documentation. This gives enough information to understand what the correct behavior should be and where the function is being used. However, some details about the current implementation and the specific context in which this is happening may be missing, but these can be inferred or investigated.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-14976": {
        "explanation": "The issue is about the lambdify function in the 'mpmath' module not properly handling rational numbers, which leads to reduced precision in calculations. The problem is described with a concrete example that shows the issue and also includes a test case that demonstrates the reduced precision problem. The expected behavior is implied by the fact that '232/3' is not being evaluated at full precision. While it's not explicitly stated what the desired behavior should be, a reasonable interpretation is that the rational number should be handled in a way that maintains full precision, likely by converting it to a high-precision floating point number before performing the calculation. This gives enough information to make an attempt at a solution, even if some interpretation is needed.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15011": {
        "explanation": "The issue is well-specified with a clear description of the problem, a minimal reproducible example, and an explanation of the expected versus actual behavior. The user demonstrates that `lambdify` works with individual components (curly braces in a symbol name and MatrixSymbol separately) but fails when both are combined, even when using `dummify=True`. The code examples clearly show the working and non-working cases, and the expected outcome is implied (that `lambdify` should work with both curly braces and MatrixSymbols together when dummify is enabled). This provides enough information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15017": {
        "explanation": "The issue is well-specified because it clearly describes the problem (the `__len__` method for rank-0 arrays in `NDimArray` returns 0 instead of 1), provides a concrete example of the incorrect behavior, and explains what the correct behavior should be (returning 1, as seen in NumPy). The issue also includes test cases showing the discrepancy between SymPy and NumPy, and the version information is provided. All of these details make it possible to understand the problem and create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15085": {
        "explanation": "The issue is well-specified enough to understand the problem. It provides a minimal working example (MWE) that reproduces the error, describes the error message, and indicates that this is a regression (i.e., the issue appeared in a newer version of the library). The task is to fix the error that occurs when using `lambdify` with a `Matrix` in a custom function. The MWE and error message give sufficient information to understand what is wrong and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15198": {
        "explanation": "The issue is somewhat vague because it references a specific commit and a codegen regression, but lacks detailed steps to reproduce the problem, expected vs actual behavior, and context about the code changes. While there's a general direction (fixing a codegen regression in specific languages), the specifics are unclear and need more information for a meaningful solution attempt.",
        "label": "VAGUE"
    },
    "sympy__sympy-15222": {
        "explanation": "The issue is reasonably specified. The user is pointing out a problem with the `subs` method in the `Subs` class where replacing a symbol in the substitution values does not work as expected. The example demonstrates that when a substitution value is the same as a symbol (e.g., `a`), calling `subs(a, z)` on the result does not change the substitution value from `a` to `z`. The expected outcome is for the substitution value to be updated to `z`. While there is some context missing about the exact behavior that should be implemented and the surrounding code, the core issue is clear enough to attempt a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15225": {
        "explanation": "The issue is well-specified. The user has provided a clear example with code that demonstrates the problem, and the expected versus actual behavior is clearly stated. The problem is about a function in the SymPy library, 'bool_map', where the output is not as expected when comparing an Xor and its negation. The user points out the discrepancy in the results and shows that the simplified functions are different, yet the 'bool_map' function returns what it considers a valid symbol mapping. The issue is reproducible with the provided code and the expected outcome is clearly communicated. Therefore, it is clear what the problem is and what needs to be investigated and fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15231": {
        "explanation": "The issue is well-specified because it includes a minimal example that reproduces the problem, the error message, and the generated code that is causing the error. The problem is clearly described as the 'Mod' function being imported twice in the generated Fortran code. The user even suggests that it might be an easy fix but doesn't know where to start, indicating that the problem is understood but the solution path is not. This information is sufficient for a software engineer to identify the problem and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15241": {
        "explanation": "The issue is reasonably specified. The problem is about improving the canonicalization of variables in the Derivative class, specifically the _sort_variable_count method. The example given shows that Derivative(f(x, y), x, f(y), x) should equal Derivative(f(x, y), x, x, f(y)).\n\nThe main task is to adjust the sorting logic so that symbols not in the free symbols of the function appear before the functions when symbols appear after functions. However, there are some blanks to fill in, such as the exact implementation details of the _sort_variable_count method, how the free symbols of the function are determined, and how the sorting should be implemented to achieve the desired behavior. But there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15286": {
        "explanation": "The issue is about recognizing elliptical integrals and improving the calculation of the circumference of an ellipse in SymPy. The provided code includes a function for calculating the circumference with high precision and some additional methods for the geometry module. However, the issue description is more of a patch or pull request rather than a clear problem statement. The actual problem to solve (i.e., how to recognize elliptical integrals in SymPy) is not well-explained, and the requirements for a successful solution are not clearly defined. The issue also references multiple other issues and PRs without clearly stating the main problem to solve. Therefore, the issue is vague and there is room for ambiguity about what a successful solution would look like.",
        "label": "VAGUE"
    },
    "sympy__sympy-15308": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with an example and the expected outcome. However, some details about the implementation might be missing. For example, it is not clear which part of the codebase needs to be modified to handle the fallback to the LaTeX printer for the inner expression. But there is a sensible interpretation of what is required to solve the issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15320": {
        "explanation": "The issue is describing a specific behavior of the RootOf function in a symbolic mathematics library (likely SymPy, given the context). It provides concrete examples of the problem, showing that when RootOf is given an expression with a new generator (like tan(x)), it sometimes retains the original generator (x) instead of the new one. The issue is well-documented with code examples and shows the unexpected behavior clearly. It also references a related issue (#8551) for context. The problem is well-defined, and it's clear what the current behavior is and what the expected behavior might be (retaining the correct generator). The examples show that the RootOf function is not respecting the generator substitution in certain cases, which is a clear and specific issue to address in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15345": {
        "explanation": "The issue is well-specified. The user provided a minimal, reproducible example of the problem, described the expected output and the actual output, and explained why the actual output is incorrect. All necessary information to understand and fix the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15346": {
        "explanation": "The issue is reporting that the simplification of trigonometric expressions involving Rational numbers is not working as expected. The user shows that when trigonometric expressions involve symbols, the simplify() function correctly recognizes and simplifies the expression (e.g., cos(x - y) from cos(x)*cos(y) + sin(x)*sin(y)). However, when using Rational numbers instead of symbols, the same simplification is not being applied. The user provides clear code examples showing this discrepancy, and the expected behavior is implied by the first example where simplification works with symbols. This is a clear and specific problem report with reproducible examples and a description of the observed vs expected behavior. The issue is well-specified enough for a meaningful attempt at a solution because it clearly identifies what is working and what is not, what the expected behavior should be, and provides all the necessary code to reproduce the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15349": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The user provides a clear example of the problem, including the expected incorrect output and the expected correct output (implied by the statement that one of the sin(x) functions should be negative). The issue is about the `to_rotation_matrix()` method in the `Quaternion` class producing an incorrect sign in the rotation matrix. The reference to the original equations is a request for clarification but doesn't prevent understanding the core issue, which is the sign error in the rotation matrix output. The user also provides the version of sympy being used and a minimal example to reproduce the problem. All these elements make the issue well-specified and actionable for a software engineer attempting to resolve it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15446": {
        "explanation": "The issue is well-specified because it clearly describes the problem (incorrect LaTeX printing of matrix products with negative signs), provides a reproducible example, and explains the expected outcome (correct use of parentheses). The example code demonstrates the issue and would allow a developer to reproduce and address the problem in the LaTeX printer module.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15523": {
        "explanation": "The issue is reasonably specified as it provides test failures under Python 3.7.1, including specific test files and error messages. The problem seems to be related to function argument handling in different Python versions. While the exact cause and solution may require further investigation, the provided error messages and context give a clear path for a developer to start debugging and fixing the issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15555": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is that the 'primepi' function in the SymPy library is not handling symbolic arguments properly. The issue provides a clear error message and code snippet that demonstrates the problem. The solution would involve modifying the 'primepi' function to handle symbolic arguments correctly, which would likely involve adding a check for symbolic arguments and handling them appropriately. The issue is specific, with a clear input (primepi(x)), a clear error (TypeError), and a clear expected outcome (the function should work with symbolic arguments).",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15586": {
        "explanation": "The issue is reasonably specified as it provides the code that is causing the problem, the error message, and a reference to a Stack Overflow discussion. The problem is clear: the user is trying to invert a float matrix using sympy and numpy and is encountering an error. However, the exact solution might require some investigation into the sympy and numpy libraries.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15596": {
        "explanation": "The issue is reasonably specified. The user is pointing out that the degree function in SymPy is returning 1 for the rational function (x-2)/(x**2+1), and is questioning if the behavior is correct or if it should instead fail. The user is suggesting that if the degree of a rational function is not implemented, the function should fail rather than return an unexpected result. This is a valid point for consideration, but there may be some blanks to fill in about the exact expected behavior and the implementation details. However, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15599": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is to fix the simplification of Mod(3*i, 2) to reduce to Mod(i, 2) for integer i. The code changes in mod.py and test_arit.py are provided to implement this fix, including a test to verify the behavior. The expected behavior before and after the fix are clearly described. The release notes also mention the fix and test addition. All the necessary information is provided to implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15625": {
        "explanation": "The issue is well-specified. The problem is clearly described with steps to reproduce, error messages, and an explanation of the root cause. It also provides a proposed solution (changing LaTeX wrapping from $$...$$ to $\\displaystyle ...$) and references to related issues/PRs. All necessary information is provided to understand the problem and implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15635": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly outlines the requirements for the `str` and `srepr` printers, providing specific examples of the current incorrect output and the desired correct output. The notes explain the expected behavior for valid Python recreation and exact recreation with specific imports. The three issues listed with their current and desired outputs give a clear direction for the necessary fixes. The mention of other potential issues is acknowledged but does not prevent starting with the specified problems.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15678": {
        "explanation": "The issue is reasonably specified. The problem is clear: the idiff function has two issues - it doesn't support Eq (equality) and doesn't support expressions with f(x) instead of y. The issue provides concrete examples of how these issues manifest with error messages, and one working example for comparison. This provides enough context to understand what needs to be fixed and to test the solution. However, it does require some interpretation of what the exact implementation changes would be, as it doesn't provide a complete specification of the desired behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15685": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, including the expected behavior, actual behavior, and a reproducible example. The proposed solution is to make the .scale_factor property private in the units module to hide the kilogram workaround from the user. The reasoning is also provided, explaining why the scale_factor should be made private. This provides all the necessary information to implement the proposed solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15809": {
        "explanation": "The issue is reasonably well-specified, but there are some blanks to fill in. The main request is to change the behavior of the Min() and Max() functions so that when they are called with no arguments, they return 'oo' (positive infinity) and '-oo' (negative infinity), respectively, instead of raising a ValueError. This is motivated by mathematical convenience, and a Wikipedia link is provided for justification.\n\nHowever, there are some considerations that need to be made when implementing this change:\n1. How are 'oo' and '-oo' represented in the codebase? Are they using a specific library (like math or numpy) or a custom implementation?\n2. What is the expected behavior when Min() or Max() are called with non-numeric arguments or mixed types? This isn't directly relevant to the issue but could be impacted by the change.\n3. What about existing code that relies on the current behavior of raising an error for zero arguments? This change could potentially break existing code that expects this error.\n4. How should this change be tested? What test cases should be added or modified to ensure the new behavior works as expected and doesn't introduce regressions?\n\nDespite these considerations, the core of the issue is clear: change the zero-argument behavior of Min() and Max() to return infinity values instead of raising an error. A developer can reasonably interpret this and implement a solution, even if they need to make some decisions about implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15875": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is described with a clear example showing the incorrect behavior of the `is_zero` method on a complex expression. The expected behavior is also specified: `is_zero` should return `None` if it cannot decide, but should never give the wrong answer. The example shows that `e.is_zero` incorrectly returns `False` when it should eventually evaluate to `True` after simplification. The issue also mentions that this problem is causing errors in determining the rank of a matrix, which gives context for its importance. The fix is expected to address the issue with `is_zero` for complex numbers while `Add` operations are involved. The reference to issue #15872 and PR #15873 also provides additional context for the problem and potential solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15948": {
        "explanation": "The issue is about a problem with the 'subs' function in SymPy when used with matrix expressions. The reporter provides a detailed description of the issue, including debug code and outputs that demonstrate the problem. They also show how the issue is resolved by modifying the 'Mul.flatten' function to return the correct return type for matrices. This includes examples of the expected behavior and what was fixed. The information provided is sufficient to understand the problem and the solution, making it clear what needs to be done to resolve the issue. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15970": {
        "explanation": "The issue is reasonably specified. The task is to replace the use of '\\quad' with '\\ ' in the LaTeX representation of lists, tuples, and dictionaries. The reference to the Twitter discussion provides context, but the actual task is clear: find where '\\quad' is used for these data structures in the LaTeX output and replace it with '\\ '. The implementation would involve locating the relevant code responsible for generating LaTeX for these structures and making the substitution. There may be some exploration needed to identify exactly which parts of the codebase need to be modified, but the overall goal is clear and actionable.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-15971": {
        "explanation": "The issue description is actually a pull request template or a draft for a pull request, not an issue. It mentions adding pretty printing functionality for the lerchphi function, which is a specific task. It also references fixing part of issue #6013. This provides a clear direction on what needs to be done: implement pretty printing for the lerchphi function in the pretty.py file. The description is specific and provides enough context to understand the required change. Therefore, it is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-15976": {
        "explanation": "The issue is well-specified. The problem is clearly described: symbols ending with a number are made invisible when printed with MathML. A minimal, reproducible example is provided along with screenshots showing the incorrect and correct outputs. The relevant environment details (Safari version, OS, Sympy version, etc.) are also included. All necessary information to understand the issue and reproduce it is present.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16003": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with examples of the current incorrect output and the desired output. The specific task (improving the _print_Derivative method) is mentioned, along with some requirements (printing variables on a single line, correct powers in numerator). There are some areas that require interpretation (like when to put the function on a separate line) but overall the task is clear enough to begin a solution. The mention of grouping adjacent identical terms with a reference to another issue provides additional guidance.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16056": {
        "explanation": "The issue is reasonably specified. The problem is clear: there are two LaTeX commands being used for printing text, and the goal is to standardize on one and make it configurable. There are some decisions to make (which one to standardize on) and implementation details (how to make it configurable), but the overall direction is clear. The issue provides pros and cons for each option and suggests a potential solution (a helper function).",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16088": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with examples showing the current behavior and the desired behavior. The fix involves modifying the simplify function to pull out independent factors from integrals, similar to how it works for sums. The code examples show the expected output after the fix. This provides enough information to implement a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16221": {
        "explanation": "The issue is reasonably specified. It indicates that the current printers for Wolfram Mathematica do not support matrices and arrays and that support should be added. However, there are some blanks to fill in, such as how matrices and arrays should be formatted in the output, what specific types of matrices and arrays need to be handled, and any constraints or requirements for the implementation. Despite these gaps, it is a sensible interpretation that the goal is to extend the printers to handle matrices and arrays in a way that is consistent with Mathematica's syntax and conventions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16281": {
        "explanation": "The issue is reasonably specified as it provides examples of the current output and suggests areas for improvement. However, there are some subjective elements like the appearance of the product symbol and the decision to extend the top bar, which require interpretation. Despite these, the overall goal is clear enough to allow for a meaningful solution attempt.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16331": {
        "explanation": "The issue is about a bug when using the 'ufuncify' function with two arguments and the Cython backend. The error message indicates that there's a variable '_y' that is redeclared in the generated Cython code, which leads to a compilation error. The issue is well specified because it provides a clear example of the failing code, the error trace, and information about when it works (with one argument or different backend). This allows a developer to reproduce the issue and understand what the expected behavior should be. The problem seems to be related to how the Cython backend handles multiple arguments in the 'ufuncify' function, specifically with variable naming conflicts. The error message even points to the line where the redeclaration happens. Therefore, the issue is well specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16334": {
        "explanation": "The issue is not well-specified because it lacks crucial context and explanation about what the expected behavior is. The problem is described in mathematical terms that may not be fully clear without understanding the specific implementation details of sympy's ask system and how it handles symbolic expressions.",
        "label": "VAGUE"
    },
    "sympy__sympy-16437": {
        "explanation": "The issue is reporting a specific problem with the Float function in a codebase, where underscores in the string representation of a float are causing incorrect placement of the decimal point. The reporter provides clear examples of correct and incorrect behavior, and even points to an upstream bug in mpmath that might be the cause. The examples are very helpful in understanding what the expected behavior should be versus what is actually happening. The reporter is clearly stating that when underscores are used in the fractional part of the number, the decimal point is being misplaced in a predictable way (losing a digit each time an underscore is added). This is sufficient information to understand the problem and start working on a solution, which would likely involve modifying how the Float function handles underscores in the string representation, or potentially working around the mpmath bug if that's the root cause. The only potential ambiguity is whether the solution should be a fix in the current codebase or a fix in the mpmath library, but the reporter is already aware of the upstream issue, so it's clear that the solution might involve either waiting for an mpmath fix or implementing a workaround in the current codebase. Overall, the issue is well-documented with examples and context, making it well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16449": {
        "explanation": "The issue is reasonably specified. The task is to add a function to compute the CDF of the Maxwell distribution, and a reference is provided for the implementation. However, there might be some ambiguity in terms of the exact requirements for the function's parameters, error handling, or integration into the existing codebase. The general task is clear, but there are some details that need to be inferred or decided during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16450": {
        "explanation": "The issue is well-specified as it provides a clear example of the problem, including input and output. It also explains the expected behavior and potential areas for further improvement. The code snippet shows the current behavior versus what is expected, making it possible to identify the necessary changes in the 'posify' function.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16474": {
        "explanation": "The issue is reasonably specified.  It clearly outlines the need for LaTeX, MathML, and pretty printers for the HadamardPower class.  The mention of extending HadamardProduct to support the division symbol provides additional context for the implementation, suggesting the printers should handle similar operations. However, the issue lacks specific details on the desired format for the printers, the current code structure for these printers, and how the division symbol extension should be integrated.  A developer would need to make some assumptions about the implementation details and the expected output format.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16503": {
        "explanation": "The issue is reasonably specified. The problem is described with an example of the current output and a description of what should be fixed. However, there are some blanks to fill in, such as exactly what the desired alignment should be (whether 'x' should be lower or '+ 3' should be higher) and how to implement this in the code. Despite these gaps, a sensible interpretation can be made to address the misalignment in the pretty print output of the Sum expression.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16527": {
        "explanation": "The issue is reasonably specified. The problem is that the collect_const() function in SymPy 1.3 is not collecting rational numbers as expected. The user provided a concrete example of input and expected output, which makes the issue clear. However, there might be some assumptions about how the function should behave that are not fully detailed, such as how to handle more complex rational expressions or other edge cases. These could be inferred from the provided example and the general behavior of similar functions.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16597": {
        "explanation": "The issue is reasonably specified. The user is pointing out that in the code, the property `is_even` does not imply `is_finite`. They provided an example where `m` is declared as an even symbol, but `m.is_finite` returns `None` instead of being `False`. The user's expectation is that for a number to be even, it should also be finite. While it's clear what the problem is, the solution may require understanding the system's logic for handling these properties, which is not fully detailed in the issue. The ambiguity lies in how the system should enforce that being even implies being finite, and how to handle symbols or objects that are not fully defined. However, the core issue is clear enough to form a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16601": {
        "explanation": "The issue is well-specified. The problem is described with a clear example that demonstrates the error when trying to determine the vertex of a parabola declared symbolically in SymPy. The example includes the exact code that reproduces the issue, the expected behavior (determining the vertex), and the actual behavior (a TypeError). The error traceback is also provided, which shows that the issue is related to evaluating a relational expression with symbolic variables. A solution would need to handle symbolic expressions appropriately to avoid evaluating the truth value of a relational expression. This information is sufficient for an experienced developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16632": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, with a minimal working example provided that demonstrates the discrepancy in how two similar expressions are parsed and evaluated. The user wants to understand why the expressions 6**n and 3**n*2**n are not being recognized as equal by sympy, and how to get a result of 0 when subtracting them. The problem involves understanding how SymPy parses expressions with implicit multiplication and exponentiation, and the user has already tried several approaches to simplify the expression without success. The solution would likely involve a deeper understanding of SymPy's parsing and simplification behavior, and possibly a way to force the expressions to be recognized as equivalent.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16637": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example that shows the current behavior versus the expected behavior. The code example demonstrates the issue with a test case that shows the incorrect point being returned. The issue also includes a workaround and references a previous fix that might be related. All of this provides sufficient information to understand the problem and work on a solution within the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16766": {
        "explanation": "The issue is well-specified. The problem is clearly described: the PythonCodePrinter does not support the Indexed class. The user provides a code example to reproduce the issue, shows the current output with the warning, and suggests a solution by adding a method to handle Indexed objects. The expected behavior is clearly defined - to generate valid Python code for Indexed expressions without warnings. All necessary information is provided to understand the problem and implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16781": {
        "explanation": "The issue is well-specified because it clearly identifies the problem with the dotprint output, provides the correct and incorrect tree structures, and explains why the current output is wrong. The issue also gives a specific example from the tutorial and indicates that the fix should apply to both the dot printer and the tutorial. All necessary information to reproduce and fix the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16792": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal counterexample that reproduces the error. The expected behavior is outlined, and the actual behavior (including the error message) is given. The root cause is partially identified (the C function has an incorrect signature). Additionally, the context and relevance of the issue are explained. All necessary information for understanding and solving the problem is provided.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16840": {
        "explanation": "The issue is not well-specified. It's unclear what the `S(2)//S.Half` expression refers to. The expected behavior is described as Python's `2//.5 -> 4`, but it's unclear how this should be implemented or what exactly is causing the ZeroDivisionError. The issue lacks context, explanation of the problem, and specific instructions for the solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-16862": {
        "explanation": "The issue is reasonably well-specified because it identifies a specific problem (IndexError when args[0] is used on an empty set), provides context about where the issue occurs, and references a failing test case. However, there are some missing details that would need to be filled in by the engineer, such as exactly how to fix the issue (should we add a check for an empty set, use a different approach, etc.) and whether the type-casting to list is essential to the fix. The ping to @mrocklin suggests the reporter is also seeking guidance on the design question of why the set is being type-cast to a list in the first place.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16886": {
        "explanation": "The issue is well-specified. It clearly states the problem (incorrect Morse code mapping for \"1\"), provides the current incorrect mapping, and specifies the correct mapping. There is no ambiguity about what needs to be fixed. The fix would involve changing the mapping from \"----\" to \".----\" for the value \"1\" in the Morse code dictionary within the simpy.crypto.crypto module. The reporter has provided all the necessary information to identify and correct the issue without requiring further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16943": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example showing that when using sympy.fps with x**2, it returns a 'Pow' object instead of a formal power series. The expected behavior is also implied - it should return a proper formal power series that supports indexing. The issue even references a specific GitHub issue (#12310) that this is fixing. The documentation reference is provided to show what behavior is expected. This provides all the information needed to understand what needs to be fixed in the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-16963": {
        "explanation": "The issue is about two related problems with the sympify function in SymPy. The first part is clearly described - sympify is not converting a Python dict to a SymPy Dict, which causes problems with hashing. There is a clear example showing the difference between sympify(d) and Dict(d). The second part is a question about implementing a decimal precision kwarg for N() and whether sympify should use evaluate=False when passed a string. While this second part is less specific, the first part is well-specified enough for a meaningful solution. I would label this as REASONABLY_SPECIFIED because there are two issues in one report, with the first being well-specified and the second having some ambiguity about exactly what should be implemented.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-16988": {
        "explanation": "The issue is reasonably specified. The problem is about the 'Intersection' function in Python, which should remove duplicates. The issue provides examples of the expected output for certain inputs. There is a mention of the answer potentially being a 'Piecewise' expression or remaining unevaluated, but the exact condition for this is not fully clear. There's also a suggestion that duplicates should be removed at the outset of instantiation, and ordering might be important for canonical processing. However, the exact implementation details and the role of 'x' in the examples are not explicitly defined. Despite these minor ambiguities, a reasonable interpretation and solution can be inferred from the given information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17010": {
        "explanation": "The issue is reasonably specified. The problem is described with an example from the code, and the potential problem (infinite recursion) is explained. The reporter has identified the specific function and line in the code where the issue occurs, and has described the condition that leads to the infinite recursion. The request for a solution is clear, asking for a more robust way to canonicalize the expression to avoid the infinite recursion. However, there are some implementation details that would need to be worked out when creating a solution, such as exactly how to implement the \"more robust way to canonicalize\" and what is meant by \"fast way\" in this context. These are not explicitly specified in the issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17038": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, with specific examples of incorrect behavior, analysis of the root cause, and suggestions for a potential solution. The issue provides concrete code examples showing the incorrect results, explains the underlying problem with the implementation, and even offers possible approaches to fix it. This level of detail allows for a direct and meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17067": {
        "explanation": "The issue is well-specified because it provides a clear minimal working example (MWE) that reproduces the problem, a description of the expected and actual outputs, and a reference to an external verification using Mathematica. The issue also mentions that the problem exists in specific Sympy versions and describes the nature of the error (incorrect simplification of a trigonometric expression). This information allows for a targeted solution to fix the simplification issue in Sympy.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17115": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a minimal working example that demonstrates the issue. The error traceback is provided, which indicates where the problem is occurring in the code. There is also a reference to a specific code location and a hypothesis about what might be causing the problem. While there are some implementation details to work out, the core issue is clear and actionable for a developer familiar with the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17139": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The problem description is vague and lacks sufficient details about the desired outcome. While it is clear that there is an error being raised when simplifying a specific expression (cos(x)**I), the expected behavior or solution is not specified. The issue mentions a \"Invalid comparison of complex I\" error, but it doesn't provide any information about what the correct behavior should be, what the expected result should be, or how to resolve the error. Without this information, it is difficult to determine what changes need to be made to the codebase to fix the issue. Additionally, the issue only provides a traceback without any context or explanation of the underlying problem. The reporter has simply provided an error message and expects a solution without giving any guidance on how to approach the problem. This makes it impossible to determine what the correct behavior should be or how to modify the code to achieve it. The issue is essentially a bug report without any proposed solution or guidance on how to fix it, which is not sufficient for a meaningful attempt at a solution.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "sympy__sympy-17150": {
        "explanation": "The issue is well-specified. It explains the problem with an example, identifies the location of the issue in the codebase, and even suggests possible solutions. The reporter has clearly analyzed the problem, identified the incorrect behavior, and provided multiple approaches to fix it. This provides a clear path for implementing a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17176": {
        "explanation": "The issue is about a function 'bool_map' in the SymPy library that is supposed to find a mapping between two Boolean expressions. The first part of the issue shows that when using 'Xor(A1,A2,A3)' and its negation with 'bool_map', the result is incorrect or unexpected. The second part points out a problem in the '_finger' function, which is used for some kind of fingerprinting or comparison of Boolean expressions, as it produces identical fingerprints for different expressions that should be distinguishable. The issue also mentions that the problem extends to XOR4 and XNR4, but it's unclear how many more inputs need to be tested or what the exact expected behavior is for these cases. The lack of a clear description of what the correct output should be and the exact nature of the problem makes it somewhat ambiguous.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17194": {
        "explanation": "The issue is well-specified because it provides concrete examples of the current output and the desired output for the mathml printing function in SymPy. Each example shows what input produces what incorrect output and what the correct output should be. This gives a clear understanding of what needs to be fixed in the codebase. There's no ambiguity about what the problem is or what the expected solution should achieve.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17223": {
        "explanation": "The issue is well-specified with a clear example and explanation of the problem. The expected behavior is clearly stated (e1.match(e1) should return None), and the current incorrect behavior is demonstrated (it returns {w_: a*b} instead). The problem is to fix the match function so that it correctly handles non-commutative matrix multiplications.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17239": {
        "explanation": "The issue is reasonably specified. The problem is identified as incorrect printing of equality in several code printers (JavaScript, Julia, etc.). The example code and output show the current behavior and expected behavior (as seen in C and Fortran printers). The root cause is mentioned - these printers are using `StrPrinter._print_Relational` incorrectly. A solution would involve fixing these printers to properly handle the Eq object by overriding `_print_Relational` like the working C and Fortran printers do. The issue provides enough information to understand what needs to be fixed, but some implementation details would need to be worked out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17271": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the error being encountered when calling `frac(zoo)` in SymPy, which results in a TypeError. The problem is described as not expecting this error, and the user indicates they are trying to cover certain lines in a test but want to avoid the exception. While the issue could use a bit more detail on the expected behavior (e.g., what should happen when `frac(zoo)` is called), the provided traceback and context give enough information to understand the problem and work toward a solution. The ambiguity is minor and can be reasonably interpreted as needing to modify the code to handle the `zoo` case gracefully without raising an error.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17273": {
        "explanation": "The issue is well-specified. It clearly states that the value of hbar in sympy.physics.units is incorrect and provides the correct CODATA value with a reference to the source. A software engineer can directly locate the hbar definition in the sympy codebase, verify the current value, and update it to the correct value from CODATA. There are no ambiguities about what needs to be done.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17288": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with a code example and the expected outcome. However, there might be some interpretation needed on how to fix the issue within the codebase without seeing the actual implementation details.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17313": {
        "explanation": "The issue is vague and lacks specific context, making it unclear what the exact problem is and what the expected solution should be. It refers to functions like `ceiling` and `floor`, but it is not specified what these functions are (e.g., are they part of a specific library, a custom implementation, or a language-specific feature like in Python or NumPy?). Additionally, it is not clear what `pos` and `neg` represent (e.g., are they variables, functions, or specific values?). The issue also does not provide a clear description of the desired behavior or what is currently not working as expected. Without this information, it is impossible to determine what a successful solution would look like.",
        "label": "VAGUE"
    },
    "sympy__sympy-17318": {
        "explanation": "The issue is well-specified. The problem is described with a specific example that triggers an IndexError in the sqrtdenest function. The expected behavior is clearly stated: if an expression cannot be denested, it should be returned unchanged. The current error handling is incorrect, and the desired fix is to prevent the IndexError by returning the original expression when denesting is not possible. The provided example shows the old (broken) behavior and the new (desired) behavior. All the necessary information is provided to understand what the bug is and what the expected fix should accomplish.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17340": {
        "explanation": "The issue description is quite brief and lacks sufficient detail to understand the context, the problem being addressed, and the specific requirements for the solution. It mentions that Permutation args are now subtypes of Basic and that a list was changed to Tuple, but it does not explain why this change is needed, what issues it addresses, or what the expected outcome should be. A software engineer would need more information about the Permutation class, the Basic class, and the implications of changing from list to Tuple for the arguments. Without this context, it is difficult to determine if the change is correct or if there are any additional considerations or tests that need to be updated. Therefore, the issue is vague and lacks clarity.",
        "label": "VAGUE"
    },
    "sympy__sympy-17394": {
        "explanation": "The issue is reasonably specified.  It describes a problem with the `lambdify` function in SymPy when using the `scipy` module.  The problem is that `lambdify` is not correctly translating `lowergamma` to the corresponding `gammainc` function.  The issue also provides a code example to reproduce the problem and references other related issues (#16533, #16535, #15134) for context.  However, the exact solution is not entirely clear.  The issue suggests that `lowergamma` should be translated to `gammainc` and that scaling might be involved, but the specifics of the scaling and the exact implementation details are not fully spelled out.  A successful solution would require understanding the relationship between `lowergamma`, `uppergamma`, and the regularized incomplete gamma functions `gammainc` and `gammaincc` in SciPy, as well as how to modify the `lambdify` code to handle this correctly.  While the general direction is clear, there are some details that would need to be worked out during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17512": {
        "explanation": "The issue is somewhat clear about the problem, but there are some missing details that need to be inferred. The main problem is that the `Range(range(10))` is currently allowed and the author believes it shouldn't be. There are examples of what is currently happening and what is expected. However, there are several key details that are not explicitly provided, such as:\n\n1. What is the overall goal or purpose of the `Range` function? \n2. What is the expected behavior when a `range` object is passed to `Range`? \n3. What are the specific requirements for what types of arguments are valid for `Range`? \n4. How should the sympification process work in this context? \n5. What are the requirements for the `ImageSet` function to properly handle its arguments? \n\nDespite these missing details, there is a clear problem statement, examples of current vs expected behavior, and a general direction for the solution (i.e., disallowing `Range(range(10))` and ensuring proper sympification). The solution would likely involve changing the validation logic in the `Range` function to check the type of arguments and ensure they are properly sympified before being used. The author also provides examples of related issues that need to be addressed (like the `ImageSet` function). This gives a reasonable path forward for implementation.\n\nThe issue is not completely vague, but there are enough missing details that require some interpretation and understanding of the codebase and context to implement a proper solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17630": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of how to reproduce it, including code and the specific error that occurs. The expected behavior is implied by the fact that one multiplication works but multiple multiplications fail. A solution would need to ensure that ZeroMatrix objects are properly maintained through the _blockmul operation so that subsequent operations do not fail with an AttributeError.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17653": {
        "explanation": "The issue is reasonably specified. It provides a clear problem description, steps to reproduce the issue, and identifies the specific part of the code that is causing the problem. The issue explains that a subclass of Symbol (TypedSymbol) is being upcast to a regular Symbol in the __new__ method of IndexedBase, leading to loss of type information. The issue also provides a code snippet with a commented line that is suspected to be the cause of the problem. The reporter also provides instructions to reproduce the issue with and without the problem (using different versions of SymPy). However, there are some missing details that would need to be filled in, such as the exact expected behavior and the potential impact of removing or modifying the commented line. The issue is clear enough to understand the problem, but some interpretation is needed to determine the best solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17655": {
        "explanation": "The issue is well-specified. The user has provided a clear example of the problem, including code that reproduces the issue and the expected vs actual behavior. They've also included the error trace, which helps in understanding where the issue is occurring. The expected behavior is clearly stated. This information is sufficient for an experienced developer to understand what the problem is and how to go about solving it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-17696": {
        "explanation": "The issue is reasonably specified. The problem is that the refine function is not correctly simplifying the sign function under certain assumptions. The code example shows the current behavior, and the expected behavior for expr3 and expr4 is given as 1. The suggestion to look at PR #17019 for a similar fix provides a reference point for the solution. While the exact implementation details are not provided, there is a clear understanding of what the desired outcome is: to have refine correctly simplify sign(x) to 1 when the assumptions indicate that x is positive (and nonzero in the case of expr3). The mention of related issues also provides additional context for the problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17770": {
        "explanation": "The issue is somewhat clear but there are some blanks to fill in. It mentions correcting functions in subclasses of `HyperbolicFunction` and improving `_eval_is_real` and `_eval_is_finite`, but the exact nature of the corrections or improvements needed is not fully detailed. A developer would need to understand the current implementation and expected behavior of these functions to make the necessary changes. There is a general direction, but the specifics are not fully provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17809": {
        "explanation": "The issue is reasonably well-specified. The problem is to modify the is_positive method for the cosh function and the Abs function to handle the cosh function correctly. The issue provides examples of the current behavior and the expected behavior. The examples show that abs(cosh(r)) should simplify to cosh(r) when r is real, but currently does not simplify correctly in all cases. The issue also references a GitHub issue number (Fixes #11721) which may provide more context. There are some details that would need to be filled in, such as exactly how to implement these changes in the codebase, but the overall goal is clear. The issue is asking for a change to the SymPy library's behavior for the cosh and Abs functions, but the expected behavior is clearly defined through examples.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17821": {
        "explanation": "The issue is reasonably specified.  It clearly states two main tasks: implementing the `S.Catalan.rewrite(Sum)` functionality and demonstrating a method to automatically generate LaTeX equations for documentation instead of manually typing them.  The first task is clearly defined.  The second task, while a good idea, is less clearly defined in terms of implementation details.  It suggests using the existing codebase's capabilities to generate the equations, but doesn't specify *how* to do this or what exactly should be generated.  The mention of a potential optimization for the LaTeX printer adds another layer of ambiguity.  However, the overall direction is clear enough to make a reasonable attempt at a solution, even if some details will need to be worked out during development.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-17845": {
        "explanation": "The issue is reasonably specified but has some missing details. It's clear that the current string representations of Interval and FiniteSet objects do not follow the principle that str(object) should return valid code to recreate the object. The problem statement explains that changing this would result in \"ugly\" code for Interval, printing something like \"Interval(0, 1, True, False)\". However, the exact desired solution is not clearly defined. There is ambiguity about what the new string representation should look like while avoiding the \"ugly\" output. The issue also references an original issue and author, but doesn't provide specific requirements for the new string format. The developer would need to interpret what would be an acceptable balance between being valid code and being readable/pretty.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18033": {
        "explanation": "The issue is reasonably specified. The task involves removing a flag from the Permutation class and moving the printing logic to the SymPy printers. It mentions that the flag should be deprecated following the project's deprecation policy. The issue also provides some context from a previous pull request and specifies how the different printers (str, pprint, latex) should behave. However, some details are not explicitly provided, such as the exact implementation steps, how the printer flags should be set, and how to handle existing code that uses the flag. These details would need to be inferred from the context and the project's coding standards.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18057": {
        "explanation": "The issue is well-specified. The problem is clearly described with a reproducible example, the expected vs. actual behavior is outlined, and the problematic code is identified. The issue is about sympy's __eq__ method incorrectly using eval on the repr of unknown objects, which leads to unexpected errors and incorrect equality checks. The report includes a minimal working example that triggers the bug, a description of the error, and even a related issue showing another unexpected behavior. All the necessary information to understand and fix the problem is provided.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18062": {
        "explanation": "The issue is reasonably specified. The problem is described with an example showing the current output and the issue (the '1' being dropped). The expected behavior is implied but not explicitly stated. It is reasonable to infer that the imageset should include both the constant term and the varying term in the expression.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18087": {
        "explanation": "The issue is reasonably well-specified, but there are some blanks to fill in. It describes a problem with the trigsimp function in SymPy versions including 1.5, where it incorrectly simplifies cos(x)+sqrt(sin(x)**2) as cos(x)+sin(x) for general complex x, but correctly handles it when x is real. The description provides enough information to understand the problem and begin working on a solution, but there are still details that would need to be filled in during the implementation process, such as exactly how to handle the simplification for complex x and what the expected behavior should be. The issue is clear enough to know what the problem is, but there may be multiple approaches to solving it that would need to be considered.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18109": {
        "explanation": "The issue is asking why the pretty print of the expression 'oo - oo' results in 'nan' even when evaluation is disabled. The code example is provided to demonstrate the issue. The expected behavior seems to be that with evaluation disabled, the expression 'oo - oo' should not be evaluated to 'nan'. The problem is well-defined and the reporter is asking for an explanation of the current behavior, not a new feature. The code is provided and the desired outcome (understanding why this happens) is clear. Therefore, the issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18116": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The description is vague and lacks clear details about what the problem is, what the expected outcome is, and how to approach the solution. There is a mention of separating boolean and symbolic relationals, but it is unclear what this entails and how to implement it. The references to other tickets and external links do not provide enough information without context. It is not clear what code changes are required, what the current behavior is, or what the desired behavior is. Therefore, it is almost impossible to understand what is being asked to do without further information.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "sympy__sympy-18130": {
        "explanation": "The issue is reporting a bug where the intersection of an ImageSet defined by the expression n**2 - 1 with the set of Integers is incorrectly returning an EmptySet. This is clearly described with a code example and expected vs actual behavior implied (that the intersection should not be empty). The problem is well-understood in the context of the SymPy library, particularly in the diophantine module. A solution would involve debugging and fixing the intersection logic in the relevant part of the codebase. The issue is well-specified enough for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18168": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The issue is asking about the validity of `is_closed` and `is_open` properties for `S.Rationals` in SymPy. However, the problem description is ambiguous on several key points:\n\n1. It's unclear whether the reporter is asking for a mathematical validation of these properties (i.e., whether they're correct from a mathematical perspective) or a code implementation validation (i.e., whether the properties are implemented correctly in the codebase).\n\n2. The reporter provides two conflicting suggestions: one where `is_open=False` and `is_closed=False` (which would be mathematically correct for Q as a subset of R with the standard topology), and another where an exception should be raised. It's not clear which of these options is actually desired.\n\n3. The reporter states that the properties ",
        "label": "VAGUE"
    },
    "sympy__sympy-18189": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. It shows two examples where the diophantine function returns different results based on the order of the symbols provided. However, the issue lacks any explanation of what the expected behavior should be, how the permute=True parameter is supposed to work, and what the actual problem is that needs to be solved. The issue also doesn't provide any code context or information about the diophantine function's implementation. Without understanding what the correct output should be and how the function is supposed to work, it's not possible to determine what needs to be fixed in the code. The issue is vague and provides insufficient information to understand what a successful solution would look like.",
        "label": "VAGUE"
    },
    "sympy__sympy-18191": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is a recursion error when evaluating a specific expression in SymPy. The error traceback is provided, showing that the recursion occurs during the evaluation of the power function. The issue also points out the specific line in the code (L373-L374) where an additional check is needed. With this information, a developer can understand the cause of the recursion error and implement the necessary check to fix the issue. The provided code context and the specific location for the fix make this a well-specified issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18198": {
        "explanation": "The issue is reasonably specified. It provides a clear motivation for renaming the module and introduces a new dict-like handler for managing global parameters. The expected behavior of this handler is described with code examples that show how it should work. However, the implementation details for making the properties callable classes that can be used as context managers are not fully specified, which leaves some blanks for the developer to fill in. Overall, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18199": {
        "explanation": "The issue is well-specified. It clearly states the problem with the `nthroot_mod` function: it misses the root x = 0 mod p when a % p == 0. The issue provides a concrete example (`nthroot_mod(17*17, 5, 17)`) that illustrates the problem and what the expected missing root is (0 mod 17). The problem is mathematically defined (x^n = a mod p), and the condition under which the root is missing (a % p == 0) is clearly stated. This provides enough information for an experienced software engineer to understand what the function is supposed to do differently and how to approach fixing it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18200": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear example of the problem with a code snippet that reproduces the error. The error message shows that an 'int' object is incorrectly being treated as a symbolic expression when the 'free_symbols' attribute is accessed. The issue also references related tickets, which may provide additional context, but the core problem is clearly described with a traceback and specific code causing the error. A developer can understand what is going wrong and work on a fix based on this information.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18211": {
        "explanation": "The issue is reasonably specified because it provides a specific example of where a `NotImplementedError` is being raised instead of returning a `ConditionSet`. The expected behavior is also described with an example output. However, there might be some blanks to fill in regarding the exact implementation changes needed in the codebase to achieve this behavior, which would require understanding the relevant parts of the SymPy codebase. Therefore, the issue is reasonably specified but not entirely well-specified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18256": {
        "explanation": "The issue is reasonably specified because it clearly explains the current behavior (parentheses being added) and the desired behavior (removing parentheses and using nested superscripts). It provides LaTeX examples and references to conventional usage. However, there might be some ambiguity in how to implement this change in SymPy's LaTeX printing logic without additional context about the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18273": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of how to reproduce the IndexError when using the cse function with CRootOf objects. The stack trace shows the exact location of the error and the conditions causing it (index >= degree). The goal is to fix this error in the codebase. There's a clear understanding of what the issue is and what needs to be resolved.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18351": {
        "explanation": "The issue is about adding support for additional matrix expressions to the NumPy printer in SymPy. The issue lists the specific matrix expressions that need to be supported, and it references a related pull request (#17013) that is a work-in-progress. However, the issue lacks a detailed description of what the expected behavior is for each matrix expression in the NumPy printer. It also doesn't specify the requirements for the implementation, such as what functions or methods should be used to represent these expressions in NumPy, or how they should be translated. The issue appears to be a work in progress and may not be complete enough to provide a clear path for a meaningful solution without further information. Therefore, I would label this issue as REASONABLY_SPECIFIED.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18477": {
        "explanation": "The issue is reasonably specified. It mentions the need to expose `min_fixed` and `max_fixed` settings for Float printers, similar to the mpmath printer. It also mentions unifying Float printer behavior across different printers (e.g., LaTeX and string printers). While the overall direction is clear, some implementation details are not provided, such as specific formatting rules or how to integrate with existing printer options. A software engineer could interpret and implement the necessary changes based on the context of the existing codebase and the referenced mpmath printer settings.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18478": {
        "explanation": "The issue is asking why the behavior of the `.subs(x, oo)` method differs between two similar expressions: (x+cos(x)) and (exp(x)+cos(x)). It's clear what the user is observing (different results for similar expressions) and what they want explained (why one gives `oo` and the other gives `AccumBounds`). The user is seeking an explanation for the inconsistency, which is a well-defined problem in understanding the behavior of the code. The problem is not to change the behavior, but to understand why it exists, which can be addressed by examining the implementation of `.subs()` and how it handles expressions involving infinity in SymPy. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18587": {
        "explanation": "The issue is well-specified. The reporter provides a clear example of the current behavior, explains what they expect (an exception to be raised), and asks if there's a reason for the current behavior. The code example shows exactly what inputs produce the unexpected result. A solution would involve checking if the length of the list passed to the Permutation constructor matches the size argument and raising an exception if they don't match. The reporter also provides a clear, reproducible example using the Python interpreter.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18605": {
        "explanation": "The issue is well-specified. The user provides a clear example of the problem, showing that the Idx object accepts non-integer bounds when a tuple is provided. They also show that passing a single non-integer value correctly raises a TypeError, but when a tuple is provided with non-integer elements, the check is not performed. The issue has a clear goal: to ensure the check for integer dimensions is applied to both upper and lower bounds when a tuple is given as an argument. The code example is provided, and the expected behavior is described. This provides enough information for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18630": {
        "explanation": "The issue is well-specified because it includes a clear error message and a reproducible example. The error is an AttributeError indicating that a 'TupleArg' object has no attribute 'compute_leading_term'. This suggests that there is a missing method implementation for the 'TupleArg' class. The issue also provides the full traceback of the error, which helps to understand the context in which the error is occurring. The example code shows how to reproduce the error, which is essential for developing and testing a solution. Given this information, a software engineer could identify the location in the code where the 'compute_leading_term' method needs to be implemented for the 'TupleArg' class and create a PR to fix the issue. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18650": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the current behavior and the expected behavior. The user wants the expression `sqrt(8)**Rational(2, 3)` to simplify to `2` instead of `2**(1/3)*2**(2/3)`. This gives a specific target for the solution. However, there may be some blanks to fill in regarding the underlying code implementation and how the simplification should be done in the context of the larger codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18667": {
        "explanation": "The issue is not well-specified enough for a meaningful attempt at a solution. The description is very brief and lacks important details. It mentions that a new feature for Schur numbers has been added, but provides no clear request or task. There is no explanation of what specific changes need to be made, what parts need review, or what the expected outcome is. The issue reads more like a commit message than a task to be solved. It is unclear what the actual problem is, what needs to be implemented or fixed, or what the requirements are for a successful solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-18698": {
        "explanation": "The issue is reasonably specified. It indicates that the function 'sqf_list' is not producing consistent output, providing examples of expected and actual outputs. However, some context is missing, such as what 'sqf_list' is supposed to do and how the correct output should be determined. The description provides examples, but understanding the expected behavior requires knowledge of the function's purpose, which may not be explicitly stated. Despite this, the examples give enough information to infer the intended functionality and guide the implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18728": {
        "explanation": "The issue is about fixing the is_zero and is_positive methods for the Pow class in SymPy. The description provides clear examples of what is wrong with the current implementation and what the expected behavior should be. It also explains why the current implementation is incorrect and how the fix addresses those issues. The issue also references a specific pull request and issue number. However, it is mentioned that the PR is a work in progress and has some unresolved problems, such as the zoo/n example. Despite these issues, the core problem and the desired outcome are clearly stated. The issue is therefore reasonably specified, as it provides enough information to understand what needs to be fixed and how to approach the solution, but there are some blanks to fill in regarding the unresolved problems.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18763": {
        "explanation": "The issue is well-specified. The problem is described with a clear example showing the current incorrect LaTeX output and the desired correct output. The example includes the exact SymPy code to reproduce the issue, and it shows both the incorrect and correct LaTeX strings. This provides all the necessary information to understand what needs to be fixed in the codebase. A developer would know exactly what the expected behavior is and how to test if their fix is working correctly.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18765": {
        "explanation": "The issue is well-specified. The problem is clearly described with examples showing the current behavior of MatAdd and MatMul compared to Add and Mul. The desired behavior is explicitly stated with an example of what the output should be when the evaluate keyword argument is used. The task is to add this evaluate keyword argument to MatAdd and MatMul to make their behavior consistent with Add and Mul.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18810": {
        "explanation": "The issue is reasonably specified. The problem is that the generate_derangements function is not handling unsorted permutations correctly. The two examples show that the function gives incorrect results for both a sorted and an unsorted permutation. The first example shows that the input string 'TRUMP' is incorrectly considered a derangement of itself, and the second example shows that the input string 'MPRTU' is not correctly identified as a derangement of 'TRUMP'. A derangement is a permutation where no element appears in its original position. The issue description provides enough information to understand what is wrong and how to fix it, but some implementation details will need to be worked out.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18835": {
        "explanation": "The issue is reasonably specified. The problem is that the `uniq` function is modifying the list that is passed to it, leading to unexpected behavior. The reporter provides examples of the issue and suggests a solution of checking the size of the list and raising a `RuntimeError` if it changes during iteration. While there are some details to work out (like exactly how to implement the size check and when to perform it), the general approach is clear and there is a sensible interpretation of what is required for a successful solution. The reporter also draws a parallel to Python's own behavior when modifying dictionaries or sets during iteration, which provides a useful reference for the desired behavior.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18903": {
        "explanation": "The issue is about the simplification of nested floor and ceiling functions in a symbolic computation context. The example shows that when evaluating expressions like `floor(floor(x) + 1) + x`, the simplification doesn't fully evaluate to the expected form `x + floor(x) + 1`. This indicates that the simplification rules for nested floor functions need to be improved. The issue is well-specified because it provides a clear example of the current behavior versus the expected behavior. A developer would understand that the goal is to modify the simplification logic to handle these nested cases correctly. There is enough information to make a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-18908": {
        "explanation": "The issue is reasonably specified. It provides a clear goal (adding more SciPy functions to the code printer) and a resource (the list of SciPy functions). While it does not specify exactly which functions need to be added or the implementation details, a reasonable interpretation is to add support for the missing special functions in the SciPyPrinter. A software engineer with access to the codebase can investigate the current implementation, identify which functions are missing, and implement them accordingly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-18922": {
        "explanation": "The issue is vague and lacks sufficient information for a meaningful attempt at a solution. The problem is described as an incorrect plot where the x-axis is moved to y=3 instead of creating a horizontal line. However, the exact context, such as the specific code being used to generate the plot, the libraries or functions involved, and the expected behavior are not provided. The issue description only includes a reference to a screenshot that the user has attached, but the screenshot itself is not included in the message. Without the actual code and more context about the plotting process, it is unclear what the correct implementation should be or what the root cause of the issue is. Therefore, it is impossible to solve the issue with the given information.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "sympy__sympy-18961": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The description includes a code diff showing the exact changes needed to the `digits` function to add a `bits` argument, which pads the output with zeros to reach the desired bit length. The explanation of the change and the test requirement are also clear. There's no ambiguity in the proposed implementation and the expected outcome.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-19007": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example and expected vs actual output. The user explains why the current output is incorrect. A developer would understand what the correct behavior should be and how to reproduce the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-19016": {
        "explanation": "The issue is reasonably specified but has some blanks to fill in. The main problem is the lack of implementation for the 'is_finite_set' property in the 'Range' class. The issue provides a proposed solution (returning self.size.is_finite), but it doesn't specify exactly how this should be implemented or how it should interact with the rest of the codebase. It also mentions additional issues with 'sup' and 'inf' methods that aren't fully described or explained. The issue provides clear examples of the current behavior and the desired outcome, but doesn't provide detailed instructions on how to implement the solution. A software engineer would need to understand the Sympy codebase and how the 'is_finite_set' property is used elsewhere to implement this correctly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19040": {
        "explanation": "The issue is well-specified enough to understand the problem and create a meaningful solution. The issue describes a specific bug in the 'factor' function in SymPy when using the 'extension=True' parameter. It includes a clear example of the problem, showing that the factor function is dropping a factor of 'y-1'. The issue also references another related issue (#5786) and is linked to a Stack Overflow question that provides more context. This information gives enough detail to understand what is wrong and what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-19091": {
        "explanation": "The issue is reasonably specified. The problem is clearly described as tensor contractions being computed before the application of the metric, which leads to incorrect results. The specific code in `tensor/tensor.py` is identified, and the explanation of why the ordering matters is provided with an equation. However, there are some blanks to fill in regarding the exact nature of the refactoring needed. The solution would require reorganizing how tensors represent their components, but the specifics of this refactoring are not fully detailed. A software engineer with domain knowledge could make reasonable assumptions and proceed with a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19093": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear example of the problem, including the error message and the code that triggers it. The problem is described as a regression, indicating that it worked in a previous version (0.7.3). This information allows a software engineer to reproduce the issue and identify the cause of the 'unhashable type' error when adding two BlockDiagMatrix objects. The goal is clear: to restore the functionality that allowed expressions with mutable BlockDiagMatrix objects.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-19201": {
        "explanation": "The issue is reasonably specified because it provides examples of the current behavior versus the proposed changes for printing symbolic matrix slices. It also explains the motivation behind the changes and highlights specific problems with the current output, such as missing brackets and inconsistent handling of slice syntax. However, some details may require interpretation, such as exactly how to implement the changes in the printer or how to handle edge cases not covered by the examples. A software engineer could still make a meaningful attempt at a solution based on the provided information, but there might be some blanks to fill in during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19254": {
        "explanation": "The issue is reasonably specified. It suggests replacing the Mignotte bound with the Knuth-Cohen bound in specific functions. However, some details about the implementation are missing, such as the exact algorithm for the Knuth-Cohen bound and the specifics of how to adapt it for the multi-variant case. Despite these gaps, there's a clear direction for the solution, and the necessary functions to modify are identified.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19346": {
        "explanation": "The issue is reasonably specified because it provides examples of the current behavior of `srepr` with different data structures (list, tuple, dict, set), and points out that the output for dict and set is not as intended. While it does not explicitly state what the expected output should be for dict and set, the examples for list and tuple give a pattern to follow. A sensible interpretation is that `srepr` should print the elements of dict and set in the same detailed and unambiguous way it does for list and tuple, such as `Set(Symbol('x'), Symbol('y'))` for sets and `Dict({Symbol('x'): Symbol('y')})` for dictionaries. This gives a clear direction for a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19487": {
        "explanation": "The issue is reasonably specified. The main task is clear: rewrite the sign function in terms of the absolute value (Abs) function. The example provided shows the expected output. However, there are some ambiguities regarding how to handle the case when the argument is zero. The issue mentions that sign(0) currently returns 0, but 0 / Abs(0) would be nan. There's a suggestion that sign(0) might should be nan as well, but there's no definitive answer provided on how to handle this edge case. A developer would need to make a reasonable decision on this point.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19495": {
        "explanation": "The issue is describing a bug in the handling of subs() method when applied to a ConditionSet containing an ImageSet. The user provides a clear example of the expected and actual behavior, showing that the subs() method is not working correctly in the case of a ConditionSet with an ImageSet. The problem seems to be that the substitution is being incorrectly applied to the bound variable of the ConditionSet rather than just the free variable y. The issue also references a related issue #7483, which suggests that the subs() method works correctly for a plain ImageSet. This provides additional context. The user is clearly explaining what is working correctly (the subs() on a ConditionSet with a FiniteSet and the subs() on a plain ImageSet) and what is not working correctly (the subs() on a ConditionSet with an ImageSet). The expected output is implied by the correct behavior of the other examples and by the related issue. Therefore, this is a well-specified issue with a clear problem description, examples of both correct and incorrect behavior, and sufficient context to understand what needs to be fixed.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-19601": {
        "explanation": "The issue is asking if there are any plans to release a version 1.6.1 of SymPy, similar to how 1.5.1 was released after 1.5. The user is currently stuck on 1.5.1 and wants to upgrade to 1.6 once 1.6.1 is available. However, the issue is not a request for a specific implementation or fix but rather an inquiry about future plans. Since it's asking about the roadmap and release planning, it's more of a request for information rather than a development task. Therefore, it is not well-specified enough for a meaningful attempt at a solution as it does not define a concrete problem to solve.",
        "label": "VAGUE"
    },
    "sympy__sympy-19637": {
        "explanation": "The issue is vague because it lacks sufficient context and details about the problem. It shows a code snippet with an UnboundLocalError but does not explain what the intended behavior is, what steps were taken to reproduce the issue, or what the expected outcome should be. Without understanding the purpose of the code and the context in which it is used, it's difficult to determine how to resolve the error. Additionally, the code snippet is incomplete and unclear, such as the line with 'hit = kern in s' being commented out and not part of the actual code. The issue also does not provide information about the environment, versions of dependencies, or any previous attempts to fix the problem. All of these missing pieces make it challenging to create a meaningful solution.",
        "label": "VAGUE"
    },
    "sympy__sympy-19783": {
        "explanation": "The issue is reasonably specified.  The problem is clearly described with a code example showing the current behavior and the desired behavior (which is implied by the fact that A * Identity simplifies correctly to A).  The code example demonstrates the inconsistency in behavior between A * Identity and B * Identity, where B is the dagger of A.  The expected behavior for B * Identity is implied to be similar to A * Identity, i.e., it should simplify to B.  The issue is that the simplification is not happening for the dagger case.  The problem is not perfectly specified in that the exact desired output is not explicitly stated, but the intended behavior can be reasonably inferred from the context and the example.  Therefore, this is a reasonably specified issue.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19885": {
        "explanation": "The issue is reasonably specified because it provides the code that reproduces the problem, the expected vs. actual results, and the relevant functions involved. However, without access to the codebase and the file 'test3.zip', there are some blanks that need to be filled in about the issue. For example, it's not clear what the expected answer should be or what the exact difference is between the 'linsolve' and 'solve' functions. But based on the provided code and the description, a sensible interpretation of what is required for a successful solution can be made.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-19954": {
        "explanation": "The issue is well-specified because it includes the specific error encountered (IndexError), the exact code that triggers the error, the versions of the relevant libraries, and the traceback showing where the error occurs. This provides sufficient information to reproduce the issue and understand what needs to be fixed. The problem is clear: there's a list index out of range error in the minimal_blocks() method when certain dihedral groups are processed by sylow_subgroup(). A successful solution would involve fixing this indexing error in the code.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20049": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the current behavior versus the expected behavior. The problem is explained with code examples that show the discrepancy between how angular velocity is calculated and how point velocity is handled. However, there are some implementation details that would need to be filled in, such as the exact approach to implement the desired functionality and how to integrate it with the existing codebase. Despite these blanks, there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-20139": {
        "explanation": "The issue is not clear on what exactly needs to be done. It mentions using Str instead of Symbol for the name of MatrixSymbol, but it's not specified where this change is needed or what the expected outcome should be. There is no detailed description of what the problem is, how it should be fixed, or any specific requirements for the solution. The references to other Issues or PRs are also missing, which could provide additional context. Therefore, it's unclear what a successful solution would look like without further information.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "sympy__sympy-20154": {
        "explanation": "The issue is reasonably specified as it provides the location of the function (sympy.utilities.iterables.partitions()), describes the current behavior (reusing output dictionaries), and explains the problem (performance vs correctness tradeoff, confusing behavior). However, there are some blanks to fill in, such as the exact implementation details needed to fix the behavior and how to optimize for both performance and correctness. A developer can interpret the request as modifying the partitions() function to copy the dictionary before yielding it, which would address the described problem.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-20169": {
        "explanation": "The issue is reasonably specified. The request is to extend the lens maker's formula to handle plano- lenses and thick lenses. While the general direction is clear, there are some details that need to be determined, such as the specific equations or approximations for thick lenses and plano-lenses, and how these would be integrated into the existing implementation. However, with domain knowledge or research, a software engineer could find the necessary formulas and implement the changes.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-20264": {
        "explanation": "The issue is well-specified. The user provided a clear description of the problem: a RecursionError occurs when converting a specific SymPy expression to LaTeX. They also included a detailed code example that reproduces the error and showed that the error occurs under certain conditions. The user also provided the version of the library they are using and the full error trace. All of these details allow a software engineer to understand the problem and start working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20428": {
        "explanation": "The issue is well-specified. The problem is described in detail with code examples showing the current behavior and expected behavior. The underlying cause (unstripped leading 0 in the DMP representation) is identified, and specific examples of the inconsistent behavior are provided. There is a clear understanding of what needs to be fixed (stripping leading zeros in the DMP representation), making it possible to create a meaningful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20438": {
        "explanation": "The issue is about the `is_subset` method in the SymPy library giving incorrect results when comparing a `ProductSet` and a `FiniteSet`. The issue includes a detailed code example and output that demonstrates the problem, including the incorrect behavior of `b.is_subset(c)` and `c.is_subset(b)` both returning `True`, which is logically inconsistent since a `ProductSet` and a `FiniteSet` cannot be true subsets of each other in both directions unless they are equal. The example also shows a traceback when attempting to simplify an equality involving these sets, indicating an error in the implementation. The issue is well-specified with a clear problem description, a minimal reproducible example, and the expected versus actual behavior. Therefore, it is clear what is required for a successful solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20442": {
        "explanation": "The issue is well-specified. It describes a specific problem with the 'convert_to' function in sympy when handling certain unit conversions. The issue includes a clear example of the unexpected behavior (converting joule*second to joule giving joule**(7/9)), and contrasts it with related examples that work as expected. The reporter explains what they would expect (original expression, base units, or an error) versus what actually happens. This provides enough information for a developer to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20565": {
        "explanation": "The issue is reasonably specified. The problem is clear: the `Rationals` set in SymPy should contain all floating point numbers, but it currently does not. The provided code example demonstrates the issue, and the expected outcome is explicitly stated. However, there might be some ambiguity regarding how to implement the solution, as it depends on the internal logic of SymPy's `Rationals` class and how floating point numbers are handled in the library. The main task is to adjust the `contains` method to correctly identify floats as rational numbers, but the exact implementation details might require some exploration of the codebase.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-20590": {
        "explanation": "The issue is well-specified. The user clearly explains the change in behavior between versions 1.6.2 and 1.7 of the sympy library regarding the Symbol class. They provide concrete examples showing that Symbol instances had no __dict__ attribute in 1.6.2 but do have it in 1.7. They also provide the error message and explain their assumption about why this might be happening (parent class defining __slots__). This provides enough information to investigate the cause of the change and determine if it's indeed a bug as the user suspects.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20639": {
        "explanation": "The issue is reasonably specified.  The problem is that the pretty print representation of pi**(1/E) is incorrect, showing a square root symbol instead of a proper exponentiation.  The reporter provided a clear example of the incorrect output and contrasted it with the correct LaTeX and string representations.  However, the solution requires understanding the codebase for pretty printing to determine where the exponentiation is being rendered incorrectly as a square root.  There are some blanks to fill in about how the pretty printing works in this codebase, but the reporter provided enough information to understand what the correct output should be.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-20741": {
        "explanation": "The issue is reasonably specified. The problem is clearly described with code examples and expected vs actual behavior. The user is facing an issue where matrix expressions are not being simplified as expected. The provided code examples show that the simplify() method is not working as expected for certain matrix expressions, particularly with the ZeroMatrix. The user wants the expressions to be simplified properly. There might be some blanks to fill in about the exact expected behavior and the specific conditions under which the simplification should occur, but the general idea is clear. The issue is related to the SymPy library, and the user is pointing to an existing GitHub issue for reference.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-20801": {
        "explanation": "The issue is well-specified enough to understand the problem and what needs to be fixed. The problem is that comparing S(0.0) to S.false gives different results depending on the order of comparison, and the expected outcome is likely for S(0.0) == S.false to return True consistently. The examples provided clearly demonstrate the issue and the desired outcome.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-20916": {
        "explanation": "The issue is reasonably specified. It is clear that the goal is to fix the formatting of Greek letters in the pprint output so that subscripts are properly applied to the Greek letters instead of defaulting to ASCII-like formatting (e.g., \u03c90 instead of properly formatted subscript). While the exact implementation details are not specified, the problem and desired outcome are clear enough for a developer to investigate the pprint module, identify where Greek letter formatting is handled, and implement the necessary changes to ensure correct subscript formatting. Some assumptions may be needed regarding the specific formatting rules or libraries used, but the core issue is well-defined.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21101": {
        "explanation": "The issue is about the incorrect LaTeX output when using the `latex` function on a `Mul` object with `evaluate=False`. The example given is that `latex(Mul(6, S.Half, evaluate=False))` produces `6 1/2`, which lacks a `numbersep` (likely a space or formatting issue between numbers). The issue is well-specified as it clearly states the problem, provides a concrete example, and points out the specific issue (lack of `numbersep`). A software engineer would need to look into the `latex` function handling of `Mul` objects with `evaluate=False` and adjust the formatting to include the appropriate `numbersep` between the numbers in the LaTeX output.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21171": {
        "explanation": "The issue is well-specified as it provides a detailed error message and a reproducible example. The error clearly indicates that there is a TypeError in the _print_SingularityFunction() method due to an unexpected keyword argument 'exp'. The user also provides the exact code that triggers the error, which includes importing necessary modules, creating a Beam object, applying loads and supports, solving for reaction loads, and finally calling the shear_force() method. This information allows for a meaningful attempt at a solution because it gives the exact context in which the error occurs. The error traceback is also provided, which helps in pinpointing the location of the problem within the codebase. Therefore, the issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21208": {
        "explanation": "The issue is well-specified and clearly describes a discrepancy in the behavior of the `diff` method when applied directly to a matrix versus when applied to the individual elements of the matrix. The user provides a minimal working example that reproduces the issue, includes the expected and actual outputs, and asks whether it is a bug or intended behavior. This is sufficient for a software engineer to understand the problem and begin investigating it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21260": {
        "explanation": "The issue is well-specified. It provides a clear problem description with a specific example and output. The problem involves symbols created in different processes not being recognized as equal. The example demonstrates the problem with a multiprocessing setup and shows that symbols with the same name and assumptions are not considered equal across different processes. The issue also includes some observations and attempts at solutions (like pickling with dill). This is sufficient for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21271": {
        "explanation": "The issue is well-specified. The problem is clearly described as a doctest failure in the file sympy/physics/vector/frame.py. The exact failure is shown with the expected and actual output, which allows for a focused solution. The context is provided by mentioning previous pull requests and the discussion in #20946, giving necessary background. The issue has a clear goal: to fix the doctest failure that was previously disabled in #20954. The provided error output gives a concrete target for the fix, making it possible to create a meaningful solution without further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21286": {
        "explanation": "The issue is reasonably specified as it provides examples of the current behavior and the desired behavior for symbolic ranges. It indicates that symbolic ranges are not being canonicalized properly, which is a clear problem. However, it does not provide specific details on how to implement the canonicalization for symbolic ranges, what functions or modules are involved, or what constraints need to be considered. Therefore, there are some blanks to fill in, but there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21313": {
        "explanation": "The issue is about preventing the canonicalization of ImageSet expressions based on Float values in SymPy. The problem is clearly described with a specific example and the expected behavior. The user also provided a workaround (frange function) and explained why the current canonicalization is incorrect for Floats. The issue has specific examples that demonstrate the problem and what is expected. This provides enough information to understand the problem and work on a solution. However, there might be some details about how to implement the fix that are not explicitly mentioned, but the overall goal is clear.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21370": {
        "explanation": "The issue is not well-specified because it lacks sufficient information about the problem and the expected solution. The problem is described as an error occurring when calculating the minimal polynomial of a complex expression, but there is no clear explanation of what the issue is, what the expected behavior should be, or how to reproduce it. The issue simply provides a traceback and a very complicated expression without context or clear requirements for a solution. Without additional information about what the expected result should be and how to approach fixing the error, it is not possible to determine a meaningful solution.",
        "label": "IMPOSSIBLE_TO_SOLVE"
    },
    "sympy__sympy-21379": {
        "explanation": "The issue is well-specified with a clear Minimal Working Example (MWE) that demonstrates the problem. The user provides the Sympy version, the specific expression causing the issue, and various conditions under which the error occurs or does not occur. These include observations about which functions (sinh, cosh, tanh) trigger the error, the impact of removing parts of the expression, and the role of symbol assumptions (real vs non-real). Additionally, the user notes that the error disappears when not clearing the cache or when certain parts of the expression are modified. All of these details allow for a meaningful attempt at a solution, as they give clear guidance on what to investigate and test within the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21436": {
        "explanation": "The issue is reasonably specified. It clearly explains the current behavior of the `orient` method, which clears existing relationships when establishing a new one. It also provides a desired use case where the graph can be built in any sequence without overwriting previous relationships. The issue includes examples of both the current (undesirable) and desired behaviors, as well as code showing the problem with `ReferenceFrame._dcm()` wiping relationships. However, there are still some blanks to fill in, such as the exact algorithm or logic that should be used to build the graph in an arbitrary order without overwriting previous relationships, and how to detect and handle inconsistencies between different orientation definitions. These details would need to be worked out during implementation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21476": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal working example (MWE) that reproduces the KeyError when calling the `transform` method with an indirect relation between coordinate systems. The error traceback is provided along with debugging information showing that the issue arises from comparing CoordSystem objects with Str objects in the `_dijkstra` method. It is clear what the expected behavior should be - the transform should work for indirect relations, but it's raising a KeyError due to a type mismatch in the path_dict keys. This provides enough information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21527": {
        "explanation": "The issue is well-specified. It clearly demonstrates a problem with the linsolve function in SymPy where the output varies for similar inputs. The user provides a minimal, reproducible example with specific code snippets and expected vs. actual outputs. The core question about why the outputs differ is clearly stated, making it possible to understand and address the underlying issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21567": {
        "explanation": "The issue is reasonably specified because it provides context (referencing a previously fixed issue), shows the current behavior for related functions, and gives examples of the desired output for `csc` and `sec`. This allows one to infer the expected behavior for `csch` and `sech` by following the pattern established in the examples. However, some assumptions must be made about the exact implementation details within the codebase, which are not explicitly provided.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21586": {
        "explanation": "The issue is about a bug in the parse_expr function when using the local_dict parameter. The user provides a detailed example showing that when using local_dict, the parsing of expr2 is incorrect. The expected behavior is that p1 and p2 should be the same, but they are different. The issue is well-specified with code examples and a clear description of the problem. A successful solution would involve fixing the parse_expr function to correctly handle the case when using local_dict.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21596": {
        "explanation": "The issue is well-specified because it provides a clear example of the current incorrect behavior and the expected correct behavior. It shows the code input and output both before and after the expected correction. A software engineer with knowledge of the codebase could use this information to identify where the bug is occurring in the is_subset(Reals) functionality and implement a fix. The issue also references a related issue (#19513) which may provide additional context.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21612": {
        "explanation": "The issue is well-specified. It clearly describes the problem with the LaTeX parsing of nested fractions, provides the problematic LaTeX expression, shows the current incorrect parsing result, and specifies the expected correct result. The issue also includes information about the versions tested and provides a reproduction script. This information is sufficient to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21614": {
        "explanation": "The issue is reasonably specified. It indicates that the 'kind' attribute for a Derivative of a MatrixSymbol is returning 'UndefinedKind' when it should be similar to the 'Integral' case, which returns 'MatrixKind(NumberKind)'. While it doesn't provide full details on the expected implementation, a developer could reasonably infer that the 'kind' attribute for the Derivative should also return a 'MatrixKind' with an appropriate inner type, likely 'NumberKind' as in the Integral case. This gives a clear direction for the solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21627": {
        "explanation": "The issue is well-specified. It clearly describes a bug that occurs when evaluating the is_zero property of a specific SymPy expression involving cosh, acos, and acosh functions. The code to reproduce the error is provided, and the specific error type (RecursionError) is mentioned. This provides enough information for a developer to understand the problem and begin working on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21769": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of the issue with the LaTeX rendering of the Clebsch-Gordan coefficient when it is raised to a power. The reporter has provided a detailed explanation of the issue, including code snippets, images showing the incorrect rendering, and a suggested fix. The issue is related to how the LaTeX string is formatted for the CG object, specifically when it has a power. The reporter has even provided a code change that wraps the string in braces to fix the issue. This makes it clear what the problem is and what needs to be done to fix it. There is also context about the Sympy version and related issues, which provides additional information that could be helpful in understanding the broader context of the issue.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21847": {
        "explanation": "The issue is well-specified because it clearly describes the problem with the `itermonomials` function, provides a minimal reproducible example, and explains the expected versus actual behavior. The user also mentions the inconsistency with the documentation, which is a clear indication of what needs to be fixed. There is enough information to understand what the function is supposed to do and what it is doing instead, making it possible to work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21849": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the problem, including the error traceback. The error is related to the display of the LambertW function in Jupyter Lab when raising it to a power. The example code and the stack trace indicate that the problem is in the _print_LambertW() method not handling the 'exp' argument properly in the LaTeX printing process. While some context about the expected behavior and the environment (e.g., versions of sympy and jupyter) is missing, the core issue is clear enough to attempt a solution by modifying the _print_LambertW() method to handle the 'exp' argument correctly.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21930": {
        "explanation": "The issue is well-specified. The problem is clearly described with a minimal example showing the incorrect LaTeX output and what the correct output should be. The example shows that the LaTeX for a second quantized operator with a dagger and a power is not being formatted correctly. The reporter provides a concrete example of the current incorrect LaTeX output and what the correct LaTeX should be (adding curly brackets). This gives a clear target for fixing the LaTeX printing code in the secondquant module. The issue is specific, actionable, and has a clear expected outcome.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-21932": {
        "explanation": "The issue is reasonably specified. It explains the problem with an example and the error message. It also mentions where the error occurs in the code. A developer should be able to understand the problem and come up with a solution based on this information.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-21952": {
        "explanation": "The issue is somewhat clear about the problem, but there are several aspects that are not well defined. The core problem is that SymPy's assumptions system doesn't correctly evaluate whether an expression like n**2/2 is even when n is known to be even. The user wants this to return True instead of None, which is clear. However, the solution proposal (a more complex assumptions method with a dictionary of primes and multiplicities) is a suggestion rather than a concrete specification. Additionally, the user is unsure about the correct GitHub workflow for proposing such a change. The example with _eval_is_odd is provided, but it's unclear how this connects to the main issue and what exactly needs to be implemented. The issue also references another issue (#8648) which might contain more context. Overall, there are enough details to understand the problem and start working on a solution, but some aspects are left to interpretation.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-22005": {
        "explanation": "The issue is reasonably specified because it provides a clear example of the current incorrect behavior and the desired behavior. The example shows that the function solve_poly_system should raise a NotImplementedError when the system has an infinite number of solutions. The provided code diff also indicates the specific part of the code that needs to be changed to fix the issue. However, the issue does not provide a detailed step-by-step solution or the exact implementation logic that should be used to handle the infinite solution case. Therefore, some blanks need to be filled in about the issue, but there is a sensible interpretation of what is required for a successful solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-22080": {
        "explanation": "The issue is well-specified. The problem is clearly described with a concrete example showing the discrepancy in behavior when using `modules=[]` versus not using it. The example includes code that reproduces the issue, expected vs actual output, and the generated source code that shows the transformation causing the issue. All necessary information is provided to understand and reproduce the bug in the lambdify function when handling expressions involving the Mod function with `modules=[]` specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22098": {
        "explanation": "The issue is well-specified with clear examples of the current behavior versus the expected behavior. The user provides detailed Python code showing what is happening and what should happen instead. The goal is clear: to ensure that 'evaluate=False' properly prevents partial evaluation within expressions parsed by 'parse_expr'. The examples and versions are given, making it possible to reproduce and understand the problem. Therefore, this issue is well-specified.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22236": {
        "explanation": "The issue is well-specified because it clearly describes the problem (unevaluated Mul needs brackets for proper printing), provides example code snippets showing the current output, and indicates what the expected behavior should be (using brackets). It is clear what needs to be fixed in the code, which is to add brackets in the second case for correct representation.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22383": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The task is to drop testing for Python 3.6 in the CI configuration. The reference to NEP 29 and the issue #21884 provides context, and the brief description clearly states what needs to be changed. A software engineer would know exactly where to look in the CI configuration files to remove or comment out the Python 3.6 testing configurations. The release notes section indicates that this change does not require a release note, which is also clear. There are no ambiguities or missing details that would make it difficult to implement the solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22456": {
        "explanation": "The issue is reasonably specified.  It clearly states the current behavior (using keyword arguments for invariance) and the desired behavior (using positional arguments for invariance).  It also provides an example of the expected invariance and mentions that this is a property of all Basic subclasses, implying that the String class should conform to this behavior.  However, some details are missing.  The issue doesn't explicitly explain *why* the positional argument invariance is more appropriate for the String class, nor does it provide information on how the current keyword argument invariance is implemented.  This could make implementing the fix more challenging, as one might need to understand the broader context of the codebase and the reasoning behind the current implementation.  Despite this, the core problem and the desired outcome are clear enough for a meaningful attempt at a solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-22706": {
        "explanation": "The issue is reasonably specified. The problem is an IndexError in the StrPrinter for UnevaluatedMul. The example code and the error message are provided, which gives enough information to begin debugging and fixing the issue. However, more context about the expected behavior or the surrounding code structure might be needed for a complete solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-22714": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a minimal code example that reproduces the issue, the expected behavior, and the actual error that is occurring. The issue is that using evaluate(False) with Point2D is causing an error, while the same code without evaluate(False) works correctly. The problem is to fix this error so that evaluate(False) works correctly with Point2D. The issue is specific and actionable.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22740": {
        "explanation": "The issue is well-specified and provides a clear problem description, steps to reproduce, and even a solution. The problem is with lambdifying Heaviside(Min(x, y)), which causes an error due to nested select functions. The issue also explains the underlying cause of the problem (ITE in the Piecewise) and even provides a potential solution (rewrite ITE to And or simplify). The error message and the code that reproduces the error are also provided, making it easy to understand what needs to be fixed. The reference to a related issue (#22486) is also helpful for context. Overall, the issue provides all the necessary information for an experienced software engineer to create a PR that resolves the problem.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22773": {
        "explanation": "The issue is reasonably specified. The user describes the incorrect LaTeX display of a determinant and provides a code snippet that they used to fix the issue locally. The code snippet is clear and provides a reference implementation. However, there are some implementation details and context about the project that would need to be understood to properly implement and test this fix. The user also mentions that they are unsure if this is the best way to solve the issue and don't have time to comply with all the requirements, which indicates there are additional considerations for a complete solution.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-22914": {
        "explanation": "The issue is well-specified. The problem is clearly described with a code example showing the current behavior and expected behavior. The solution is also provided in the form of code that should be added to the PythonCodePrinter class. A developer would have all the information needed to implement the proposed solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-22969": {
        "explanation": "The issue is reasonably specified. It points out a specific problem in the implementation of the BeamParameter class in the sympy.physics.optics.gaussopt module. The issue explains that the beam waist calculation (w_0) is not correct when considering a change in refractive index. It provides code context, shows an example of the current behavior, and explains why the current implementation is not physically accurate (the beam waist should not change in the described scenario). This gives a clear direction for a solution: to fix the w_0 calculation to properly account for refractive index changes. However, there may be some details about the correct physical model that would need to be researched or confirmed before implementing a fix.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-23021": {
        "explanation": "The issue is well-specified. The problem is clearly described with a detailed error traceback and a specific example of the error. The desired behavior is also clearly demonstrated with before and after examples. The issue has a clear objective: to add support for Min/Max in the decompogen function so that it doesn't cause a recursion depth exceeded error. The issue is tied to specific GitHub issues and has a clear test case to verify the fix. All necessary information is provided to understand what the problem is, what the expected outcome should be, and how to verify the solution. The release notes also indicate what needs to be updated. This level of detail makes it possible to implement a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23262": {
        "explanation": "The issue is well-specified. The reporter provides a minimal working example (MWE) that clearly demonstrates the problem with the Python code printer in SymPy 1.10. The issue is that when generating code for a tuple with a single element, the printer is not including the trailing comma, which is necessary for Python to recognize it as a tuple. The reporter also shows that the behavior changed from version 1.9 to 1.10 and provides examples of both correct and incorrect outputs. The request is clear: fix the code printer to handle single-element tuples correctly by ensuring the trailing comma is included. This is a specific and actionable task for a developer to address within the SymPy codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23296": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It provides a clear example of the problem, including the error message, and shows that the function _collect_factor_and_dimension is not correctly identifying a dimensionless quantity in an exponent. The example code demonstrates the error and shows that check_dimensions does not raise an error, which helps to isolate the issue. Additionally, there is a PR that claims to fix this issue, which further confirms that there is a known solution. The problem is specific and actionable for a software engineer with knowledge of the codebase.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23413": {
        "explanation": "The issue is reasonably specified. It provides a clear example of the expected versus actual behavior, including the specific input and output. However, it does not fully explain the context of 'hermite_normal_form' function or the environment it's being used in (e.g., which library, versions, etc.). Despite this, the issue gives enough information to reproduce the problem and understand the discrepancy, making it possible to work on a solution with some assumptions filled in.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-23534": {
        "explanation": "The issue is well-specified because it includes a clear problem description, a minimal reproducible example, and the expected vs. actual results. The user is using the `smp.symbols` function with a class (`smp.Function`) to create function objects, but an extra layer of parentheses is causing the creation of `Symbol` objects instead of `Function` objects. The example demonstrates this by creating symbols with an extra layer of parentheses and shows that the result is not as expected. The issue also includes the Sympy version, which is helpful for debugging. All the necessary information to reproduce and understand the issue is provided.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23729": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described in detail, including the error message, the cause of the issue, and a suggested fix. The expected output after the fix is also provided. This information allows for a meaningful attempt at a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23808": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the `sum_of_squares` function in SymPy causing a RecursionError for relatively small inputs. The issue includes a detailed error traceback and a specific example (n = 1000000, k = 2) that reproduces the problem. The reporter also explains why they believe this might be unintended behavior, mentioning that the number has an easy factorization. With this information, an experienced developer would be able to analyze the `pow_rep_recursive` function in the SymPy codebase to identify why it's causing a recursion overflow and work on a solution to fix or optimize it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23824": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific example of incorrect behavior, including expected vs actual results. The reporter has already identified the source of the bug and indicates the fix involves reversing an insertion loop. The test case clearly demonstrates the issue and what the correct behavior should be. All necessary information is provided to understand what needs to be fixed and how to verify the fix is successful.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-23950": {
        "explanation": "The issue is well-specified. It clearly explains the problem: the method as_set() on the Contains object is returning the Contains object itself, which is not a set. This is causing a failure when trying to use it in a Piecewise expression, as it lacks the as_relational() method expected by the code. The expected behavior is that as_set() should return an actual set object. The error message and the code example provide enough context to understand the problem and how to fix it.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24066": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described, with a specific function (SI._collect_factor_and_dimension) and a scenario in which it fails. There is a reproduction script, an assertion that checks the expected result, and a description of the error that occurs. The goal is to fix the function so that it properly detects when an expression involving exponentials is dimensionless. This provides enough information to understand the problem and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24102": {
        "explanation": "The issue is well-specified. It provides a clear description of the problem: the new `parse_mathematica` function is unable to handle Greek characters like `\u03bb`, unlike the old `mathematica` function. It includes a specific example that works with the old function but fails with the new one, along with the exact error message. This is sufficient for a software engineer to understand what the issue is, how to reproduce it, and what the expected outcome should be (correctly parsing Greek characters).",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24213": {
        "explanation": "The issue is well-specified because it provides the code to reproduce the problem, the expected behavior, and the actual error message. The code demonstrates that the function `_collect_factor_and_dimension` is not handling the case where the dimensions of the terms in an addition are equivalent but not identical. The error message clearly indicates the problem, and the example shows the context in which it occurs. This information is sufficient for a software engineer to understand the issue and work on a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24325": {
        "explanation": "The issue is well-specified. It clearly identifies a numerical error in the conversion from coulomb to statcoulomb within the 'cgs_gauss' unit system in the 'sympy' library. The problem is described with a concrete example showing the current incorrect output and the expected correct output. It also provides the incorrect and correct versions of the test function 'test_conversion_to_from_si()', which indicates how the fix should be implemented. The issue is specific, actionable, and the expected solution is clearly outlined. A software engineer can directly use this information to locate the relevant code in the 'sympy' codebase and make the necessary corrections to the unit conversion logic to produce the correct output. The information provided is sufficient to understand the problem and implement a solution without requiring further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24353": {
        "explanation": "The issue is well-specified enough to understand the problem. The error message shows that there is an ImportError when running py.bench due to a missing module 'py.__.test.item'. The issue also includes the version of the 'py' library being used (1.1.1). This information is sufficient to investigate why the import is failing and to potentially fix it. The original issue and author are also provided for additional context.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24370": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. The problem is clearly described with a reproducible example and a detailed error message. The issue explains that using sympy.Integer with floor division on a symbolic expression causes an error, while using a plain Python int on the left-hand side works. This provides enough information for an experienced software engineer to understand the problem and how to approach a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24443": {
        "explanation": "The issue is reasonably specified as it provides a clear example of the problem, identifies the location of the issue in the code, and suggests a possible direction for the solution. However, there may be some blanks to fill in regarding the exact implementation of the fix and how to simplify the `_image()` function.",
        "label": "REASONABLY_SPECIFIED"
    },
    "sympy__sympy-24455": {
        "explanation": "The issue is well-specified enough for a meaningful attempt at a solution. It clearly describes the problem with the `is_cyclic` method in SymPy's `PermutationGroup` class when applied to a group isomorphic to S3 that is not constructed using `SymmetricGroup`. The issue provides a detailed example illustrating the incorrect behavior, identifies the specific part of the code that needs to be fixed, and discusses the potential theory behind the problem and possible solutions. The reporter even suggests that the current algorithm may be based on an incorrect theorem and proposes a brute-force alternative, while expressing interest in finding a better method. All the necessary information is provided to understand the problem and begin working on a solution without needing further clarification.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24539": {
        "explanation": "The issue is well-specified. The problem is clearly described with a specific example showing the current behavior. The expected behavior is also implied (the as_expr method should use the provided symbols instead of ignoring them). The code location is provided (with a link to the specific lines in the file), and there's a concrete test case showing the incorrect behavior. This provides enough information to understand what needs to be fixed and how to verify the fix.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24562": {
        "explanation": "The issue is reporting a discrepancy in the behavior of the Rational function in SymPy version 1.11.1 when passing string arguments versus numeric arguments. The problem is clearly described with specific examples (Rational('0.5', '100') vs Rational(0.5, 100)) and the expected behavior is indicated by referencing that SymPy 1.8 works correctly. The Python version and SymPy version are also provided, which helps with debugging. All necessary information is provided to understand the problem and attempt a solution.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24661": {
        "explanation": "The issue is well-specified because it clearly explains the problem (evaluate=False is ignored for relationals), provides a specific example of the issue (parse_expr('1 < 2', evaluate=False) returning True instead of 1 < 2), and shows what the expected result should be. The example makes it clear what the desired behavior is and what needs to be fixed in the code. A developer could use this information to locate where the parse_expr function handles relationals and modify the code to respect the evaluate=False parameter for these cases.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24723": {
        "explanation": "The issue is well-specified because it provides a clear problem statement, expected outcome, and actual outcome. It also includes a reference to the correct formula from Wikipedia and a code example demonstrating the discrepancy. The problem is to correct the constant in the PDF of the Matrix Normal Distribution in Sympy. The required solution is clear: to modify the constant from 2e/(2\u03c0) to e/(2\u03c0) as per the correct formula.",
        "label": "WELL_SPECIFIED"
    },
    "sympy__sympy-24909": {
        "explanation": "The issue is well-specified and it is clear what is required for a successful solution. The problem is described with a clear example of the current behavior versus the expected behavior. The user provides a specific case where 'milli*W' evaluates to 1 instead of the expected 'milliwatts' or 'mW'. The issue is reproducible and has a clear expected outcome.",
        "label": "WELL_SPECIFIED"
    }
}